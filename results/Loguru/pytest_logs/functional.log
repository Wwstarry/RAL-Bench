F.FFF..FFF.                                                              [100%]
================================== FAILURES ===================================
______________________ test_basic_levels_and_formatting _______________________

    def test_basic_levels_and_formatting() -> None:
        log, buf = make_buffer_logger(fmt="{level}:{message}", level="DEBUG")
    
        log.debug("debug-msg")
        log.info("info-msg")
        log.warning("warn-msg")
    
        lines = _lines(buf)
>       assert len(lines) >= 3
E       AssertionError: assert 1 >= 3
E        +  where 1 = len(['DEBUG:debug-msgINFO:info-msgWARNING:warn-msg'])

tests\Loguru\functional_test.py:105: AssertionError
_______________________ test_log_method_with_level_name _______________________

    def test_log_method_with_level_name() -> None:
        log, buf = make_buffer_logger(fmt="{level}:{message}", level="DEBUG")
    
>       log.log("INFO", "hello-info")
E       AttributeError: 'Logger' object has no attribute 'log'

tests\Loguru\functional_test.py:125: AttributeError
_______________________ test_bind_extra_renders_fields ________________________

    def test_bind_extra_renders_fields() -> None:
        log, buf = make_buffer_logger(fmt="{level}:{message} user={extra[user]} req={extra[request_id]}")
    
        bound = log.bind(user="alice", request_id="req-123")
        bound.info("hello")
    
        out = buf.getvalue()
>       assert "INFO:" in out
E       AssertionError: assert 'INFO:' in ''

tests\Loguru\functional_test.py:140: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-15 11:37:08.480 +08:00 | INFO     | functional_test:test_bind_extra_renders_fields:137 - hello
____________________ test_contextualize_adds_extra_fields _____________________

    def test_contextualize_adds_extra_fields() -> None:
        log, buf = make_buffer_logger(fmt="{message} user={extra[user]}")
    
>       with log.contextualize(user="bob"):
E       AttributeError: 'Logger' object has no attribute 'contextualize'

tests\Loguru\functional_test.py:149: AttributeError
______________ test_serialize_output_contains_message_and_level _______________

    def test_serialize_output_contains_message_and_level() -> None:
        # serialize=True should emit JSON per record into the sink
        log, buf = make_buffer_logger(level="INFO", serialize=True)
    
        log.info("json-msg")
    
        raw_lines = _lines(buf)
        assert len(raw_lines) >= 1
    
>       record = json.loads(raw_lines[-1])

tests\Loguru\functional_test.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:346: in loads
    return _default_decoder.decode(s)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.decoder.JSONDecoder object at 0x0000023AB930BCD0>
s = 'INFO:json-msg', idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\decoder.py:355: JSONDecodeError
_____________________ test_patch_can_enrich_record_extra ______________________

    def test_patch_can_enrich_record_extra() -> None:
        # patch() lets us enrich record data in a typical usage pattern
        log, buf = make_buffer_logger(fmt="{message} patched={extra[patched]}")
    
>       patched = log.patch(lambda r: r["extra"].update({"patched": "yes"}))
E       AttributeError: 'Logger' object has no attribute 'patch'

tests\Loguru\functional_test.py:211: AttributeError
________________ test_filter_callable_allows_subset_of_records ________________

    def test_filter_callable_allows_subset_of_records() -> None:
        def only_info(record) -> bool:
            return record["level"].name == "INFO"
    
        log, buf = make_buffer_logger(fmt="{level}:{message}", level="DEBUG", filter_=only_info)
    
        log.debug("nope")
        log.info("yep")
    
        out = buf.getvalue()
        assert "nope" not in out
>       assert "yep" in out
E       AssertionError: assert 'yep' in ''

tests\Loguru\functional_test.py:230: AssertionError
=========================== short test summary info ===========================
FAILED tests/Loguru/functional_test.py::test_basic_levels_and_formatting - As...
FAILED tests/Loguru/functional_test.py::test_log_method_with_level_name - Att...
FAILED tests/Loguru/functional_test.py::test_bind_extra_renders_fields - Asse...
FAILED tests/Loguru/functional_test.py::test_contextualize_adds_extra_fields
FAILED tests/Loguru/functional_test.py::test_serialize_output_contains_message_and_level
FAILED tests/Loguru/functional_test.py::test_patch_can_enrich_record_extra - ...
FAILED tests/Loguru/functional_test.py::test_filter_callable_allows_subset_of_records
7 failed, 4 passed in 0.60s
