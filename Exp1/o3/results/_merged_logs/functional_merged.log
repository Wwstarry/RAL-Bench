####################################################################################################
# MODEL: o3
# NUM_PROJECT_LOGS: 37
####################################################################################################

==========================================================================================
PROJECT: Astral
LOG: D:\桌面\Exp1\o3\results\Astral\pytest_logs\functional.log
==========================================================================================
...........                                                              [100%]
11 passed in 0.21s

==========================================================================================
PROJECT: Cachetools
LOG: D:\桌面\Exp1\o3\results\Cachetools\pytest_logs\functional.log
==========================================================================================
.............                                                            [100%]
13 passed in 1.68s

==========================================================================================
PROJECT: Celery
LOG: D:\桌面\Exp1\o3\results\Celery\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFF                                                               [100%]
================================== FAILURES ===================================
___________________ test_001_import_celery_and_core_symbols ___________________

    def test_001_import_celery_and_core_symbols() -> None:
        _ensure_celery_importable()
        import celery  # noqa: F401
    
        from celery import Celery  # noqa: F401
>       from celery import chain, chord, group, signature  # noqa: F401
E       ImportError: cannot import name 'chain' from 'celery' (D:\桌面\RealAppCodeBench_generic_eval\generation\Celery\celery\__init__.py)

tests\Celery\functional_test.py:61: ImportError
______________ test_002_create_app_and_register_task_runs_delay _______________

    def test_002_create_app_and_register_task_runs_delay() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() missing 1 required positional argument: 'mapping'

tests\Celery\functional_test.py:41: TypeError
____ test_003_apply_async_supports_kwargs_and_counts_down_ignored_in_eager ____

    def test_003_apply_async_supports_kwargs_and_counts_down_ignored_in_eager() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() missing 1 required positional argument: 'mapping'

tests\Celery\functional_test.py:41: TypeError
__________________ test_004_group_collects_results_in_order ___________________

    def test_004_group_collects_results_in_order() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() missing 1 required positional argument: 'mapping'

tests\Celery\functional_test.py:41: TypeError
____________________ test_005_chain_passes_previous_result ____________________

    def test_005_chain_passes_previous_result() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() missing 1 required positional argument: 'mapping'

tests\Celery\functional_test.py:41: TypeError
_______________ test_006_chord_runs_callback_over_group_results _______________

    def test_006_chord_runs_callback_over_group_results() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() missing 1 required positional argument: 'mapping'

tests\Celery\functional_test.py:41: TypeError
______________ test_007_task_exception_propagates_in_eager_mode _______________

    def test_007_task_exception_propagates_in_eager_mode() -> None:
        """
        In some Celery versions/configs with task_always_eager=True and
        task_eager_propagates=True, the exception is raised immediately during
        delay()/apply_async() rather than on AsyncResult.get().
    
        This test accepts both correct behaviors:
        - delay raises ValueError directly, OR
        - delay returns a result whose .get() raises ValueError.
        """
>       app = _make_app()

tests\Celery\functional_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() missing 1 required positional argument: 'mapping'

tests\Celery\functional_test.py:41: TypeError
_____________ test_008_disable_propagation_returns_failed_result ______________

    def test_008_disable_propagation_returns_failed_result() -> None:
        """
        With task_eager_propagates=False:
          - Some Celery builds still raise on get(..., propagate=True)
          - get(..., propagate=False) may return None OR return the exception object
        We accept both behaviors as long as the task is marked failed.
        """
>       app = _make_app()

tests\Celery\functional_test.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() missing 1 required positional argument: 'mapping'

tests\Celery\functional_test.py:41: TypeError
_______________ test_009_signature_freeze_has_id_and_task_name ________________

    def test_009_signature_freeze_has_id_and_task_name() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() missing 1 required positional argument: 'mapping'

tests\Celery\functional_test.py:41: TypeError
____________ test_010_default_app_does_not_break_custom_app_usage _____________

    def test_010_default_app_does_not_break_custom_app_usage() -> None:
        """
        Ensure that importing celery and using a custom app is not polluted by globals.
        """
>       app = _make_app("celery_test_app_2")

tests\Celery\functional_test.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app_2'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() missing 1 required positional argument: 'mapping'

tests\Celery\functional_test.py:41: TypeError
=========================== short test summary info ===========================
FAILED tests/Celery/functional_test.py::test_001_import_celery_and_core_symbols
FAILED tests/Celery/functional_test.py::test_002_create_app_and_register_task_runs_delay
FAILED tests/Celery/functional_test.py::test_003_apply_async_supports_kwargs_and_counts_down_ignored_in_eager
FAILED tests/Celery/functional_test.py::test_004_group_collects_results_in_order
FAILED tests/Celery/functional_test.py::test_005_chain_passes_previous_result
FAILED tests/Celery/functional_test.py::test_006_chord_runs_callback_over_group_results
FAILED tests/Celery/functional_test.py::test_007_task_exception_propagates_in_eager_mode
FAILED tests/Celery/functional_test.py::test_008_disable_propagation_returns_failed_result
FAILED tests/Celery/functional_test.py::test_009_signature_freeze_has_id_and_task_name
FAILED tests/Celery/functional_test.py::test_010_default_app_does_not_break_custom_app_usage
10 failed in 0.47s

==========================================================================================
PROJECT: Click
LOG: D:\桌面\Exp1\o3\results\Click\pytest_logs\functional.log
==========================================================================================
.F.FF.FFFFF                                                              [100%]
================================== FAILURES ===================================
________________________ test_boolean_flag_option_pair ________________________

    def test_boolean_flag_option_pair():
        @click.command()
        @click.option("--flag/--no-flag", default=False)
        def cli(flag: bool) -> None:
            click.echo(f"FLAG={flag}")
    
        runner = CliRunner()
    
        r1 = runner.invoke(cli, ["--flag"])
>       assert r1.exit_code == 0
E       assert 1 == 0
E        +  where 1 = <Result 1>.exit_code

tests\Click\functional_test.py:157: AssertionError
___________________ test_help_output_for_command_and_group ____________________

    def test_help_output_for_command_and_group():
        @click.group(help="Top level group")
        def cli() -> None:
            pass
    
        @cli.command(help="Say hello")
        @click.option("--shout/--no-shout", default=False)
        @click.argument("name")
        def hello(name: str, shout: bool) -> None:
            msg = f"Hello {name}"
            if shout:
                msg = msg.upper()
            click.echo(msg)
    
        runner = CliRunner()
    
        group_help = runner.invoke(cli, ["--help"])
        assert group_help.exit_code == 0
        assert "Top level group" in group_help.output
        assert "hello" in group_help.output
    
        cmd_help = runner.invoke(cli, ["hello", "--help"])
        assert cmd_help.exit_code == 0
        assert "Say hello" in cmd_help.output
>       assert "--shout" in cmd_help.output
E       AssertionError: assert '--shout' in 'Usage: cli COMMAND [ARGS]...\n\nTop level group\n\nCommands:\n  hello  Say hello\n'
E        +  where 'Usage: cli COMMAND [ARGS]...\n\nTop level group\n\nCommands:\n  hello  Say hello\n' = <Result 0>.output

tests\Click\functional_test.py:215: AssertionError
____________________ test_get_current_context_propagation _____________________

    def test_get_current_context_propagation():
        @click.group()
        @click.option("--config", type=str, default="default.cfg")
        def cli(config: str) -> None:
            ctx = click.get_current_context()
            ctx.obj = {"config": config}
    
        @cli.command()
        def show() -> None:
            ctx = click.get_current_context()
            cfg = ctx.obj.get("config")
            click.echo(f"CONFIG={cfg}")
    
        runner = CliRunner()
        result = runner.invoke(cli, ["--config", "custom.cfg", "show"])
    
>       assert result.exit_code == 0
E       assert 1 == 0
E        +  where 1 = <Result 1>.exit_code

tests\Click\functional_test.py:235: AssertionError
_____________________ test_option_envvar_default_is_used ______________________

    def test_option_envvar_default_is_used():
        @click.command()
        @click.option("--name", envvar="CLICK_TEST_NAME", default="fallback")
>       def cli(name: str) -> None:

tests\Click\functional_test.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Click\click\decorators.py:34: in decorator
    _attach_param(f, Option(param_decls, **attrs))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <click.core.Option object at 0x000001A2D33794F0>
param_decls = ('--name',), is_flag = False
attrs = {'default': 'fallback', 'envvar': 'CLICK_TEST_NAME'}, name = 'name'

    def __init__(
        self,
        param_decls: Sequence[str],
        is_flag: bool = False,
        **attrs: Any,
    ) -> None:
        if not param_decls:
            raise TypeError("At least one option string is required.")
        self.param_decls = list(param_decls)
        name = self._infer_name()
>       super().__init__(name, param_type="option", **attrs)
E       TypeError: __init__() got an unexpected keyword argument 'envvar'

generation\Click\click\core.py:207: TypeError
________________ test_prompt_option_can_be_satisfied_via_input ________________

    def test_prompt_option_can_be_satisfied_via_input():
        @click.command()
        @click.option("--token", prompt=True)
        def cli(token: str) -> None:
            click.echo(f"TOKEN={token}")
    
        runner = CliRunner()
        r = runner.invoke(cli, [], input="secret-token\n")
>       assert r.exit_code == 0
E       assert 1 == 0
E        +  where 1 = <Result 1>.exit_code

tests\Click\functional_test.py:285: AssertionError
_______________ test_default_map_provides_default_option_value ________________

    def test_default_map_provides_default_option_value():
        @click.group()
        def cli() -> None:
            pass
    
        @cli.command()
        @click.option("--count", type=int, default=1)
        def run(count: int) -> None:
            click.echo(f"COUNT={count}")
    
        runner = CliRunner()
>       r = runner.invoke(cli, ["run"], default_map={"run": {"count": 7}})
E       TypeError: invoke() got an unexpected keyword argument 'default_map'

tests\Click\functional_test.py:300: TypeError
_______________ test_parameter_type_validation_error_exit_code ________________

    def test_parameter_type_validation_error_exit_code():
        @click.command()
        @click.option("--count", type=int, required=True)
        def cli(count: int) -> None:
            click.echo(f"COUNT={count}")
    
        runner = CliRunner()
        r = runner.invoke(cli, ["--count", "not-an-int"])
        assert r.exit_code != 0
>       assert ("Invalid value" in r.output) or ("Error" in r.output)
E       AssertionError: assert ('Invalid value' in '' or 'Error' in '')
E        +  where '' = <Result 1>.output
E        +  and   '' = <Result 1>.output

tests\Click\functional_test.py:314: AssertionError
_____________ test_path_type_creates_writable_path_in_isolated_fs _____________

    def test_path_type_creates_writable_path_in_isolated_fs():
        @click.command()
>       @click.option("--out", type=click.Path(dir_okay=False, writable=True))
E       AttributeError: module 'click' has no attribute 'Path'

tests\Click\functional_test.py:319: AttributeError
=========================== short test summary info ===========================
FAILED tests/Click/functional_test.py::test_boolean_flag_option_pair - assert...
FAILED tests/Click/functional_test.py::test_help_output_for_command_and_group
FAILED tests/Click/functional_test.py::test_get_current_context_propagation
FAILED tests/Click/functional_test.py::test_option_envvar_default_is_used - T...
FAILED tests/Click/functional_test.py::test_prompt_option_can_be_satisfied_via_input
FAILED tests/Click/functional_test.py::test_default_map_provides_default_option_value
FAILED tests/Click/functional_test.py::test_parameter_type_validation_error_exit_code
FAILED tests/Click/functional_test.py::test_path_type_creates_writable_path_in_isolated_fs
8 failed, 3 passed in 2.94s

==========================================================================================
PROJECT: Cmd2
LOG: D:\桌面\Exp1\o3\results\Cmd2\pytest_logs\functional.log
==========================================================================================
EEEEEEEEEEE                                                              [100%]
=================================== ERRORS ====================================
_______________ ERROR at setup of test_simple_command_execution _______________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A0241220>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A0241220>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
______________ ERROR at setup of test_default_argument_behavior _______________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029D790>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029D790>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
______________ ERROR at setup of test_echo_arguments_and_parsing ______________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A024C250>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A024C250>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
______________ ERROR at setup of test_echo_arguments_with_quotes ______________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A0303B20>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A0303B20>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
_______________ ERROR at setup of test_help_for_custom_command ________________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029C430>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029C430>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
_____________ ERROR at setup of test_help_top_level_contains_help _____________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02419D0>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02419D0>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
____________ ERROR at setup of test_unknown_command_reports_error _____________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02823A0>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02823A0>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
________________ ERROR at setup of test_empty_command_is_noop _________________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02FA6A0>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02FA6A0>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
____________ ERROR at setup of test_multiple_commands_and_history _____________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029DD30>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029DD30>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
___________ ERROR at setup of test_history_object_records_commands ____________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A025CBB0>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A025CBB0>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
_______ ERROR at setup of test_quit_command_sets_stop_flag_and_outputs ________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A01E6820>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A01E6820>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
=========================== short test summary info ===========================
ERROR tests/Cmd2/functional_test.py::test_simple_command_execution - Attribut...
ERROR tests/Cmd2/functional_test.py::test_default_argument_behavior - Attribu...
ERROR tests/Cmd2/functional_test.py::test_echo_arguments_and_parsing - Attrib...
ERROR tests/Cmd2/functional_test.py::test_echo_arguments_with_quotes - Attrib...
ERROR tests/Cmd2/functional_test.py::test_help_for_custom_command - Attribute...
ERROR tests/Cmd2/functional_test.py::test_help_top_level_contains_help - Attr...
ERROR tests/Cmd2/functional_test.py::test_unknown_command_reports_error - Att...
ERROR tests/Cmd2/functional_test.py::test_empty_command_is_noop - AttributeEr...
ERROR tests/Cmd2/functional_test.py::test_multiple_commands_and_history - Att...
ERROR tests/Cmd2/functional_test.py::test_history_object_records_commands - A...
ERROR tests/Cmd2/functional_test.py::test_quit_command_sets_stop_flag_and_outputs
11 errors in 27.89s

==========================================================================================
PROJECT: Dataset
LOG: D:\桌面\Exp1\o3\results\Dataset\pytest_logs\functional.log
==========================================================================================
FF...F..F.F                                                              [100%]
================================== FAILURES ===================================
______________________ test_insert_and_query_basic_rows _______________________

    def test_insert_and_query_basic_rows() -> None:
        db = create_in_memory_db()
        table = db["users"]
    
        table.insert({"name": "Alice", "age": 30, "country": "DE"})
        table.insert({"name": "Bob", "age": 41, "country": "US", "active": True})
        table.insert({"name": "Charlie", "age": 41, "country": "US", "active": False})
    
        assert "id" in _table_columns(table)
        assert "name" in _table_columns(table)
        assert "country" in _table_columns(table)
        assert len(table) == 3
    
        alice = table.find_one(name="Alice")
        assert alice is not None
        assert alice["country"] == "DE"
    
>       older = list(table.find(age={">=": 40}))

tests\Dataset\functional_test.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <dataset.table.Table object at 0x000001AB56FFFA90>
where = '"age" = :age', params = {'age': {'>=': 40}}

    def _select(
        self, where: str | None = None, params: Dict[str, Any] | None = None
    ) -> Iterator[Dict[str, Any]]:
        sql = f'SELECT * FROM "{self.name}"'
        if where:
            sql += f" WHERE {where}"
>       cur = self._db.connection.execute(sql, params or {})
E       sqlite3.InterfaceError: Error binding parameter :age - probably unsupported type.

generation\Dataset\dataset\table.py:143: InterfaceError
_______________________ test_update_upsert_and_indexes ________________________

    def test_update_upsert_and_indexes() -> None:
        db = create_in_memory_db()
        table = db["accounts"]
    
        rows = [
            {"account_id": 1, "owner": "Alice", "balance": 100.0, "currency": "EUR"},
            {"account_id": 2, "owner": "Bob", "balance": 250.0, "currency": "USD"},
        ]
        table.insert_many(rows)
    
        if hasattr(table, "create_index") and hasattr(table, "has_index"):
            table.create_index(["owner", "currency"])
            assert table.has_index(["owner", "currency"])
    
        table.update({"account_id": 1, "balance": 150.0}, ["account_id"])
        updated = table.find_one(account_id=1)
        assert updated is not None
>       assert pytest.approx(updated["balance"]) == 150.0
E       assert 150.0 == 150.0
E         
E         comparison failed
E         Obtained: 150.0
E         Expected: 150.0

tests\Dataset\functional_test.py:184: AssertionError
_______________________ test_find_order_by_limit_offset _______________________

    def test_find_order_by_limit_offset() -> None:
        db = create_in_memory_db()
        table = db["nums"]
        for i in range(10):
            table.insert({"n": i})
    
        rows = list(table.find(order_by="n", _limit=3, _offset=4))
>       assert [r["n"] for r in rows] == [4, 5, 6]
E       assert [] == [4, 5, 6]
E         
E         Right contains 3 more items, first extra item: 4
E         Use -v to get more diff

tests\Dataset\functional_test.py:249: AssertionError
___________________ test_drop_table_removes_from_db_tables ____________________

    def test_drop_table_removes_from_db_tables() -> None:
        db = create_in_memory_db()
        table = db["to_drop"]
        table.insert({"x": 1})
    
>       assert "to_drop" in _db_tables(db)
E       AssertionError: assert 'to_drop' in []
E        +  where [] = _db_tables(<dataset.database.Database object at 0x000001AB570920A0>)

tests\Dataset\functional_test.py:301: AssertionError
_____________________ test_distinct_returns_unique_values _____________________

    def test_distinct_returns_unique_values() -> None:
        db = create_in_memory_db()
        table = db["colors"]
        table.insert_many([{"c": "red"}, {"c": "red"}, {"c": "blue"}])
    
        distinct = list(table.distinct("c"))
>       values = {r["c"] for r in distinct}

tests\Dataset\functional_test.py:333: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001AB56FBF610>

>   values = {r["c"] for r in distinct}
E   TypeError: string indices must be integers

tests\Dataset\functional_test.py:333: TypeError
=========================== short test summary info ===========================
FAILED tests/Dataset/functional_test.py::test_insert_and_query_basic_rows - s...
FAILED tests/Dataset/functional_test.py::test_update_upsert_and_indexes - ass...
FAILED tests/Dataset/functional_test.py::test_find_order_by_limit_offset - as...
FAILED tests/Dataset/functional_test.py::test_drop_table_removes_from_db_tables
FAILED tests/Dataset/functional_test.py::test_distinct_returns_unique_values
5 failed, 6 passed in 3.70s

==========================================================================================
PROJECT: Fail2ban
LOG: D:\桌面\Exp1\o3\results\Fail2ban\pytest_logs\functional.log
==========================================================================================
...F....F...                                                             [100%]
================================== FAILURES ===================================
________________ test_004_filter_core_symbols_exist_statically ________________

    def test_004_filter_core_symbols_exist_statically():
        """
        Do not assume helper names like isValidIP/searchIP (they vary across versions).
        Instead, require stable core anchors in fail2ban.server.filter:
          - A Filter class (or similarly named core filter object), OR
          - presence of key tokens that indicate regex-driven filtering (failregex/<HOST>).
        """
        filter_py = _pkg_dir() / "server" / "filter.py"
        src = _read_text(filter_py)
    
        has_filter_class = _ast_has_class(filter_py, "Filter") or ("class Filter" in src)
        has_regex_tokens = ("failregex" in src.lower()) or ("<host>" in src.lower())
    
>       assert has_filter_class or has_regex_tokens, "Expected core filter anchors (Filter class or failregex/<HOST> tokens)."
E       AssertionError: Expected core filter anchors (Filter class or failregex/<HOST> tokens).
E       assert (False or False)

tests\Fail2ban\functional_test.py:129: AssertionError
____________ test_009_import_filter_and_basic_behavior_if_possible ____________

    def test_009_import_filter_and_basic_behavior_if_possible():
        _prepend_import_path()
        try:
            from fail2ban.server import filter as f
        except ModuleNotFoundError as e:
            msg = str(e).lower()
            assert any(k in msg for k in ["pwd", "grp", "resource", "fcntl"]), f"Unexpected import failure: {e}"
            return
    
        # If import works, ensure the module exposes a core Filter-like object or regex constants.
        if hasattr(f, "Filter"):
            assert callable(getattr(f, "Filter"))
        else:
            src = _read_text(_pkg_dir() / "server" / "filter.py").lower()
>           assert ("failregex" in src) or ("<host>" in src)
E           assert ('failregex' in '"""\nfail2ban.server.filter\n======================\n\na *very* small helper module that offers the api surface requi...ier to locate.\n    m4 = _ipv4_re.search(text)\n    if m4:\n        return m4.group(0)\n\n    return _first_ipv6(text)' or '<host>' in '"""\nfail2ban.server.filter\n======================\n\na *very* small helper module that offers the api surface requi...ier to locate.\n    m4 = _ipv4_re.search(text)\n    if m4:\n        return m4.group(0)\n\n    return _first_ipv6(text)')

tests\Fail2ban\functional_test.py:187: AssertionError
=========================== short test summary info ===========================
FAILED tests/Fail2ban/functional_test.py::test_004_filter_core_symbols_exist_statically
FAILED tests/Fail2ban/functional_test.py::test_009_import_filter_and_basic_behavior_if_possible
2 failed, 10 passed in 1.26s

==========================================================================================
PROJECT: Folium
LOG: D:\桌面\Exp1\o3\results\Folium\pytest_logs\functional.log
==========================================================================================
.FFFFFFFFFFF                                                             [100%]
================================== FAILURES ===================================
___________________________ test_001_import_folium ____________________________

    def test_001_import_folium():
        _prepend_import_path()
>       import folium  # noqa: F401
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:39: SyntaxError
__________________ test_002_create_basic_map_renders_leaflet __________________

    def test_002_create_basic_map_renders_leaflet():
        _prepend_import_path()
>       import folium
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:44: SyntaxError
_________________________ test_003_map_has_html_root __________________________

    def test_003_map_has_html_root():
        _prepend_import_path()
>       import folium
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:53: SyntaxError
__________________ test_004_add_marker_layer_changes_output ___________________

    def test_004_add_marker_layer_changes_output():
        _prepend_import_path()
>       import folium
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:64: SyntaxError
__________________ test_005_add_circle_marker_changes_output __________________

    def test_005_add_circle_marker_changes_output():
        _prepend_import_path()
>       import folium
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:77: SyntaxError
__________________ test_006_add_tile_layer_and_layer_control __________________

    def test_006_add_tile_layer_and_layer_control():
        _prepend_import_path()
>       import folium
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:89: SyntaxError
__________________ test_007_geojson_adds_feature_collection ___________________

    def test_007_geojson_adds_feature_collection():
        _prepend_import_path()
>       import folium
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:101: SyntaxError
_________________ test_008_geojson_style_function_serializes __________________

    def test_008_geojson_style_function_serializes():
        _prepend_import_path()
>       import folium
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:123: SyntaxError
________________________ test_009_map_save_writes_html ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-464/test_009_map_save_writes_html0')

    def test_009_map_save_writes_html(tmp_path: Path):
        _prepend_import_path()
>       import folium
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:149: SyntaxError
______________ test_010_plugins_markercluster_module_importable _______________

    def test_010_plugins_markercluster_module_importable():
        _prepend_import_path()
>       plugins = _plugins_module()

tests\Folium\functional_test.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Folium\functional_test.py:29: in _plugins_module
    return importlib.import_module("folium.plugins")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:786: in exec_module
    ???
<frozen importlib._bootstrap_external>:923: in get_code
    ???
<frozen importlib._bootstrap_external>:853: in source_to_code
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <built-in function compile>
args = (b'"""\r\nA very small subset of the `folium` API implemented in pure-Python.\r\n\r\nOnly the functionality required b... of folium.plugins.__init__', 'D:\\桌面\\RealAppCodeBench_generic_eval\\generation\\Folium\\folium\\__init__.py', 'exec')
kwds = {'dont_inherit': True, 'optimize': -1}

>   ???
E     File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E       """
E          ^
E   SyntaxError: f-string expression part cannot include a backslash

<frozen importlib._bootstrap>:228: SyntaxError
_________________ test_011_markercluster_adds_cluster_snippet _________________

    def test_011_markercluster_adds_cluster_snippet():
        _prepend_import_path()
>       import folium
E         File "D:\桌面\RealAppCodeBench_generic_eval\generation\Folium\folium\__init__.py", line 305
E           """
E              ^
E       SyntaxError: f-string expression part cannot include a backslash

tests\Folium\functional_test.py:168: SyntaxError
=========================== short test summary info ===========================
FAILED tests/Folium/functional_test.py::test_001_import_folium -   File "D:\...
FAILED tests/Folium/functional_test.py::test_002_create_basic_map_renders_leaflet
FAILED tests/Folium/functional_test.py::test_003_map_has_html_root -   File "...
FAILED tests/Folium/functional_test.py::test_004_add_marker_layer_changes_output
FAILED tests/Folium/functional_test.py::test_005_add_circle_marker_changes_output
FAILED tests/Folium/functional_test.py::test_006_add_tile_layer_and_layer_control
FAILED tests/Folium/functional_test.py::test_007_geojson_adds_feature_collection
FAILED tests/Folium/functional_test.py::test_008_geojson_style_function_serializes
FAILED tests/Folium/functional_test.py::test_009_map_save_writes_html -   Fil...
FAILED tests/Folium/functional_test.py::test_010_plugins_markercluster_module_importable
FAILED tests/Folium/functional_test.py::test_011_markercluster_adds_cluster_snippet
11 failed, 1 passed in 0.60s

==========================================================================================
PROJECT: Glances
LOG: D:\桌面\Exp1\o3\results\Glances\pytest_logs\functional.log
==========================================================================================
............                                                             [100%]
12 passed in 1.32s

==========================================================================================
PROJECT: Humanize
LOG: D:\桌面\Exp1\o3\results\Humanize\pytest_logs\functional.log
==========================================================================================
..F.......sss..                                                          [100%]
================================== FAILURES ===================================
______________________________ test_naturalsize _______________________________

    def test_naturalsize() -> None:
>       assert humanize.naturalsize(1024) == "1.0 kB"
E       AssertionError: assert '1 kB' == '1.0 kB'
E         
E         - 1.0 kB
E         ?  --
E         + 1 kB

tests\Humanize\functional_test.py:107: AssertionError
=========================== short test summary info ===========================
FAILED tests/Humanize/functional_test.py::test_naturalsize - AssertionError: ...
1 failed, 11 passed, 3 skipped in 0.50s

==========================================================================================
PROJECT: Imageio
LOG: D:\桌面\Exp1\o3\results\Imageio\pytest_logs\functional.log
==========================================================================================
...F...FF.                                                               [100%]
================================== FAILURES ===================================
_____________________ test_png_roundtrip_via_bytes_buffer _____________________

    def test_png_roundtrip_via_bytes_buffer() -> None:
        """Write PNG to in-memory bytes, then read back using extension."""
        img = _make_color_image(height=20, width=31)
    
>       blob = iio.imwrite("<bytes>", img, extension=".png")
E       TypeError: imwrite() got an unexpected keyword argument 'extension'

tests\Imageio\functional_test.py:139: TypeError
___________ test_gif_imread_index0_matches_first_imiter_frame_shape ___________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-467/test_gif_imread_index0_matches0')

    def test_gif_imread_index0_matches_first_imiter_frame_shape(tmp_path: Path) -> None:
        """Read first GIF frame using both index=0 and imiter; verify consistent spatial shape."""
        frames = _make_grayscale_frames(num_frames=4, height=19, width=23)
        path = tmp_path / "index0.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       first_by_index = iio.imread(path, index=0)
E       TypeError: imread() got an unexpected keyword argument 'index'

tests\Imageio\functional_test.py:206: TypeError
_______________________ test_imopen_write_then_read_png _______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-467/test_imopen_write_then_read_pn0')

    def test_imopen_write_then_read_png(tmp_path: Path) -> None:
        """Use the v3 imopen context manager to write then read a PNG."""
        img = _make_color_image(height=16, width=20)
        path = tmp_path / "imopen.png"
    
>       with iio.imopen(path, "w") as f:
E       AttributeError: module 'imageio.v3' has no attribute 'imopen'

tests\Imageio\functional_test.py:221: AttributeError
=========================== short test summary info ===========================
FAILED tests/Imageio/functional_test.py::test_png_roundtrip_via_bytes_buffer
FAILED tests/Imageio/functional_test.py::test_gif_imread_index0_matches_first_imiter_frame_shape
FAILED tests/Imageio/functional_test.py::test_imopen_write_then_read_png - At...
3 failed, 7 passed in 0.93s

==========================================================================================
PROJECT: Lifelines
LOG: D:\桌面\Exp1\o3\results\Lifelines\pytest_logs\functional.log
==========================================================================================
..F..FFFFFFFFFF                                                          [100%]
================================== FAILURES ===================================
____________________________ test_coxph_basic_fit _____________________________

    def test_coxph_basic_fit() -> None:
        """Fit a simple Cox proportional hazards model on a toy dataset."""
        df = _toy_cox_df()
    
        cph = CoxPHFitter()
        cph.fit(df, duration_col="duration", event_col="event")
        summary = cph.summary
    
        assert "coef" in summary.columns
        assert "se(coef)" in summary.columns
>       assert "p" in summary.columns or "p" in "".join(summary.columns).lower()
E       AssertionError: assert ('p' in Index(['coef', 'se(coef)'], dtype='object') or 'p' in 'coefse(coef)')
E        +  where Index(['coef', 'se(coef)'], dtype='object') =                coef  se(coef)\nage       -0.001841  0.011457\ntreatment  0.648316  0.707976.columns
E        +  and   'coefse(coef)' = <built-in method lower of str object at 0x000002BFFD6C6F70>()
E        +    where <built-in method lower of str object at 0x000002BFFD6C6F70> = 'coefse(coef)'.lower
E        +      where 'coefse(coef)' = <built-in method join of str object at 0x000002BFDAA64670>(Index(['coef', 'se(coef)'], dtype='object'))
E        +        where <built-in method join of str object at 0x000002BFDAA64670> = ''.join
E        +        and   Index(['coef', 'se(coef)'], dtype='object') =                coef  se(coef)\nage       -0.001841  0.011457\ntreatment  0.648316  0.707976.columns

tests\Lifelines\functional_test.py:127: AssertionError
________________ test_kmf_cumulative_density_is_non_decreasing ________________

    def test_kmf_cumulative_density_is_non_decreasing() -> None:
        """Cumulative density should be non-decreasing and within [0, 1]."""
        durations, events = _toy_kmf_data()
        kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
>       cd = kmf.cumulative_density_
E       AttributeError: 'KaplanMeierFitter' object has no attribute 'cumulative_density_'

tests\Lifelines\functional_test.py:170: AttributeError
__________________ test_kmf_event_table_has_standard_columns __________________

    def test_kmf_event_table_has_standard_columns() -> None:
        """KM event table should include standard bookkeeping columns."""
        durations, events = _toy_kmf_data()
        kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
>       et = kmf.event_table
E       AttributeError: 'KaplanMeierFitter' object has no attribute 'event_table'

tests\Lifelines\functional_test.py:183: AttributeError
_____________ test_kmf_confidence_interval_matches_survival_index _____________

    def test_kmf_confidence_interval_matches_survival_index() -> None:
        """Confidence intervals should align with survival function index."""
        durations, events = _toy_kmf_data()
        kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
>       ci = kmf.confidence_interval_
E       AttributeError: 'KaplanMeierFitter' object has no attribute 'confidence_interval_'

tests\Lifelines\functional_test.py:192: AttributeError
___________ test_kmf_median_survival_time_is_within_duration_range ____________

    def test_kmf_median_survival_time_is_within_duration_range() -> None:
        """Median survival time should be within the observed duration range."""
        durations, events = _toy_kmf_data()
        kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
    
>       m = float(kmf.median_survival_time_)
E       AttributeError: 'KaplanMeierFitter' object has no attribute 'median_survival_time_'

tests\Lifelines\functional_test.py:206: AttributeError
_________________ test_coxph_params_index_matches_covariates __________________

    def test_coxph_params_index_matches_covariates() -> None:
        """Cox model params_ should be indexed by covariate names."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
        params = cph.params_
>       assert list(params.index) == ["age", "treatment"]
E       AttributeError: 'numpy.ndarray' object has no attribute 'index'

tests\Lifelines\functional_test.py:216: AttributeError
___________ test_coxph_baseline_cumulative_hazard_is_non_decreasing ___________

    def test_coxph_baseline_cumulative_hazard_is_non_decreasing() -> None:
        """Baseline cumulative hazard should be non-decreasing over time."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
>       bch = cph.baseline_cumulative_hazard_
E       AttributeError: 'CoxPHFitter' object has no attribute 'baseline_cumulative_hazard_'

tests\Lifelines\functional_test.py:225: AttributeError
__________ test_coxph_predict_partial_hazard_is_positive_and_varies ___________

    def test_coxph_predict_partial_hazard_is_positive_and_varies() -> None:
        """Partial hazards should be positive and reflect covariate differences."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
        x_low = pd.DataFrame({"age": [25], "treatment": [0]})
        x_high = pd.DataFrame({"age": [55], "treatment": [1]})
    
>       h_low = float(cph.predict_partial_hazard(x_low).iloc[0])
E       AttributeError: 'CoxPHFitter' object has no attribute 'predict_partial_hazard'

tests\Lifelines\functional_test.py:240: AttributeError
____________ test_coxph_predict_survival_function_shape_and_bounds ____________

    def test_coxph_predict_survival_function_shape_and_bounds() -> None:
        """Predict survival functions for two individuals; verify shape and bounds."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
        x = pd.DataFrame({"age": [30, 60], "treatment": [0, 1]})
>       sf = cph.predict_survival_function(x)

tests\Lifelines\functional_test.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <lifelines.coxph_fitter.CoxPHFitter object at 0x000002BFFF75BF70>
row =    age  treatment
0   30          0
1   60          1, times = None

    def predict_survival_function(
        self, row: pd.DataFrame, times: Optional[np.ndarray] = None
    ) -> pd.DataFrame:
        """
        Predict the survival function for a single row of covariate values.
        """
        if self.params_ is None:
            raise RuntimeError("Model has not been fitted yet.")
        if row.shape[0] != 1:
>           raise ValueError("Row must contain exactly one observation.")
E           ValueError: Row must contain exactly one observation.

generation\Lifelines\lifelines\coxph_fitter.py:191: ValueError
________________ test_coxph_concordance_index_in_unit_interval ________________

    def test_coxph_concordance_index_in_unit_interval() -> None:
        """Concordance index should lie in [0, 1] after fitting."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
>       c = float(cph.concordance_index_)
E       AttributeError: 'CoxPHFitter' object has no attribute 'concordance_index_'

tests\Lifelines\functional_test.py:269: AttributeError
_____________ test_coxph_fit_on_waltons_with_binary_group_feature _____________

    def test_coxph_fit_on_waltons_with_binary_group_feature() -> None:
        """Fit CoxPH on Waltons dataset using a binary treated indicator derived from group."""
        df = load_waltons()
        assert {"T", "E", "group"}.issubset(df.columns)
    
        df2 = df.copy()
        df2["treated"] = (df2["group"] != "control").astype(int)
    
        model_df = df2[["T", "E", "treated"]].rename(columns={"T": "duration", "E": "event"})
    
        cph = CoxPHFitter()
        cph.fit(model_df, duration_col="duration", event_col="event")
    
>       coef = float(cph.params_.loc["treated"])
E       AttributeError: 'numpy.ndarray' object has no attribute 'loc'

tests\Lifelines\functional_test.py:286: AttributeError
=========================== short test summary info ===========================
FAILED tests/Lifelines/functional_test.py::test_coxph_basic_fit - AssertionEr...
FAILED tests/Lifelines/functional_test.py::test_kmf_cumulative_density_is_non_decreasing
FAILED tests/Lifelines/functional_test.py::test_kmf_event_table_has_standard_columns
FAILED tests/Lifelines/functional_test.py::test_kmf_confidence_interval_matches_survival_index
FAILED tests/Lifelines/functional_test.py::test_kmf_median_survival_time_is_within_duration_range
FAILED tests/Lifelines/functional_test.py::test_coxph_params_index_matches_covariates
FAILED tests/Lifelines/functional_test.py::test_coxph_baseline_cumulative_hazard_is_non_decreasing
FAILED tests/Lifelines/functional_test.py::test_coxph_predict_partial_hazard_is_positive_and_varies
FAILED tests/Lifelines/functional_test.py::test_coxph_predict_survival_function_shape_and_bounds
FAILED tests/Lifelines/functional_test.py::test_coxph_concordance_index_in_unit_interval
FAILED tests/Lifelines/functional_test.py::test_coxph_fit_on_waltons_with_binary_group_feature
11 failed, 4 passed in 2.30s

==========================================================================================
PROJECT: Loguru
LOG: D:\桌面\Exp1\o3\results\Loguru\pytest_logs\functional.log
==========================================================================================

1 skipped in 0.11s

==========================================================================================
PROJECT: Mailpile
LOG: D:\桌面\Exp1\o3\results\Mailpile\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
_____________ ERROR collecting tests/Mailpile/functional_test.py ______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\Mailpile\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\Mailpile\functional_test.py:176: in <module>
    from mailpile.safe_popen import PIPE, Popen, Safe_Pipe  # type: ignore
E   ImportError: cannot import name 'PIPE' from 'mailpile.safe_popen' (D:\桌面\RealAppCodeBench_generic_eval\.converted\Mailpile\generated\mailpile\safe_popen.py)
=========================== short test summary info ===========================
ERROR tests/Mailpile/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 1.38s

==========================================================================================
PROJECT: Markdown
LOG: D:\桌面\Exp1\o3\results\Markdown\pytest_logs\functional.log
==========================================================================================
......F..Fsssssssss                                                      [100%]
================================== FAILURES ===================================
_________________ test_html_escaping_in_text_but_not_in_code __________________

    def test_html_escaping_in_text_but_not_in_code() -> None:
        src = textwrap.dedent(
            """
            Use <b>raw HTML</b> here.
    
            ```
            literal <b> tag in code block
            ```
            """
        )
        html = markdown.markdown(src)
        norm = normalize_html(html)
    
>       assert "<b>" in norm
E       AssertionError: assert '<b>' in '<p>Use &lt;b&gt;raw HTML&lt;/b&gt; here.</p>\n<pre><code>literal &lt;b&gt; tag in code block</code></pre>'

tests\Markdown\functional_test.py:209: AssertionError
_______________________ test_horizontal_rule_renders_hr _______________________

    def test_horizontal_rule_renders_hr() -> None:
        src = textwrap.dedent(
            """
            Paragraph above
    
            ---
    
            Paragraph below
            """
        )
        html = markdown.markdown(src)
        norm = normalize_html(html)
    
>       assert "<hr" in norm
E       AssertionError: assert '<hr' in '<p>Paragraph above</p>\n<p>---</p>\n<p>Paragraph below</p>'

tests\Markdown\functional_test.py:272: AssertionError
=========================== short test summary info ===========================
FAILED tests/Markdown/functional_test.py::test_html_escaping_in_text_but_not_in_code
FAILED tests/Markdown/functional_test.py::test_horizontal_rule_renders_hr - A...
2 failed, 8 passed, 9 skipped in 0.57s

==========================================================================================
PROJECT: Mitmproxy
LOG: D:\桌面\Exp1\o3\results\Mitmproxy\pytest_logs\functional.log
==========================================================================================
..FF.FF.FFF                                                              [100%]
================================== FAILURES ===================================
_______ test_003_version_source_file_exists_and_has_version_like_token ________

    def test_003_version_source_file_exists_and_has_version_like_token():
        """
        Do NOT assume mitmproxy exposes __version__ at top-level.
        Instead, require a stable version source file under the package and a version-like token inside.
    
        This aligns better with how many projects store version information (e.g. version.py, __init__.py, or pyproject).
        """
        pkg = _mitmproxy_pkg_dir()
    
        candidates = [
            pkg / "version.py",
            pkg / "__init__.py",
        ]
    
        existing = [p for p in candidates if p.is_file()]
        assert existing, f"Expected one of these to exist: {[str(p) for p in candidates]}"
    
        text = "\n".join(_file(p).lower() for p in existing)
    
        # Accept multiple common patterns.
        # Examples: __version__ = "10.0.0", VERSION = "10.0.0", version = "10.0.0"
        import re
    
>       assert (
            re.search(r"__version__\s*=\s*['\"][^'\"]+['\"]", text)
            or re.search(r"\bversion\s*=\s*['\"][^'\"]+['\"]", text)
            or re.search(r"\bversion\b", text)
        ), "Expected a version-like assignment or token in version source files."
E       AssertionError: Expected a version-like assignment or token in version source files.
E       assert (None or None or None)
E        +  where None = <function search at 0x0000020506DA99D0>('__version__\\s*=\\s*[\'\\"][^\'\\"]+[\'\\"]', '"""\na **very** small stub of the real *mitmproxy* package.\n\nthe intention of this repository is **not** to ship a ...("mitmproxy.flow")\naddonmanager = _import_module("mitmproxy.addonmanager")\ntools = _import_module("mitmproxy.tools")')
E        +    where <function search at 0x0000020506DA99D0> = <module 're' from 'C:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\re.py'>.search
E        +  and   None = <function search at 0x0000020506DA99D0>('\\bversion\\s*=\\s*[\'\\"][^\'\\"]+[\'\\"]', '"""\na **very** small stub of the real *mitmproxy* package.\n\nthe intention of this repository is **not** to ship a ...("mitmproxy.flow")\naddonmanager = _import_module("mitmproxy.addonmanager")\ntools = _import_module("mitmproxy.tools")')
E        +    where <function search at 0x0000020506DA99D0> = <module 're' from 'C:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\re.py'>.search
E        +  and   None = <function search at 0x0000020506DA99D0>('\\bversion\\b', '"""\na **very** small stub of the real *mitmproxy* package.\n\nthe intention of this repository is **not** to ship a ...("mitmproxy.flow")\naddonmanager = _import_module("mitmproxy.addonmanager")\ntools = _import_module("mitmproxy.tools")')
E        +    where <function search at 0x0000020506DA99D0> = <module 're' from 'C:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\re.py'>.search

tests\Mitmproxy\functional_test.py:103: AssertionError
_______________________ test_004_tools_main_file_exists _______________________

    def test_004_tools_main_file_exists():
        pkg = _mitmproxy_pkg_dir()
>       assert (pkg / "tools" / "main.py").is_file()
E       AssertionError: assert False
E        +  where False = is_file()
E        +    where is_file = ((WindowsPath('D:/桌面/RealAppCodeBench_generic_eval/generation/Mitmproxy/mitmproxy') / 'tools') / 'main.py').is_file

tests\Mitmproxy\functional_test.py:112: AssertionError
_____________________ test_006_tools_cmdline_file_exists ______________________

    def test_006_tools_cmdline_file_exists():
        pkg = _mitmproxy_pkg_dir()
>       assert (pkg / "tools" / "cmdline.py").is_file()
E       AssertionError: assert False
E        +  where False = is_file()
E        +    where is_file = ((WindowsPath('D:/桌面/RealAppCodeBench_generic_eval/generation/Mitmproxy/mitmproxy') / 'tools') / 'cmdline.py').is_file

tests\Mitmproxy\functional_test.py:122: AssertionError
__________ test_007_tools_main_defines_mitmdump_function_or_wrapper ___________

    def test_007_tools_main_defines_mitmdump_function_or_wrapper():
        """
        Anchor: mitmproxy.tools.main.mitmdump should exist.
        If runtime import is blocked by missing mitmproxy_rs, we still enforce the symbol statically.
        """
        pkg = _mitmproxy_pkg_dir()
        main_py = pkg / "tools" / "main.py"
>       src = _file(main_py)

tests\Mitmproxy\functional_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Mitmproxy\functional_test.py:44: in _file
    return path.read_text(encoding="utf-8", errors="replace")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\pathlib.py:1255: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\pathlib.py:1241: in open
    return io.open(self, mode, buffering, encoding, errors, newline,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = WindowsPath('D:/桌面/RealAppCodeBench_generic_eval/generation/Mitmproxy/mitmproxy/tools/main.py')
name = 'D:\\桌面\\RealAppCodeBench_generic_eval\\generation\\Mitmproxy\\mitmproxy\\tools\\main.py'
flags = 32896, mode = 438

    def _opener(self, name, flags, mode=0o666):
        # A stub for the opener argument to built-in open()
>       return self._accessor.open(self, flags, mode)
E       FileNotFoundError: [Errno 2] No such file or directory: 'D:\\桌面\\RealAppCodeBench_generic_eval\\generation\\Mitmproxy\\mitmproxy\\tools\\main.py'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\pathlib.py:1109: FileNotFoundError
________________ test_009_proxy_mode_specs_mentions_ProxyMode _________________

    def test_009_proxy_mode_specs_mentions_ProxyMode():
        """
        Anchor: mitmproxy.proxy.mode_specs is part of the CLI import chain.
        Runtime import may require mitmproxy_rs; we assert the file contains ProxyMode constructs.
        """
        pkg = _mitmproxy_pkg_dir()
        ms_py = pkg / "proxy" / "mode_specs.py"
>       assert ms_py.is_file()
E       AssertionError: assert False
E        +  where False = is_file()
E        +    where is_file = WindowsPath('D:/桌面/RealAppCodeBench_generic_eval/generation/Mitmproxy/mitmproxy/proxy/mode_specs.py').is_file

tests\Mitmproxy\functional_test.py:156: AssertionError
_________ test_010_conditional_import_http_module_depends_on_OpenSSL __________

    def test_010_conditional_import_http_module_depends_on_OpenSSL():
        """
        Importing mitmproxy.http may require pyOpenSSL (OpenSSL module) through mitmproxy.certs.
        If OpenSSL is installed, import must succeed.
        If not installed, import must fail with ModuleNotFoundError mentioning OpenSSL.
        """
        _prepend_import_path()
        have_openssl = _has_module("OpenSSL")
        if have_openssl:
            import mitmproxy.http  # noqa: F401
        else:
            with pytest.raises(ModuleNotFoundError) as ei:
>               import mitmproxy.http  # noqa: F401
E               Failed: DID NOT RAISE <class 'ModuleNotFoundError'>

tests\Mitmproxy\functional_test.py:173: Failed
_______ test_011_conditional_import_tools_main_depends_on_mitmproxy_rs ________

    def test_011_conditional_import_tools_main_depends_on_mitmproxy_rs():
        """
        Importing mitmproxy.tools.main currently pulls in mitmproxy.proxy.mode_specs,
        which imports mitmproxy_rs. If mitmproxy_rs is installed, import should succeed.
        Otherwise, it should fail with ModuleNotFoundError mentioning mitmproxy_rs.
        """
        _prepend_import_path()
        have_rs = _has_module("mitmproxy_rs")
        if have_rs:
            from mitmproxy.tools import main as tools_main  # noqa: F401
            assert hasattr(tools_main, "mitmdump")
        else:
            with pytest.raises(ModuleNotFoundError) as ei:
>               from mitmproxy.tools import main as tools_main  # noqa: F401
E               Failed: DID NOT RAISE <class 'ModuleNotFoundError'>

tests\Mitmproxy\functional_test.py:190: Failed
=========================== short test summary info ===========================
FAILED tests/Mitmproxy/functional_test.py::test_003_version_source_file_exists_and_has_version_like_token
FAILED tests/Mitmproxy/functional_test.py::test_004_tools_main_file_exists - ...
FAILED tests/Mitmproxy/functional_test.py::test_006_tools_cmdline_file_exists
FAILED tests/Mitmproxy/functional_test.py::test_007_tools_main_defines_mitmdump_function_or_wrapper
FAILED tests/Mitmproxy/functional_test.py::test_009_proxy_mode_specs_mentions_ProxyMode
FAILED tests/Mitmproxy/functional_test.py::test_010_conditional_import_http_module_depends_on_OpenSSL
FAILED tests/Mitmproxy/functional_test.py::test_011_conditional_import_tools_main_depends_on_mitmproxy_rs
7 failed, 4 passed in 0.75s

==========================================================================================
PROJECT: Mutagen
LOG: D:\桌面\Exp1\o3\results\Mutagen\pytest_logs\functional.log
==========================================================================================

1 skipped in 0.15s

==========================================================================================
PROJECT: Pendulum
LOG: D:\桌面\Exp1\o3\results\Pendulum\pytest_logs\functional.log
==========================================================================================
FF.FFFFF.sFFF                                                            [100%]
================================== FAILURES ===================================
_____________________ test_parse_and_timezone_conversion ______________________

    def test_parse_and_timezone_conversion() -> None:
        """Parse an ISO string and convert between timezones."""
        dt_utc = pendulum.parse("2020-01-01T12:00:00+00:00")
    
        assert dt_utc.year == 2020
        assert dt_utc.month == 1
        assert dt_utc.day == 1
    
        offset_utc = dt_utc.utcoffset()
        assert offset_utc is not None
        assert offset_utc.total_seconds() == 0
    
        dt_tokyo = dt_utc.in_timezone("Asia/Tokyo")
        offset_tokyo = dt_tokyo.utcoffset()
        assert offset_tokyo is not None
        assert offset_tokyo.total_seconds() == 9 * 60 * 60
    
>       as_str = dt_tokyo.to_datetime_string()
E       AttributeError: 'DateTime' object has no attribute 'to_datetime_string'

tests\Pendulum\functional_test.py:81: AttributeError
____________________ test_datetime_arithmetic_and_duration ____________________

    def test_datetime_arithmetic_and_duration() -> None:
        """Basic arithmetic with pendulum.datetime and pendulum.duration."""
        base = pendulum.datetime(2021, 3, 15, 10, 30, 0, tz="UTC")
    
        shifted = base.add(days=2, hours=5, minutes=15)
        delta = shifted - base
    
>       assert delta.days == 2
E       assert 0 == 2
E        +  where 0 = Duration(seconds=191700).days

tests\Pendulum\functional_test.py:92: AssertionError
_____________________ test_parse_date_only_to_date_string _____________________

    def test_parse_date_only_to_date_string() -> None:
        """Parse a date-only string and verify normalized date output."""
>       d = pendulum.parse("2020-02-29")

tests\Pendulum\functional_test.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\__init__.py:63: in parse
    dt = _parse_iso_datetime(timestring)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

val = '2020-02-29'

    def _parse_iso_datetime(val: str) -> DateTime:
        """
        Very naive ISO-8601 parser sufficient for YYYY-MM-DDTHH:MM:SS[.ffffff][Z|±HH:MM]
        """
        m = _DATETIME_ISO_RE.match(val)
        if not m:
>           raise ValueError(f"Invalid ISO-8601 datetime string: {val!r}")
E           ValueError: Invalid ISO-8601 datetime string: '2020-02-29'

generation\Pendulum\pendulum\datetime.py:223: ValueError
__________________ test_datetime_to_iso8601_string_roundtrip __________________

    def test_datetime_to_iso8601_string_roundtrip() -> None:
        """Create a datetime and verify ISO8601 string contains expected offset."""
        dt = pendulum.datetime(2020, 1, 1, 12, 0, 0, tz="UTC")
>       iso = dt.to_iso8601_string()
E       AttributeError: 'DateTime' object has no attribute 'to_iso8601_string'

tests\Pendulum\functional_test.py:127: AttributeError
_____________________ test_formatting_with_custom_pattern _____________________

    def test_formatting_with_custom_pattern() -> None:
        """Verify formatting with a custom pattern is stable for a fixed datetime."""
        dt = pendulum.datetime(2021, 12, 31, 23, 59, 58, tz="UTC")
>       s = dt.format("YYYY/MM/DD HH:mm:ss")
E       AttributeError: 'DateTime' object has no attribute 'format'

tests\Pendulum\functional_test.py:136: AttributeError
__________________________ test_start_of_end_of_day ___________________________

    def test_start_of_end_of_day() -> None:
        """Check start_of and end_of for a day boundary."""
        dt = pendulum.datetime(2020, 5, 20, 13, 14, 15, tz="UTC")
    
>       sod = dt.start_of("day")
E       AttributeError: 'DateTime' object has no attribute 'start_of'

tests\Pendulum\functional_test.py:144: AttributeError
_____________________ test_weekday_and_isoweekday_values ______________________

    def test_weekday_and_isoweekday_values() -> None:
        """Validate weekday values for a known date (2020-01-01 is Wednesday)."""
>       dt = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:155: AttributeError
_____________________ test_in_timezone_preserves_instant ______________________

    def test_in_timezone_preserves_instant() -> None:
        """Converting timezones should preserve the instant (timestamp)."""
        dt_utc = pendulum.datetime(2020, 6, 1, 0, 0, 0, tz="UTC")
        dt_ny = dt_utc.in_timezone("America/New_York")
    
        assert int(dt_utc.timestamp()) == int(dt_ny.timestamp())
>       assert dt_ny.to_date_string() in ("2020-05-31", "2020-06-01")
E       AttributeError: 'DateTime' object has no attribute 'to_date_string'

tests\Pendulum\functional_test.py:202: AttributeError
________________________ test_diff_in_days_is_integer _________________________

    def test_diff_in_days_is_integer() -> None:
        """Compute diff in days between two dates."""
>       a = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:207: AttributeError
____________________ test_add_months_across_year_boundary _____________________

    def test_add_months_across_year_boundary() -> None:
        """Add months and verify year boundary transitions."""
>       dt = pendulum.date(2019, 12, 15)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:217: AttributeError
=========================== short test summary info ===========================
FAILED tests/Pendulum/functional_test.py::test_parse_and_timezone_conversion
FAILED tests/Pendulum/functional_test.py::test_datetime_arithmetic_and_duration
FAILED tests/Pendulum/functional_test.py::test_parse_date_only_to_date_string
FAILED tests/Pendulum/functional_test.py::test_datetime_to_iso8601_string_roundtrip
FAILED tests/Pendulum/functional_test.py::test_formatting_with_custom_pattern
FAILED tests/Pendulum/functional_test.py::test_start_of_end_of_day - Attribut...
FAILED tests/Pendulum/functional_test.py::test_weekday_and_isoweekday_values
FAILED tests/Pendulum/functional_test.py::test_in_timezone_preserves_instant
FAILED tests/Pendulum/functional_test.py::test_diff_in_days_is_integer - Attr...
FAILED tests/Pendulum/functional_test.py::test_add_months_across_year_boundary
10 failed, 2 passed, 1 skipped in 0.70s

==========================================================================================
PROJECT: Petl
LOG: D:\桌面\Exp1\o3\results\Petl\pytest_logs\functional.log
==========================================================================================
...ss.Fs.sss                                                             [100%]
================================== FAILURES ===================================
_____________________ test_sort_descending_orders_values ______________________

    def test_sort_descending_orders_values() -> None:
        """Sort descending by a numeric field."""
        _require_attr("sort")
    
        records = [
            {"name": "A", "score": 10},
            {"name": "B", "score": 30},
            {"name": "C", "score": 20},
        ]
        table = petl.fromdicts(records, header=["name", "score"])
    
        # petl.sort supports reverse=True in typical implementations.
>       sorted_tbl = petl.sort(table, "score", reverse=True)
E       TypeError: sort() got an unexpected keyword argument 'reverse'

tests\Petl\functional_test.py:278: TypeError
=========================== short test summary info ===========================
FAILED tests/Petl/functional_test.py::test_sort_descending_orders_values - Ty...
1 failed, 5 passed, 6 skipped in 0.52s

==========================================================================================
PROJECT: Pygments
LOG: D:\桌面\Exp1\o3\results\Pygments\pytest_logs\functional.log
==========================================================================================
Traceback (most recent call last):
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\runpy.py", line 188, in _run_module_as_main
    mod_name, mod_spec, code = _get_module_details(mod_name, _Error)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\runpy.py", line 147, in _get_module_details
    return _get_module_details(pkg_main_name, error)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\runpy.py", line 111, in _get_module_details
    __import__(pkg_name)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\pytest\__init__.py", line 8, in <module>
    from _pytest._code import ExceptionInfo
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_code\__init__.py", line 5, in <module>
    from .code import Code
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_code\code.py", line 44, in <module>
    from _pytest._io import TerminalWriter
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_io\__init__.py", line 3, in <module>
    from .terminalwriter import get_terminal_width
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_io\terminalwriter.py", line 13, in <module>
    import pygments
  File "D:\桌面\RealAppCodeBench_generic_eval\generation\Pygments\pygments\__init__.py", line 14, in <module>
    from pygments.lex import lex   # type: ignore  # re-export
  File "D:\桌面\RealAppCodeBench_generic_eval\generation\Pygments\pygments\lex.py", line 7, in <module>
    from pygments.lexers import get_lexer_by_name
  File "D:\桌面\RealAppCodeBench_generic_eval\generation\Pygments\pygments\lexers\__init__.py", line 16, in <module>
    TokenStream = Iterable[Tuple[Token, str]]
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\typing.py", line 243, in inner
    return func(*args, **kwds)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\typing.py", line 856, in __getitem__
    params = tuple(_type_check(p, msg) for p in params)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\typing.py", line 856, in <genexpr>
    params = tuple(_type_check(p, msg) for p in params)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\typing.py", line 151, in _type_check
    raise TypeError(f"{msg} Got {arg!r:.100}.")
TypeError: Tuple[t0, t1, ...]: each t must be a type. Got Token.

==========================================================================================
PROJECT: PyJWT
LOG: D:\桌面\Exp1\o3\results\PyJWT\pytest_logs\functional.log
==========================================================================================
.F.FF...F.s                                                              [100%]
================================== FAILURES ===================================
_____________________ test_hs512_encode_decode_roundtrip ______________________

    def test_hs512_encode_decode_roundtrip() -> None:
        payload = {"scope": ["read", "write"], "active": True}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS512")

tests\PyJWT\functional_test.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <jwt.api_jwt.PyJWT object at 0x0000023629CE9040>
payload = {'active': True, 'scope': ['read', 'write']}, key = 'secret'
algorithm = 'HS512', headers = None, json_encoder = None

    def encode(
        self,
        payload: Dict[str, Any],
        key: Union[str, bytes],
        algorithm: str = "HS256",
        headers: Optional[Dict[str, Any]] = None,
        json_encoder: Optional[json.JSONEncoder] = None,
    ) -> str:
        """
        Create a JSON Web Token.
    
        Only HS256 (HMAC + SHA-256) is supported. The returned value is
        a ``str`` instance containing the compact JWT.
        """
        algorithm = (algorithm or "").upper()
        if algorithm != "HS256":
>           raise NotImplementedError("Only HS256 algorithm is supported in this implementation")
E           NotImplementedError: Only HS256 algorithm is supported in this implementation

generation\PyJWT\jwt\api_jwt.py:105: NotImplementedError
_______________ test_encode_decode_with_datetime_exp_in_future ________________

    def test_encode_decode_with_datetime_exp_in_future() -> None:
        exp_dt = _fixed_dt_utc(2099, 1, 1, 0, 0, 0)
        payload = {"sub": "u-123", "exp": exp_dt}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS256")

tests\PyJWT\functional_test.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
generation\PyJWT\jwt\api_jwt.py:117: in encode
    _json_dumps(payload).encode("utf-8")
generation\PyJWT\jwt\api_jwt.py:59: in _json_dumps
    return json.dumps(data, separators=(",", ":"), ensure_ascii=False)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x0000023629D88A60>
o = datetime.datetime(2099, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
________________ test_encode_decode_with_datetime_nbf_in_past _________________

    def test_encode_decode_with_datetime_nbf_in_past() -> None:
        nbf_dt = _fixed_dt_utc(2000, 1, 1, 0, 0, 0)
        payload = {"feature": "enabled", "nbf": nbf_dt}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS256")

tests\PyJWT\functional_test.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
generation\PyJWT\jwt\api_jwt.py:117: in encode
    _json_dumps(payload).encode("utf-8")
generation\PyJWT\jwt\api_jwt.py:59: in _json_dumps
    return json.dumps(data, separators=(",", ":"), ensure_ascii=False)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x0000023629DC44C0>
o = datetime.datetime(2000, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
_____________ test_unverified_header_contains_alg_and_custom_kid ______________

    def test_unverified_header_contains_alg_and_custom_kid() -> None:
        payload = {"foo": "bar"}
        key = "secret"
        token = _normalize_token(jwt.encode(payload, key, algorithm="HS256", headers={"kid": "k1", "typ": "JWT"}))
    
>       header = jwt.get_unverified_header(token)
E       AttributeError: module 'jwt' has no attribute 'get_unverified_header'

tests\PyJWT\functional_test.py:210: AttributeError
=========================== short test summary info ===========================
FAILED tests/PyJWT/functional_test.py::test_hs512_encode_decode_roundtrip - N...
FAILED tests/PyJWT/functional_test.py::test_encode_decode_with_datetime_exp_in_future
FAILED tests/PyJWT/functional_test.py::test_encode_decode_with_datetime_nbf_in_past
FAILED tests/PyJWT/functional_test.py::test_unverified_header_contains_alg_and_custom_kid
4 failed, 6 passed, 1 skipped in 0.64s

==========================================================================================
PROJECT: PyPDF
LOG: D:\桌面\Exp1\o3\results\PyPDF\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFsF                                                             [100%]
================================== FAILURES ===================================
_______________________ test_create_and_read_blank_pdf ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_create_and_read_blank_pdf0')

    def test_create_and_read_blank_pdf(tmp_path: Path) -> None:
        pdf_path = tmp_path / "simple.pdf"
>       _create_simple_pdf(pdf_path, num_pages=3)

tests\PyPDF\functional_test.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD39A22E0>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_create_and_read_blank_pdf0\\simple.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
______________________ test_blank_page_has_expected_size ______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_blank_page_has_expected_s0')

    def test_blank_page_has_expected_size(tmp_path: Path) -> None:
        """The first blank page should have the width/height we set."""
        pdf_path = tmp_path / "size.pdf"
>       _create_simple_pdf(pdf_path, num_pages=1)

tests\PyPDF\functional_test.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD39A09D0>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_blank_page_has_expected_s0\\size.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
_____________________________ test_merge_two_pdfs _____________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_merge_two_pdfs0')

    def test_merge_two_pdfs(tmp_path: Path) -> None:
        pdf1 = tmp_path / "p1.pdf"
        pdf2 = tmp_path / "p2.pdf"
        merged = tmp_path / "merged.pdf"
    
>       _create_simple_pdf(pdf1, num_pages=1)

tests\PyPDF\functional_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD399C3D0>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_merge_two_pdfs0\\p1.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
__________________ test_writer_add_page_preserves_page_count __________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_writer_add_page_preserves0')

    def test_writer_add_page_preserves_page_count(tmp_path: Path) -> None:
        """Add pages from a reader into a writer and verify count is preserved."""
        src = tmp_path / "src.pdf"
        dst = tmp_path / "dst.pdf"
>       _create_simple_pdf(src, num_pages=4)

tests\PyPDF\functional_test.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD39A3730>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_writer_add_page_preserves0\\src.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
______________________________ test_rotate_page _______________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_rotate_page0')

    def test_rotate_page(tmp_path: Path) -> None:
        src = tmp_path / "src.pdf"
        rotated = tmp_path / "rotated.pdf"
>       _create_simple_pdf(src, num_pages=1)

tests\PyPDF\functional_test.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD399C0D0>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_rotate_page0\\src.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
_______________________ test_rotate_preserves_page_size _______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_rotate_preserves_page_siz0')

    def test_rotate_preserves_page_size(tmp_path: Path) -> None:
        """Rotating a blank page should keep a valid mediabox size."""
        src = tmp_path / "src_size.pdf"
        rotated = tmp_path / "rot_size.pdf"
>       _create_simple_pdf(src, num_pages=1)

tests\PyPDF\functional_test.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD3A1DEE0>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_rotate_preserves_page_siz0\\src_size.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
__________________________ test_encrypt_and_decrypt ___________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_encrypt_and_decrypt0')

    def test_encrypt_and_decrypt(tmp_path: Path) -> None:
        src = tmp_path / "plain.pdf"
        enc = tmp_path / "encrypted.pdf"
>       _create_simple_pdf(src, num_pages=2)

tests\PyPDF\functional_test.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD3A7FE80>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_encrypt_and_decrypt0\\plain.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
_____________ test_encrypted_pdf_allows_page_access_after_decrypt _____________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_encrypted_pdf_allows_page0')

    def test_encrypted_pdf_allows_page_access_after_decrypt(tmp_path: Path) -> None:
        """After decrypting, basic page access should succeed and page size is valid."""
        src = tmp_path / "plain2.pdf"
        enc = tmp_path / "encrypted2.pdf"
>       _create_simple_pdf(src, num_pages=1)

tests\PyPDF\functional_test.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD39A0340>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_encrypted_pdf_allows_page0\\plain2.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
___________________________ test_metadata_roundtrip ___________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_metadata_roundtrip0')

    def test_metadata_roundtrip(tmp_path: Path) -> None:
        src = tmp_path / "src.pdf"
        dst = tmp_path / "meta.pdf"
>       _create_simple_pdf(src, num_pages=1)

tests\PyPDF\functional_test.py:278: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD3A574F0>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_metadata_roundtrip0\\src.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
___________________ test_metadata_multiple_fields_roundtrip ___________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_metadata_multiple_fields_0')

    def test_metadata_multiple_fields_roundtrip(tmp_path: Path) -> None:
        """Add several info dict fields and ensure they can be read back."""
        src = tmp_path / "src_info.pdf"
        dst = tmp_path / "info.pdf"
>       _create_simple_pdf(src, num_pages=1)

tests\PyPDF\functional_test.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD3A3CCA0>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_metadata_multiple_fields_0\\src_info.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
_________________ test_clone_document_by_writing_reader_pages _________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-470/test_clone_document_by_writing0')

    def test_clone_document_by_writing_reader_pages(tmp_path: Path) -> None:
        """Clone a document by copying pages and verify page count matches."""
        src = tmp_path / "orig.pdf"
        dst = tmp_path / "clone.pdf"
>       _create_simple_pdf(src, num_pages=3)

tests\PyPDF\functional_test.py:361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:78: in _create_simple_pdf
    writer.write(fp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._writer.PdfWriter object at 0x000001ECD23989D0>
stream = <_io.BufferedWriter name='C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-470\\test_clone_document_by_writing0\\orig.pdf'>

    def write(self, stream: Union[str, IO[bytes], io.BufferedIOBase]):
        """
        Serialise the current document into *stream*.
    
        *stream* may be:
          \u2022 a str / Path \u2013 interpreted as a file path to open,
          \u2022 a binary file-like object.
        """
        data = dumps_doc(
            {
                "pages": [p.to_dict() for p in self._pages],
                "metadata": self._metadata,
                "encrypted": self._encrypt_password is not None,
                "password": self._encrypt_password or "",
            }
        )
    
>       if isinstance(stream, (str, bytes, io.PathLike)):
E       AttributeError: module 'io' has no attribute 'PathLike'

generation\PyPDF\pypdf\_writer.py:73: AttributeError
=========================== short test summary info ===========================
FAILED tests/PyPDF/functional_test.py::test_create_and_read_blank_pdf - Attri...
FAILED tests/PyPDF/functional_test.py::test_blank_page_has_expected_size - At...
FAILED tests/PyPDF/functional_test.py::test_merge_two_pdfs - AttributeError: ...
FAILED tests/PyPDF/functional_test.py::test_writer_add_page_preserves_page_count
FAILED tests/PyPDF/functional_test.py::test_rotate_page - AttributeError: mod...
FAILED tests/PyPDF/functional_test.py::test_rotate_preserves_page_size - Attr...
FAILED tests/PyPDF/functional_test.py::test_encrypt_and_decrypt - AttributeEr...
FAILED tests/PyPDF/functional_test.py::test_encrypted_pdf_allows_page_access_after_decrypt
FAILED tests/PyPDF/functional_test.py::test_metadata_roundtrip - AttributeErr...
FAILED tests/PyPDF/functional_test.py::test_metadata_multiple_fields_roundtrip
FAILED tests/PyPDF/functional_test.py::test_clone_document_by_writing_reader_pages
11 failed, 1 skipped in 23.09s

==========================================================================================
PROJECT: Requests
LOG: D:\桌面\Exp1\o3\results\Requests\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
_____________ ERROR collecting tests/Requests/functional_test.py ______________
tests\Requests\functional_test.py:40: in <module>
    import requests  # noqa: E402
generation\Requests\requests\__init__.py:15: in <module>
    from .api import delete, get, head, options, patch, post, put, request
generation\Requests\requests\api.py:33: in <module>
    def get(url: str, params: dict | None = None, **kwargs):
E   TypeError: unsupported operand type(s) for |: 'type' and 'NoneType'
=========================== short test summary info ===========================
ERROR tests/Requests/functional_test.py - TypeError: unsupported operand type...
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.74s

==========================================================================================
PROJECT: Rich
LOG: D:\桌面\Exp1\o3\results\Rich\pytest_logs\functional.log
==========================================================================================

1 skipped in 0.17s

==========================================================================================
PROJECT: Schedule
LOG: D:\桌面\Exp1\o3\results\Schedule\pytest_logs\functional.log
==========================================================================================
FFFF....FFF.                                                             [100%]
================================== FAILURES ===================================
________________________ test_basic_every_and_run_all _________________________

    def test_basic_every_and_run_all() -> None:
        """every(...).seconds/minutes + run_all execute jobs."""
        _clear()
        calls: List[str] = []
    
        def job1() -> None:
            calls.append("job1")
    
        def job2() -> None:
            calls.append("job2")
    
        schedule.every(5).seconds.do(job1).tag("sec", "common")
        schedule.every().minutes.do(job2).tag("min", "common")
    
>       jobs = schedule.get_jobs()

tests\Schedule\functional_test.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'get_jobs'

    def __getattr__(name: str) -> Any:  # noqa: D401
        if name == "datetime":
            return _datetime_module
        if name == "time":
            return _time_module
>       raise AttributeError(name)
E       AttributeError: get_jobs

generation\Schedule\schedule\__init__.py:463: AttributeError
_________________________ test_tags_and_clear_by_tag __________________________

    def test_tags_and_clear_by_tag() -> None:
        """Jobs can be tagged, selected by tag, and cleared by tag."""
        _clear()
        calls: List[str] = []
    
        def job_keep() -> None:
            calls.append("keep")
    
        def job_drop() -> None:
            calls.append("drop")
    
        schedule.every().hour.do(job_keep).tag("keep", "group")
        schedule.every().hour.do(job_drop).tag("drop", "group")
    
>       drop_jobs = schedule.get_jobs("drop")

tests\Schedule\functional_test.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'get_jobs'

    def __getattr__(name: str) -> Any:  # noqa: D401
        if name == "datetime":
            return _datetime_module
        if name == "time":
            return _time_module
>       raise AttributeError(name)
E       AttributeError: get_jobs

generation\Schedule\schedule\__init__.py:463: AttributeError
_____________________ test_cancel_job_removes_single_job ______________________

    def test_cancel_job_removes_single_job() -> None:
        """cancel_job removes a single job from the scheduler."""
        _clear()
        calls: List[str] = []
    
        def job1() -> None:
            calls.append("job1")
    
        def job2() -> None:
            calls.append("job2")
    
        j1 = schedule.every().day.do(job1)
        j2 = schedule.every().day.at("10:30").do(job2)
    
        schedule.cancel_job(j2)
    
        schedule.run_all()
        assert calls == ["job1"]
>       assert j1 in schedule.get_jobs()

tests\Schedule\functional_test.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'get_jobs'

    def __getattr__(name: str) -> Any:  # noqa: D401
        if name == "datetime":
            return _datetime_module
        if name == "time":
            return _time_module
>       raise AttributeError(name)
E       AttributeError: get_jobs

generation\Schedule\schedule\__init__.py:463: AttributeError
__________________ test_repeat_decorator_registers_and_runs ___________________

    def test_repeat_decorator_registers_and_runs() -> None:
        """@repeat(every(...)) schedules a function correctly and run_all triggers it."""
        _clear()
        call_count = 0
    
>       @schedule.repeat(schedule.every().seconds)

tests\Schedule\functional_test.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'repeat'

    def __getattr__(name: str) -> Any:  # noqa: D401
        if name == "datetime":
            return _datetime_module
        if name == "time":
            return _time_module
>       raise AttributeError(name)
E       AttributeError: repeat

generation\Schedule\schedule\__init__.py:463: AttributeError
________________ test_every_to_creates_job_with_interval_range ________________

    def test_every_to_creates_job_with_interval_range() -> None:
        """every(A).to(B).seconds should create a job and be runnable via run_all."""
        _clear()
        calls: List[str] = []
    
        def job() -> None:
            calls.append("x")
    
>       j = schedule.every(2).to(5).seconds.do(job)
E       AttributeError: 'Job' object has no attribute 'to'

tests\Schedule\functional_test.py:239: AttributeError
______________________ test_idle_seconds_returns_number _______________________

    def test_idle_seconds_returns_number() -> None:
        """idle_seconds should return a numeric value when jobs exist."""
        _clear()
    
        def job() -> None:
            return None
    
        schedule.every().hour.do(job)
>       idle = schedule.idle_seconds()

tests\Schedule\functional_test.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'idle_seconds'

    def __getattr__(name: str) -> Any:  # noqa: D401
        if name == "datetime":
            return _datetime_module
        if name == "time":
            return _time_module
>       raise AttributeError(name)
E       AttributeError: idle_seconds

generation\Schedule\schedule\__init__.py:463: AttributeError
_____________________ test_get_jobs_by_tag_filters_subset _____________________

    def test_get_jobs_by_tag_filters_subset() -> None:
        """get_jobs(tag) should return only jobs with that tag."""
        _clear()
    
        def a() -> None:
            return None
    
        def b() -> None:
            return None
    
        schedule.every().minute.do(a).tag("alpha")
        schedule.every().minute.do(b).tag("beta")
    
>       alpha_jobs = schedule.get_jobs("alpha")

tests\Schedule\functional_test.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'get_jobs'

    def __getattr__(name: str) -> Any:  # noqa: D401
        if name == "datetime":
            return _datetime_module
        if name == "time":
            return _time_module
>       raise AttributeError(name)
E       AttributeError: get_jobs

generation\Schedule\schedule\__init__.py:463: AttributeError
=========================== short test summary info ===========================
FAILED tests/Schedule/functional_test.py::test_basic_every_and_run_all - Attr...
FAILED tests/Schedule/functional_test.py::test_tags_and_clear_by_tag - Attrib...
FAILED tests/Schedule/functional_test.py::test_cancel_job_removes_single_job
FAILED tests/Schedule/functional_test.py::test_repeat_decorator_registers_and_runs
FAILED tests/Schedule/functional_test.py::test_every_to_creates_job_with_interval_range
FAILED tests/Schedule/functional_test.py::test_idle_seconds_returns_number - ...
FAILED tests/Schedule/functional_test.py::test_get_jobs_by_tag_filters_subset
7 failed, 5 passed in 0.56s

==========================================================================================
PROJECT: Slugify
LOG: D:\桌面\Exp1\o3\results\Slugify\pytest_logs\functional.log
==========================================================================================
.......F....                                                             [100%]
================================== FAILURES ===================================
________________ test_regex_pattern_allows_underscore_prefixes ________________

    def test_regex_pattern_allows_underscore_prefixes() -> None:
        """Custom regex_pattern can allow underscores to remain."""
        text = "___This is a test___"
        regex_pattern = r"[^-a-z0-9_]+"
    
        result_default_sep = slugify(text, regex_pattern=regex_pattern)
        assert result_default_sep.startswith("___")
>       assert "this-is-a-test" in result_default_sep
E       AssertionError: assert 'this-is-a-test' in '___thisisatest___'

tests\Slugify\functional_test.py:174: AssertionError
=========================== short test summary info ===========================
FAILED tests/Slugify/functional_test.py::test_regex_pattern_allows_underscore_prefixes
1 failed, 11 passed in 0.41s

==========================================================================================
PROJECT: Sqlmap
LOG: D:\桌面\Exp1\o3\results\Sqlmap\pytest_logs\functional.log
==========================================================================================
....F.F.F                                                                [100%]
================================== FAILURES ===================================
_____________ test_005_version_runs_and_prints_version_like_token _____________

    def test_005_version_runs_and_prints_version_like_token():
        """
        sqlmap --version may print a raw version token (e.g. 1.9.12.3#dev) and may also
        print an 'exit' message. Do not require specific words like 'sqlmap'/'version'.
        """
        # --batch helps avoid interactive prompts on some builds, but keep tolerance regardless.
        p = _run_cli(["--batch", "--version"], timeout_s=30)
        out = _out(p)
    
        # Require a version-like token such as "1.9.12.3" optionally with suffix "#dev"
>       assert re.search(r"\b\d+\.\d+(?:\.\d+){0,3}(?:#[a-z0-9]+)?\b", out) is not None
E       AssertionError: assert None is not None
E        +  where None = <function search at 0x00000211BCF999D0>('\\b\\d+\\.\\d+(?:\\.\\d+){0,3}(?:#[a-z0-9]+)?\\b', '\nusage: sqlmap.py [-h] [-hh] [--version]\nsqlmap.py: error: unrecognized arguments: --batch\n')
E        +    where <function search at 0x00000211BCF999D0> = re.search

tests\Sqlmap\functional_test.py:80: AssertionError
______________ test_007_alignment_api_surface_symbols_importable ______________

    def test_007_alignment_api_surface_symbols_importable():
        """
        Alignment anchors (must exist in BOTH reference and generated repos):
    
          - lib.parse.cmdline.cmdLineParser
          - lib.core.option.init, lib.core.option.initOptions
          - lib.core.data: cmdLineOptions, conf, kb
          - lib.core.settings: VERSION, DESCRIPTION
          - lib.controller.controller.start
    
        Only checks importability + symbol presence; does not execute scanning logic.
        """
        repo = _repo_root()
        sys.path.insert(0, str(repo))
        try:
            from lib.parse.cmdline import cmdLineParser  # noqa: F401
            from lib.core.option import init, initOptions  # noqa: F401
            from lib.core.data import cmdLineOptions, conf, kb  # noqa: F401
            from lib.core.settings import VERSION, DESCRIPTION  # noqa: F401
            from lib.controller.controller import start  # noqa: F401
    
            assert callable(cmdLineParser)
            assert callable(init)
            assert callable(initOptions)
>           assert cmdLineOptions is not None
E           assert None is not None

tests\Sqlmap\functional_test.py:119: AssertionError
__________ test_009_unicode_output_dir_argument_stable_in_help_mode ___________

    def test_009_unicode_output_dir_argument_stable_in_help_mode():
        root = _project_root()
        out_dir = root / "generation" / "Sqlmap" / "tmp_输出"
        out_dir.mkdir(parents=True, exist_ok=True)
    
        p = _run_cli(["-h", "--output-dir", str(out_dir)], timeout_s=30)
>       assert p.returncode == 0
E       AssertionError: assert 2 == 0
E        +  where 2 = CompletedProcess(args=['C:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\python.exe', 'D:\\桌面\\RealAppCod... stdout='', stderr='usage: sqlmap.py [-h] [-hh] [--version]\nsqlmap.py: error: unrecognized arguments: --output-dir\n').returncode

tests\Sqlmap\functional_test.py:142: AssertionError
=========================== short test summary info ===========================
FAILED tests/Sqlmap/functional_test.py::test_005_version_runs_and_prints_version_like_token
FAILED tests/Sqlmap/functional_test.py::test_007_alignment_api_surface_symbols_importable
FAILED tests/Sqlmap/functional_test.py::test_009_unicode_output_dir_argument_stable_in_help_mode
3 failed, 6 passed in 1.91s

==========================================================================================
PROJECT: SQLModel
LOG: D:\桌面\Exp1\o3\results\SQLModel\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
_____________ ERROR collecting tests/SQLModel/functional_test.py ______________
tests\SQLModel\functional_test.py:34: in <module>
    SQLModel.metadata.clear()
E   AttributeError: '_Column' object has no attribute 'clear'
=========================== short test summary info ===========================
ERROR tests/SQLModel/functional_test.py - AttributeError: '_Column' object ha...
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.53s

==========================================================================================
PROJECT: Stegano
LOG: D:\桌面\Exp1\o3\results\Stegano\pytest_logs\functional.log
==========================================================================================
FFFFFF.....F                                                             [100%]
================================== FAILURES ===================================
________________________ test_lsb_hide_and_reveal_text ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-473/test_lsb_hide_and_reveal_text0')

    def test_lsb_hide_and_reveal_text(tmp_path: Path) -> None:
        """lsb.hide(..., str) then lsb.reveal(...) returns the same string."""
        _ensure_image_samples_exist()
    
        secret = "hello world"
        output = tmp_path / "lsb_lenna.png"
    
>       encoded_img = lsb.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Stegano\stegano\lsb\lsb.py:94: in hide
    img = _prepare_image(image, auto_convert_rgb=auto_convert_rgb)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'

    def _prepare_image(
        image: Image.Image, *, auto_convert_rgb: bool = False
    ) -> Image.Image:
        """
        Makes sure the supplied image is in RGB mode (3×8-bit) because the current
        implementation depends on that layout.
        """
>       if image.mode != "RGB":
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:27: AttributeError
___________________ test_lsb_hide_and_reveal_with_generator ___________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-473/test_lsb_hide_and_reveal_with_0')

    def test_lsb_hide_and_reveal_with_generator(tmp_path: Path) -> None:
        """lsb hide/reveal with a deterministic generator."""
        _ensure_image_samples_exist()
    
        secret = "generator secret"
        output = tmp_path / "lsb_generator.png"
    
        gen = generators.eratosthenes()
>       encoded_img = lsb.hide(str(LENNA_PNG), secret, generator=gen)

tests\Stegano\functional_test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Stegano\stegano\lsb\lsb.py:94: in hide
    img = _prepare_image(image, auto_convert_rgb=auto_convert_rgb)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'

    def _prepare_image(
        image: Image.Image, *, auto_convert_rgb: bool = False
    ) -> Image.Image:
        """
        Makes sure the supplied image is in RGB mode (3×8-bit) because the current
        implementation depends on that layout.
        """
>       if image.mode != "RGB":
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:27: AttributeError
__________________ test_lsb_hide_and_reveal_long_ascii_text ___________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-473/test_lsb_hide_and_reveal_long_0')

    def test_lsb_hide_and_reveal_long_ascii_text(tmp_path: Path) -> None:
        """LSB should roundtrip a longer ASCII text message (still < typical capacity)."""
        _ensure_image_samples_exist()
    
        secret = "This is a longer secret message with punctuation: 12345, hello-world!"
        output = tmp_path / "lsb_long.png"
    
>       encoded_img = lsb.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Stegano\stegano\lsb\lsb.py:94: in hide
    img = _prepare_image(image, auto_convert_rgb=auto_convert_rgb)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'

    def _prepare_image(
        image: Image.Image, *, auto_convert_rgb: bool = False
    ) -> Image.Image:
        """
        Makes sure the supplied image is in RGB mode (3×8-bit) because the current
        implementation depends on that layout.
        """
>       if image.mode != "RGB":
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:27: AttributeError
______________________ test_lsb_reveal_from_image_object ______________________

    def test_lsb_reveal_from_image_object() -> None:
        """lsb.reveal should work when passed a PIL.Image object (common API usage)."""
        _ensure_image_samples_exist()
    
        secret = "object input"
>       img_obj = lsb.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Stegano\stegano\lsb\lsb.py:94: in hide
    img = _prepare_image(image, auto_convert_rgb=auto_convert_rgb)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'

    def _prepare_image(
        image: Image.Image, *, auto_convert_rgb: bool = False
    ) -> Image.Image:
        """
        Makes sure the supplied image is in RGB mode (3×8-bit) because the current
        implementation depends on that layout.
        """
>       if image.mode != "RGB":
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:27: AttributeError
________________________ test_red_hide_and_reveal_text ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-473/test_red_hide_and_reveal_text0')

    def test_red_hide_and_reveal_text(tmp_path: Path) -> None:
        """red.hide(..., str) then red.reveal(...) returns the same string."""
        _ensure_image_samples_exist()
    
        secret = "red secret"
        output = tmp_path / "red_lenna.png"
    
>       encoded_img = red.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Stegano\stegano\red\red.py:28: in hide
    img = _prepare_image(image)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

img = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'

    def _prepare_image(img: Image.Image) -> Image.Image:
>       if img.mode != "RGB":
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\red\red.py:19: AttributeError
________________ test_red_hide_and_reveal_extended_latin_text _________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-473/test_red_hide_and_reveal_exten0')

    def test_red_hide_and_reveal_extended_latin_text(tmp_path: Path) -> None:
        """Red backend stores per-char ord() into a byte channel; Latin-1 chars like 'é' are valid."""
        _ensure_image_samples_exist()
    
        secret = "Café au lait"
        output = tmp_path / "red_latin.png"
    
>       encoded_img = red.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Stegano\stegano\red\red.py:28: in hide
    img = _prepare_image(image)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

img = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'

    def _prepare_image(img: Image.Image) -> Image.Image:
>       if img.mode != "RGB":
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\red\red.py:19: AttributeError
_____________________ test_lsb_and_red_outputs_are_files ______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-473/test_lsb_and_red_outputs_are_f0')

    def test_lsb_and_red_outputs_are_files(tmp_path: Path) -> None:
        """Ensure image-encoding backends produce files that can be written to disk."""
        _ensure_image_samples_exist()
    
        out_lsb = tmp_path / "lsb_file.png"
        out_red = tmp_path / "red_file.png"
    
>       lsb.hide(str(LENNA_PNG), "x").save(str(out_lsb))

tests\Stegano\functional_test.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Stegano\stegano\lsb\lsb.py:94: in hide
    img = _prepare_image(image, auto_convert_rgb=auto_convert_rgb)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'

    def _prepare_image(
        image: Image.Image, *, auto_convert_rgb: bool = False
    ) -> Image.Image:
        """
        Makes sure the supplied image is in RGB mode (3×8-bit) because the current
        implementation depends on that layout.
        """
>       if image.mode != "RGB":
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:27: AttributeError
=========================== short test summary info ===========================
FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_text - Attr...
FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_with_generator
FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_long_ascii_text
FAILED tests/Stegano/functional_test.py::test_lsb_reveal_from_image_object - ...
FAILED tests/Stegano/functional_test.py::test_red_hide_and_reveal_text - Attr...
FAILED tests/Stegano/functional_test.py::test_red_hide_and_reveal_extended_latin_text
FAILED tests/Stegano/functional_test.py::test_lsb_and_red_outputs_are_files
7 failed, 5 passed in 2.50s

==========================================================================================
PROJECT: Tablib
LOG: D:\桌面\Exp1\o3\results\Tablib\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
______________ ERROR collecting tests/Tablib/functional_test.py _______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\Tablib\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\Tablib\functional_test.py:59: in <module>
    import tablib  # type: ignore  # noqa: E402
generation\Tablib\tablib\__init__.py:10: in <module>
    from .core import Dataset, Databook        # noqa: F401
generation\Tablib\tablib\core.py:13: in <module>
    from .formats import _csv as csv_format
generation\Tablib\tablib\formats\_csv.py:9: in <module>
    from ..core import Dataset
E   ImportError: cannot import name 'Dataset' from partially initialized module 'tablib.core' (most likely due to a circular import) (D:\桌面\RealAppCodeBench_generic_eval\generation\Tablib\tablib\core.py)
=========================== short test summary info ===========================
ERROR tests/Tablib/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.59s

==========================================================================================
PROJECT: Tabulate
LOG: D:\桌面\Exp1\o3\results\Tabulate\pytest_logs\functional.log
==========================================================================================
..FF.F...FF.                                                             [100%]
================================== FAILURES ===================================
___________________ test_headers_firstrow_and_simple_format ___________________

    def test_headers_firstrow_and_simple_format() -> None:
        table = [
            ["Name", "Age"],
            ["Alice", 24],
            ["Bob", 19],
        ]
    
        output = tabulate(table, headers="firstrow", tablefmt="simple")
        lines = _lines(output)
    
        assert lines[0].strip().startswith("Name")
        assert "Age" in lines[0]
        # separator line usually contains dashes
>       assert "-" in lines[1].replace(" ", "")
E       AssertionError: assert '-' in 'Alice24'
E        +  where 'Alice24' = <built-in method replace of str object at 0x0000024BE0E16BF0>(' ', '')
E        +    where <built-in method replace of str object at 0x0000024BE0E16BF0> = 'Alice  24'.replace

tests\Tabulate\functional_test.py:123: AssertionError
___________________ test_headers_keys_on_dict_of_iterables ____________________

    def test_headers_keys_on_dict_of_iterables() -> None:
        table = {
            "Name": ["Alice", "Bob"],
            "Age": [24, 19],
        }
    
        output = tabulate(table, headers="keys")
        lines = _lines(output)
    
>       assert "Name" in lines[0]
E       AssertionError: assert 'Name' in 'key  value           '

tests\Tabulate\functional_test.py:137: AssertionError
________________________ test_github_and_grid_formats _________________________

    def test_github_and_grid_formats() -> None:
        table = [
            ["item", "qty"],
            ["spam", 42],
            ["eggs", 451],
            ["bacon", 0],
        ]
    
>       out_github = tabulate(table[1:], headers=table[0], tablefmt="github")

tests\Tabulate\functional_test.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tabular_data = [['spam', 42], ['eggs', 451], ['bacon', 0]]
headers = ['item', 'qty'], tablefmt = 'github', showindex = False
stralign = 'left', numalign = 'decimal', floatfmt = 'g', missingval = ''

    def tabulate(
        tabular_data: Any,
        headers: Any = (),
        tablefmt: str = "simple",
        showindex: bool | Sequence[Any] = False,
        stralign: str | None = "left",
        numalign: str | None = "decimal",
        floatfmt: str = "g",
        missingval: str = "",
    ) -> str:
        """
        Format *tabular_data* into a table.
    
        Only a subset of arguments of the original *tabulate* function
        is implemented, but the most frequently used ones are present.
        """
    
        fmt = TABLE_FORMATS.get(tablefmt)
        if fmt is None:
>           raise ValueError(f"Unknown table format {tablefmt!r}")
E           ValueError: Unknown table format 'github'

generation\Tabulate\tabulate\core.py:173: ValueError
_______________ test_disable_numparse_preserves_numeric_strings _______________

    def test_disable_numparse_preserves_numeric_strings() -> None:
        rows = [
            ["code", "value"],
            ["A", "001"],
            ["B", "010"],
        ]
>       output = tabulate(rows[1:], headers=rows[0], tablefmt="plain", disable_numparse=True)
E       TypeError: tabulate() got an unexpected keyword argument 'disable_numparse'

tests\Tabulate\functional_test.py:236: TypeError
______________________ test_maxcolwidths_wraps_long_text ______________________

    def test_maxcolwidths_wraps_long_text() -> None:
        long_text = "alpha beta gamma delta epsilon zeta"
        rows = [
            ["id", "note"],
            [1, long_text],
            [2, "short"],
        ]
>       output = tabulate(
            rows[1:],
            headers=rows[0],
            tablefmt="simple",
            maxcolwidths=[None, 10],
        )
E       TypeError: tabulate() got an unexpected keyword argument 'maxcolwidths'

tests\Tabulate\functional_test.py:251: TypeError
=========================== short test summary info ===========================
FAILED tests/Tabulate/functional_test.py::test_headers_firstrow_and_simple_format
FAILED tests/Tabulate/functional_test.py::test_headers_keys_on_dict_of_iterables
FAILED tests/Tabulate/functional_test.py::test_github_and_grid_formats - Valu...
FAILED tests/Tabulate/functional_test.py::test_disable_numparse_preserves_numeric_strings
FAILED tests/Tabulate/functional_test.py::test_maxcolwidths_wraps_long_text
5 failed, 7 passed in 0.50s

==========================================================================================
PROJECT: Termgraph
LOG: D:\桌面\Exp1\o3\results\Termgraph\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFF                                                              [100%]
================================== FAILURES ===================================
______________________ test_simple_horizontal_bar_chart _______________________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD27BFD0>

    def test_simple_horizontal_bar_chart(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["A", "B", "C"]
        values = [[3], [5], [2]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd282490>
labels = [[3], [5], [2]], series = ['A', 'B', 'C']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
_____________________ test_stacked_chart_multiple_series ______________________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD2F48E0>

    def test_stacked_chart_multiple_series(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["X", "Y"]
        values = [[1, 2], [3, 4]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd2f4c40>
labels = [[1, 2], [3, 4]], series = ['X', 'Y']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
_______________________ test_bar_chart_object_interface _______________________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD282BB0>

    def test_bar_chart_object_interface(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["D", "E"]
        values = [[4], [1]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd27ce80>
labels = [[4], [1]], series = ['D', 'E']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
___________________ test_bar_chart_respects_no_values_flag ____________________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD26D070>

    def test_bar_chart_respects_no_values_flag(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["A", "B"]
        values = [[2], [7]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd26d370>
labels = [[2], [7]], series = ['A', 'B']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
___________________ test_bar_chart_respects_no_labels_flag ____________________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD2F56A0>

    def test_bar_chart_respects_no_labels_flag(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["L1", "L2", "L3"]
        values = [[1], [2], [3]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd2f5160>
labels = [[1], [2], [3]], series = ['L1', 'L2', 'L3']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
__________________ test_bar_chart_suffix_appended_to_values ___________________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD26DA30>

    def test_bar_chart_suffix_appended_to_values(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["CPU", "RAM"]
        values = [[12.5], [7.0]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd26d280>
labels = [[12.5], [7.0]], series = ['CPU', 'RAM']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
___________ test_bar_chart_custom_format_changes_numeric_rendering ____________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD25D1F0>

    def test_bar_chart_custom_format_changes_numeric_rendering(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["P", "Q"]
        values = [[3.14159], [2.71828]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd3423a0>
labels = [[3.14159], [2.71828]], series = ['P', 'Q']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
____________________ test_stacked_chart_renders_all_labels ____________________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD343BB0>

    def test_stacked_chart_renders_all_labels(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["S1", "S2", "S3"]
        values = [[1, 1], [2, 1], [1, 3]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd343c40>
labels = [[1, 1], [2, 1], [1, 3]], series = ['S1', 'S2', 'S3']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
____________ test_stacked_chart_no_values_still_renders_structure _____________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD342B20>

    def test_stacked_chart_no_values_still_renders_structure(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["A", "B"]
        values = [[1, 2, 3], [3, 2, 1]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd3429d0>
labels = [[1, 2, 3], [3, 2, 1]], series = ['A', 'B']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
__________________ test_title_none_does_not_break_rendering ___________________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD34D400>

    def test_title_none_does_not_break_rendering(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["U", "V"]
        values = [[4], [6]]
    
>       data = Data(values, labels)

tests\Termgraph\functional_test.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError("'Data' object has no attribute 'labels'") raised in repr()] Data object at 0x2bcfd34d2e0>
labels = [[4], [6]], series = ['U', 'V']

    def __init__(self, labels, series):
        if not isinstance(labels, (list, tuple)):
            raise TypeError("labels must be a sequence")
    
        if not isinstance(series, (list, tuple)):
            raise TypeError("series must be a sequence of sequences")
    
        # Basic sanity ---------------------------------------------------------
        row_count = len(labels)
        for s in series:
            if len(s) != row_count:
>               raise ValueError("every series must have the same length as labels")
E               ValueError: every series must have the same length as labels

generation\Termgraph\termgraph\data.py:33: ValueError
________________ test_width_parameter_affects_output_presence _________________

capsys = <_pytest.capture.CaptureFixture object at 0x000002BCFD335040>

    def test_width_parameter_affects_output_presence(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["W"]
        values = [[9]]
    
        data = Data(values, labels)
    
        args_narrow = _make_args(title="Narrow", width=5, format="{:>4.1f}")
>       BarChart(data, args_narrow).draw()

tests\Termgraph\functional_test.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.BarChart object at 0x000002BCFD335070>
data = Data(labels=[[9]], series=[['W']])
args = Args(width=5, stacked=False, different_scale=False, no_labels=False, format='{:>4.1f}', suffix='', vertical=False, histogram=False, no_values=False, color=None, labels=None, title='Narrow')
stream = None

    def __init__(self, data: Data, args: Args, stream=None):
        self.data = data
        self.args = args
        self.stream = stream if stream is not None else sys.stdout
    
        # Prepare values -------------------------------------------------------
        # Flatten to compute a global maximum when `different_scale` is False.
        if not args.different_scale:
            flat_values = list(itertools.chain.from_iterable(self.data.series))
            # Avoid division by zero.  Use 1 to make every bar zero width.
>           self._global_max = max(max(flat_values), 1)
E           TypeError: '>' not supported between instances of 'int' and 'str'

generation\Termgraph\termgraph\charts.py:37: TypeError
=========================== short test summary info ===========================
FAILED tests/Termgraph/functional_test.py::test_simple_horizontal_bar_chart
FAILED tests/Termgraph/functional_test.py::test_stacked_chart_multiple_series
FAILED tests/Termgraph/functional_test.py::test_bar_chart_object_interface - ...
FAILED tests/Termgraph/functional_test.py::test_bar_chart_respects_no_values_flag
FAILED tests/Termgraph/functional_test.py::test_bar_chart_respects_no_labels_flag
FAILED tests/Termgraph/functional_test.py::test_bar_chart_suffix_appended_to_values
FAILED tests/Termgraph/functional_test.py::test_bar_chart_custom_format_changes_numeric_rendering
FAILED tests/Termgraph/functional_test.py::test_stacked_chart_renders_all_labels
FAILED tests/Termgraph/functional_test.py::test_stacked_chart_no_values_still_renders_structure
FAILED tests/Termgraph/functional_test.py::test_title_none_does_not_break_rendering
FAILED tests/Termgraph/functional_test.py::test_width_parameter_affects_output_presence
11 failed in 0.68s

==========================================================================================
PROJECT: TheFuck
LOG: D:\桌面\Exp1\o3\results\TheFuck\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFF..                                                             [100%]
================================== FAILURES ===================================
_______________________ test_001_import_thefuck_package _______________________

    def test_001_import_thefuck_package() -> None:
>       import thefuck  # noqa: F401

tests\TheFuck\functional_test.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
___________________ test_002_import_no_command_rule_module ____________________

    def test_002_import_no_command_rule_module() -> None:
>       importlib.import_module("thefuck.rules.no_command")

tests\TheFuck\functional_test.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
_____________ test_003_no_command_match_returns_bool_windows_like _____________

    def test_003_no_command_match_returns_bool_windows_like() -> None:
>       match_fn, _ = _import_no_command_rule()

tests\TheFuck\functional_test.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
______________ test_004_no_command_match_returns_bool_bash_like _______________

    def test_004_no_command_match_returns_bool_bash_like() -> None:
>       match_fn, _ = _import_no_command_rule()

tests\TheFuck\functional_test.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
______ test_005_no_command_like_rule_matches_at_least_one_typical_output ______

    def test_005_no_command_like_rule_matches_at_least_one_typical_output() -> None:
        """
        Ensure the reference no_command rule actually matches a typical 'command not found' output.
        We check both Windows and bash variants, and require at least one to match.
        """
>       match_fn, _ = _import_no_command_rule()

tests\TheFuck\functional_test.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
___________ test_006_no_command_get_new_command_returns_string_like ___________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-474/test_006_no_command_get_new_co0')

    def test_006_no_command_get_new_command_returns_string_like(tmp_path: Path) -> None:
        """
        get_new_command should return something string-like (or iterable of strings).
        Do not require a specific suggestion yet.
        """
>       _, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
________ test_007_no_command_suggests_python_when_only_python_in_path _________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-474/test_007_no_command_suggests_p0')

    def test_007_no_command_suggests_python_when_only_python_in_path(tmp_path: Path) -> None:
        """
        With PATH constrained to a directory containing only python.cmd,
        the best correction for 'pythno' should include 'python' in the suggestion.
        """
>       _, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
_______________ test_008_no_command_suggestion_is_deterministic _______________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-474/test_008_no_command_suggestion0')

    def test_008_no_command_suggestion_is_deterministic(tmp_path: Path) -> None:
        """
        Same input should yield same first suggestion in a controlled PATH.
        """
>       _, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
_____________ test_009_no_command_does_not_crash_on_empty_output ______________

    def test_009_no_command_does_not_crash_on_empty_output() -> None:
>       match_fn, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
_________________ test_010_no_command_handles_unicode_output __________________

    def test_010_no_command_handles_unicode_output() -> None:
>       match_fn, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:972: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
generation\TheFuck\thefuck\__init__.py:21: in <module>
    from .command import Command           # Re-export for the tests
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Very small re-implementation of the *Command* helper from *The Fuck*.
    
    It is nothing more than a glorified named-tuple but with a few convenience
    methods that the rules can rely on.
    """
    from __future__ import annotations
    from dataclasses import dataclass
    
    
>   @dataclass(slots=True)
E   TypeError: dataclass() got an unexpected keyword argument 'slots'

generation\TheFuck\thefuck\command.py:11: TypeError
=========================== short test summary info ===========================
FAILED tests/TheFuck/functional_test.py::test_001_import_thefuck_package - Ty...
FAILED tests/TheFuck/functional_test.py::test_002_import_no_command_rule_module
FAILED tests/TheFuck/functional_test.py::test_003_no_command_match_returns_bool_windows_like
FAILED tests/TheFuck/functional_test.py::test_004_no_command_match_returns_bool_bash_like
FAILED tests/TheFuck/functional_test.py::test_005_no_command_like_rule_matches_at_least_one_typical_output
FAILED tests/TheFuck/functional_test.py::test_006_no_command_get_new_command_returns_string_like
FAILED tests/TheFuck/functional_test.py::test_007_no_command_suggests_python_when_only_python_in_path
FAILED tests/TheFuck/functional_test.py::test_008_no_command_suggestion_is_deterministic
FAILED tests/TheFuck/functional_test.py::test_009_no_command_does_not_crash_on_empty_output
FAILED tests/TheFuck/functional_test.py::test_010_no_command_handles_unicode_output
10 failed, 2 passed in 25.40s

==========================================================================================
PROJECT: TinyDB
LOG: D:\桌面\Exp1\o3\results\TinyDB\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
______________ ERROR collecting tests/TinyDB/functional_test.py _______________
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\python.py:498: in importtestmodule
    mod = import_path(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\pathlib.py:587: in import_path
    importlib.import_module(module_name)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\assertion\rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests\TinyDB\functional_test.py:49: in <module>
    from tinydb import TinyDB, Query, where  # type: ignore  # noqa: E402
generation\TinyDB\tinydb\__init__.py:16: in <module>
    from .database import TinyDB
generation\TinyDB\tinydb\database.py:11: in <module>
    from .table import Table
generation\TinyDB\tinydb\table.py:19: in <module>
    from .queries import Condition
E     File "D:\桌面\RealAppCodeBench_generic_eval\generation\TinyDB\tinydb\queries.py", line 127
E       def _drill(self, document: dict, default=_Ellipsis := object()):
E                                                          ^
E   SyntaxError: invalid syntax
=========================== short test summary info ===========================
ERROR tests/TinyDB/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.71s

==========================================================================================
PROJECT: Typer
LOG: D:\桌面\Exp1\o3\results\Typer\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFFF                                                             [100%]
================================== FAILURES ===================================
__________________________ test_simple_hello_command __________________________

    def test_simple_hello_command() -> None:
>       app = _create_greeter_app()

tests\Typer\functional_test.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_greeter_app() -> typer.Typer:
        """
        Single-command style app (callback-only):
          app NAME [--excited]
        """
        app = typer.Typer()
    
>       @app.callback(invoke_without_command=True)
E       TypeError: 'NoneType' object is not callable

tests\Typer\functional_test.py:70: TypeError
______________________ test_simple_hello_command_excited ______________________

    def test_simple_hello_command_excited() -> None:
>       app = _create_greeter_app()

tests\Typer\functional_test.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_greeter_app() -> typer.Typer:
        """
        Single-command style app (callback-only):
          app NAME [--excited]
        """
        app = typer.Typer()
    
>       @app.callback(invoke_without_command=True)
E       TypeError: 'NoneType' object is not callable

tests\Typer\functional_test.py:70: TypeError
_______________ test_greeter_help_mentions_option_and_argument ________________

    def test_greeter_help_mentions_option_and_argument() -> None:
>       app = _create_greeter_app()

tests\Typer\functional_test.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_greeter_app() -> typer.Typer:
        """
        Single-command style app (callback-only):
          app NAME [--excited]
        """
        app = typer.Typer()
    
>       @app.callback(invoke_without_command=True)
E       TypeError: 'NoneType' object is not callable

tests\Typer\functional_test.py:70: TypeError
_____________________ test_todo_list_empty_shows_no_tasks _____________________

    def test_todo_list_empty_shows_no_tasks() -> None:
>       app = _create_todo_app()

tests\Typer\functional_test.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Typer\functional_test.py:92: in _create_todo_app
    def add(title: str) -> None:
generation\Typer\typer\__init__.py:196: in decorator
    params = _build_click_params(fn)
generation\Typer\typer\__init__.py:160: in _build_click_params
    argument = click.Argument(decls, **kwargs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2994: in __init__
    super().__init__(param_decls, required=required, **attrs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2114: in __init__
    self.type: types.ParamType = types.convert_type(type, default)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:1056: in convert_type
    return FuncParamType(ty)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <click.types.FuncParamType object at 0x0000021BCA56A520>, func = 'str'

    def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
>       self.name: str = func.__name__
E       AttributeError: 'str' object has no attribute '__name__'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:166: AttributeError
___________________________ test_todo_add_and_list ____________________________

    def test_todo_add_and_list() -> None:
>       app = _create_todo_app()

tests\Typer\functional_test.py:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Typer\functional_test.py:92: in _create_todo_app
    def add(title: str) -> None:
generation\Typer\typer\__init__.py:196: in decorator
    params = _build_click_params(fn)
generation\Typer\typer\__init__.py:160: in _build_click_params
    argument = click.Argument(decls, **kwargs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2994: in __init__
    super().__init__(param_decls, required=required, **attrs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2114: in __init__
    self.type: types.ParamType = types.convert_type(type, default)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:1056: in convert_type
    return FuncParamType(ty)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <click.types.FuncParamType object at 0x0000021BCAFC1AF0>, func = 'str'

    def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
>       self.name: str = func.__name__
E       AttributeError: 'str' object has no attribute '__name__'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:166: AttributeError
_____________________ test_todo_remove_then_list_updates ______________________

    def test_todo_remove_then_list_updates() -> None:
>       app = _create_todo_app()

tests\Typer\functional_test.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Typer\functional_test.py:92: in _create_todo_app
    def add(title: str) -> None:
generation\Typer\typer\__init__.py:196: in decorator
    params = _build_click_params(fn)
generation\Typer\typer\__init__.py:160: in _build_click_params
    argument = click.Argument(decls, **kwargs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2994: in __init__
    super().__init__(param_decls, required=required, **attrs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2114: in __init__
    self.type: types.ParamType = types.convert_type(type, default)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:1056: in convert_type
    return FuncParamType(ty)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <click.types.FuncParamType object at 0x0000021BCA4AF1C0>, func = 'str'

    def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
>       self.name: str = func.__name__
E       AttributeError: 'str' object has no attribute '__name__'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:166: AttributeError
_____________________ test_help_output_includes_commands ______________________

    def test_help_output_includes_commands() -> None:
>       app = _create_todo_app()

tests\Typer\functional_test.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Typer\functional_test.py:92: in _create_todo_app
    def add(title: str) -> None:
generation\Typer\typer\__init__.py:196: in decorator
    params = _build_click_params(fn)
generation\Typer\typer\__init__.py:160: in _build_click_params
    argument = click.Argument(decls, **kwargs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2994: in __init__
    super().__init__(param_decls, required=required, **attrs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2114: in __init__
    self.type: types.ParamType = types.convert_type(type, default)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:1056: in convert_type
    return FuncParamType(ty)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <click.types.FuncParamType object at 0x0000021BCA5D3A00>, func = 'str'

    def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
>       self.name: str = func.__name__
E       AttributeError: 'str' object has no attribute '__name__'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:166: AttributeError
_______________ test_subcommand_help_for_add_mentions_argument ________________

    def test_subcommand_help_for_add_mentions_argument() -> None:
>       app = _create_todo_app()

tests\Typer\functional_test.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Typer\functional_test.py:92: in _create_todo_app
    def add(title: str) -> None:
generation\Typer\typer\__init__.py:196: in decorator
    params = _build_click_params(fn)
generation\Typer\typer\__init__.py:160: in _build_click_params
    argument = click.Argument(decls, **kwargs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2994: in __init__
    super().__init__(param_decls, required=required, **attrs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2114: in __init__
    self.type: types.ParamType = types.convert_type(type, default)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:1056: in convert_type
    return FuncParamType(ty)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <click.types.FuncParamType object at 0x0000021BCA585520>, func = 'str'

    def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
>       self.name: str = func.__name__
E       AttributeError: 'str' object has no attribute '__name__'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:166: AttributeError
________________________ test_prompt_option_happy_path ________________________

    def test_prompt_option_happy_path() -> None:
>       app = _create_prompt_app()

tests\Typer\functional_test.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Typer\functional_test.py:120: in _create_prompt_app
    def greet(
generation\Typer\typer\__init__.py:196: in decorator
    params = _build_click_params(fn)
generation\Typer\typer\__init__.py:130: in _build_click_params
    option = click.Option(list(decls), **kwargs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2536: in __init__
    super().__init__(param_decls, type=type, multiple=multiple, **attrs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2114: in __init__
    self.type: types.ParamType = types.convert_type(type, default)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:1056: in convert_type
    return FuncParamType(ty)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <click.types.FuncParamType object at 0x0000021BCA72F3D0>, func = 'str'

    def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
>       self.name: str = func.__name__
E       AttributeError: 'str' object has no attribute '__name__'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:166: AttributeError
________________________ test_envvar_option_happy_path ________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000021BCA49F070>

    def test_envvar_option_happy_path(monkeypatch: pytest.MonkeyPatch) -> None:
>       app = _create_env_app()

tests\Typer\functional_test.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Typer\functional_test.py:144: in _create_env_app
    def show(token: str = typer.Option(..., "--token", envvar="APP_TOKEN")) -> None:
generation\Typer\typer\__init__.py:196: in decorator
    params = _build_click_params(fn)
generation\Typer\typer\__init__.py:130: in _build_click_params
    option = click.Option(list(decls), **kwargs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2536: in __init__
    super().__init__(param_decls, type=type, multiple=multiple, **attrs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2114: in __init__
    self.type: types.ParamType = types.convert_type(type, default)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:1056: in convert_type
    return FuncParamType(ty)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <click.types.FuncParamType object at 0x0000021BCA49F100>, func = 'str'

    def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
>       self.name: str = func.__name__
E       AttributeError: 'str' object has no attribute '__name__'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:166: AttributeError
_____________ test_callback_global_option_affects_command_output ______________

    def test_callback_global_option_affects_command_output() -> None:
>       app = _create_callback_app()

tests\Typer\functional_test.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_callback_app() -> typer.Typer:
        """App with a callback global option that influences command output."""
        app = typer.Typer()
        state: Dict[str, bool] = {"verbose": False}
    
>       @app.callback()
E       TypeError: 'NoneType' object is not callable

tests\Typer\functional_test.py:159: TypeError
____________________ test_typed_arguments_and_float_option ____________________

    def test_typed_arguments_and_float_option() -> None:
>       app = _create_types_app()

tests\Typer\functional_test.py:310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Typer\functional_test.py:181: in _create_types_app
    def calc(x: int, y: int, scale: float = typer.Option(1.0, "--scale")) -> None:
generation\Typer\typer\__init__.py:196: in decorator
    params = _build_click_params(fn)
generation\Typer\typer\__init__.py:160: in _build_click_params
    argument = click.Argument(decls, **kwargs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2994: in __init__
    super().__init__(param_decls, required=required, **attrs)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\core.py:2114: in __init__
    self.type: types.ParamType = types.convert_type(type, default)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:1056: in convert_type
    return FuncParamType(ty)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <click.types.FuncParamType object at 0x0000021BCA610E50>, func = 'int'

    def __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
>       self.name: str = func.__name__
E       AttributeError: 'str' object has no attribute '__name__'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\click\types.py:166: AttributeError
=========================== short test summary info ===========================
FAILED tests/Typer/functional_test.py::test_simple_hello_command - TypeError:...
FAILED tests/Typer/functional_test.py::test_simple_hello_command_excited - Ty...
FAILED tests/Typer/functional_test.py::test_greeter_help_mentions_option_and_argument
FAILED tests/Typer/functional_test.py::test_todo_list_empty_shows_no_tasks - ...
FAILED tests/Typer/functional_test.py::test_todo_add_and_list - AttributeErro...
FAILED tests/Typer/functional_test.py::test_todo_remove_then_list_updates - A...
FAILED tests/Typer/functional_test.py::test_help_output_includes_commands - A...
FAILED tests/Typer/functional_test.py::test_subcommand_help_for_add_mentions_argument
FAILED tests/Typer/functional_test.py::test_prompt_option_happy_path - Attrib...
FAILED tests/Typer/functional_test.py::test_envvar_option_happy_path - Attrib...
FAILED tests/Typer/functional_test.py::test_callback_global_option_affects_command_output
FAILED tests/Typer/functional_test.py::test_typed_arguments_and_float_option
12 failed in 1.69s

==========================================================================================
PROJECT: Watchdog
LOG: D:\桌面\Exp1\o3\results\Watchdog\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
_____________ ERROR collecting tests/Watchdog/functional_test.py ______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\Watchdog\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\Watchdog\functional_test.py:55: in <module>
    from watchdog.events import (  # type: ignore  # noqa: E402
E   ImportError: cannot import name 'PatternMatchingEventHandler' from 'watchdog.events' (D:\桌面\RealAppCodeBench_generic_eval\generation\Watchdog\watchdog\events.py)
=========================== short test summary info ===========================
ERROR tests/Watchdog/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.59s

==========================================================================================
PROJECT: Xmltodict
LOG: D:\桌面\Exp1\o3\results\Xmltodict\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFFF                                                             [100%]
================================== FAILURES ===================================
__________________________ test_parse_simple_element __________________________

    def test_parse_simple_element() -> None:
        """Parsing a simple XML element should produce the expected dict."""
        xml = "<root><message>Hello</message></root>"
>       data = _parse(xml)

tests\Xmltodict\functional_test.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:144: in parse
    return _convert(root)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

el = <Element 'root' at 0x0000027F5928F130>

    def _convert(el: _ET.Element) -> Mapping[str, Any]:
        """
        Convert *el* into mapping according to the rules described above and
        return ``{el.tag: value}``.
        """
        node_map: MutableMapping[str, Any] = dict_constructor()
    
        # Attributes ---------------------------------------------------- #
        for k, v in el.attrib.items():
            node_map[f"{attr_prefix}{k}"] = v
    
        # Children ------------------------------------------------------ #
        for child in el:
            child_mapping = _convert(child)
            tag, value = next(iter(child_mapping.items()))
    
            if tag in node_map:
                existing = node_map[tag]
                if isinstance(existing, list):
                    existing.append(value)
                else:
                    node_map[tag] = [existing, value]
            else:
                node_map[tag] = value
    
        # Text ---------------------------------------------------------- #
        text = (el.text or "").strip()
        if text:
            if node_map:
                node_map[cdata_key] = text
            else:
                # No attributes/children – represent directly as text
                return dict_constructor(((el.tag, text),))
    
>       return dict_constructor(((el.tag, node_map)))
E       ValueError: too many values to unpack (expected 2)

generation\Xmltodict\xmltodict.py:142: ValueError
____________________ test_parse_repeated_elements_as_list _____________________

    def test_parse_repeated_elements_as_list() -> None:
        """Repeated child elements should be represented as a list."""
        xml = "<root><item>1</item><item>2</item><item>3</item></root>"
>       data = _parse(xml)

tests\Xmltodict\functional_test.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:144: in parse
    return _convert(root)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

el = <Element 'root' at 0x0000027F591ECD60>

    def _convert(el: _ET.Element) -> Mapping[str, Any]:
        """
        Convert *el* into mapping according to the rules described above and
        return ``{el.tag: value}``.
        """
        node_map: MutableMapping[str, Any] = dict_constructor()
    
        # Attributes ---------------------------------------------------- #
        for k, v in el.attrib.items():
            node_map[f"{attr_prefix}{k}"] = v
    
        # Children ------------------------------------------------------ #
        for child in el:
            child_mapping = _convert(child)
            tag, value = next(iter(child_mapping.items()))
    
            if tag in node_map:
                existing = node_map[tag]
                if isinstance(existing, list):
                    existing.append(value)
                else:
                    node_map[tag] = [existing, value]
            else:
                node_map[tag] = value
    
        # Text ---------------------------------------------------------- #
        text = (el.text or "").strip()
        if text:
            if node_map:
                node_map[cdata_key] = text
            else:
                # No attributes/children – represent directly as text
                return dict_constructor(((el.tag, text),))
    
>       return dict_constructor(((el.tag, node_map)))
E       ValueError: too many values to unpack (expected 2)

generation\Xmltodict\xmltodict.py:142: ValueError
_______________________ test_parse_attributes_and_text ________________________

    def test_parse_attributes_and_text() -> None:
        """Attributes and text content should be exposed using @attr and #text keys."""
        xml = '<user id="123">Alice</user>'
>       data = _parse(xml)

tests\Xmltodict\functional_test.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:144: in parse
    return _convert(root)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

el = <Element 'user' at 0x0000027F59315040>

    def _convert(el: _ET.Element) -> Mapping[str, Any]:
        """
        Convert *el* into mapping according to the rules described above and
        return ``{el.tag: value}``.
        """
        node_map: MutableMapping[str, Any] = dict_constructor()
    
        # Attributes ---------------------------------------------------- #
        for k, v in el.attrib.items():
            node_map[f"{attr_prefix}{k}"] = v
    
        # Children ------------------------------------------------------ #
        for child in el:
            child_mapping = _convert(child)
            tag, value = next(iter(child_mapping.items()))
    
            if tag in node_map:
                existing = node_map[tag]
                if isinstance(existing, list):
                    existing.append(value)
                else:
                    node_map[tag] = [existing, value]
            else:
                node_map[tag] = value
    
        # Text ---------------------------------------------------------- #
        text = (el.text or "").strip()
        if text:
            if node_map:
                node_map[cdata_key] = text
            else:
                # No attributes/children – represent directly as text
                return dict_constructor(((el.tag, text),))
    
>       return dict_constructor(((el.tag, node_map)))
E       ValueError: too many values to unpack (expected 2)

generation\Xmltodict\xmltodict.py:142: ValueError
___________________ test_unparse_roundtrip_basic_structure ____________________

    def test_unparse_roundtrip_basic_structure() -> None:
        """unparse() followed by parse() should preserve the logical structure."""
        original = {
            "root": {
                "item": [
                    {"@id": "1", "#text": "A"},
                    {"@id": "2", "#text": "B"},
                ]
            }
        }
    
        xml = _unparse(original)
>       round_tripped = _parse(xml)

tests\Xmltodict\functional_test.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:144: in parse
    return _convert(root)
generation\Xmltodict\xmltodict.py:121: in _convert
    child_mapping = _convert(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

el = <Element 'item' at 0x0000027F591ECB30>

    def _convert(el: _ET.Element) -> Mapping[str, Any]:
        """
        Convert *el* into mapping according to the rules described above and
        return ``{el.tag: value}``.
        """
        node_map: MutableMapping[str, Any] = dict_constructor()
    
        # Attributes ---------------------------------------------------- #
        for k, v in el.attrib.items():
            node_map[f"{attr_prefix}{k}"] = v
    
        # Children ------------------------------------------------------ #
        for child in el:
            child_mapping = _convert(child)
            tag, value = next(iter(child_mapping.items()))
    
            if tag in node_map:
                existing = node_map[tag]
                if isinstance(existing, list):
                    existing.append(value)
                else:
                    node_map[tag] = [existing, value]
            else:
                node_map[tag] = value
    
        # Text ---------------------------------------------------------- #
        text = (el.text or "").strip()
        if text:
            if node_map:
                node_map[cdata_key] = text
            else:
                # No attributes/children – represent directly as text
                return dict_constructor(((el.tag, text),))
    
>       return dict_constructor(((el.tag, node_map)))
E       ValueError: too many values to unpack (expected 2)

generation\Xmltodict\xmltodict.py:142: ValueError
_____________________ test_namespace_prefix_is_preserved ______________________

    def test_namespace_prefix_is_preserved() -> None:
        """Namespace prefixes in element names should be preserved in dict keys."""
        xml = """
        <root xmlns:x="http://example.com/x">
            <x:item>value</x:item>
        </root>
        """
>       data = _parse(xml)

tests\Xmltodict\functional_test.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:144: in parse
    return _convert(root)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

el = <Element 'root' at 0x0000027F59209770>

    def _convert(el: _ET.Element) -> Mapping[str, Any]:
        """
        Convert *el* into mapping according to the rules described above and
        return ``{el.tag: value}``.
        """
        node_map: MutableMapping[str, Any] = dict_constructor()
    
        # Attributes ---------------------------------------------------- #
        for k, v in el.attrib.items():
            node_map[f"{attr_prefix}{k}"] = v
    
        # Children ------------------------------------------------------ #
        for child in el:
            child_mapping = _convert(child)
            tag, value = next(iter(child_mapping.items()))
    
            if tag in node_map:
                existing = node_map[tag]
                if isinstance(existing, list):
                    existing.append(value)
                else:
                    node_map[tag] = [existing, value]
            else:
                node_map[tag] = value
    
        # Text ---------------------------------------------------------- #
        text = (el.text or "").strip()
        if text:
            if node_map:
                node_map[cdata_key] = text
            else:
                # No attributes/children – represent directly as text
                return dict_constructor(((el.tag, text),))
    
>       return dict_constructor(((el.tag, node_map)))
E       ValueError: too many values to unpack (expected 2)

generation\Xmltodict\xmltodict.py:142: ValueError
_________________________ test_parse_nested_structure _________________________

    def test_parse_nested_structure() -> None:
        """Nested XML elements should map to nested dict structures."""
        xml = """
        <root>
            <user>
                <name>Ada</name>
                <address>
                    <city>London</city>
                    <country>UK</country>
                </address>
            </user>
        </root>
        """
>       data = _parse(xml)

tests\Xmltodict\functional_test.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:144: in parse
    return _convert(root)
generation\Xmltodict\xmltodict.py:121: in _convert
    child_mapping = _convert(child)
generation\Xmltodict\xmltodict.py:121: in _convert
    child_mapping = _convert(child)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

el = <Element 'address' at 0x0000027F592BBD60>

    def _convert(el: _ET.Element) -> Mapping[str, Any]:
        """
        Convert *el* into mapping according to the rules described above and
        return ``{el.tag: value}``.
        """
        node_map: MutableMapping[str, Any] = dict_constructor()
    
        # Attributes ---------------------------------------------------- #
        for k, v in el.attrib.items():
            node_map[f"{attr_prefix}{k}"] = v
    
        # Children ------------------------------------------------------ #
        for child in el:
            child_mapping = _convert(child)
            tag, value = next(iter(child_mapping.items()))
    
            if tag in node_map:
                existing = node_map[tag]
                if isinstance(existing, list):
                    existing.append(value)
                else:
                    node_map[tag] = [existing, value]
            else:
                node_map[tag] = value
    
        # Text ---------------------------------------------------------- #
        text = (el.text or "").strip()
        if text:
            if node_map:
                node_map[cdata_key] = text
            else:
                # No attributes/children – represent directly as text
                return dict_constructor(((el.tag, text),))
    
>       return dict_constructor(((el.tag, node_map)))
E       ValueError: too many values to unpack (expected 2)

generation\Xmltodict\xmltodict.py:142: ValueError
__________________ test_force_list_option_for_single_element __________________

    def test_force_list_option_for_single_element() -> None:
        """force_list should allow representing a single child as a list when supported."""
        xml = "<root><item>1</item></root>"
    
        # Prefer a targeted force_list that is common in xmltodict.
>       data = _parse(xml, force_list=("item",))

tests\Xmltodict\functional_test.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:144: in parse
    return _convert(root)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

el = <Element 'root' at 0x0000027F59277E00>

    def _convert(el: _ET.Element) -> Mapping[str, Any]:
        """
        Convert *el* into mapping according to the rules described above and
        return ``{el.tag: value}``.
        """
        node_map: MutableMapping[str, Any] = dict_constructor()
    
        # Attributes ---------------------------------------------------- #
        for k, v in el.attrib.items():
            node_map[f"{attr_prefix}{k}"] = v
    
        # Children ------------------------------------------------------ #
        for child in el:
            child_mapping = _convert(child)
            tag, value = next(iter(child_mapping.items()))
    
            if tag in node_map:
                existing = node_map[tag]
                if isinstance(existing, list):
                    existing.append(value)
                else:
                    node_map[tag] = [existing, value]
            else:
                node_map[tag] = value
    
        # Text ---------------------------------------------------------- #
        text = (el.text or "").strip()
        if text:
            if node_map:
                node_map[cdata_key] = text
            else:
                # No attributes/children – represent directly as text
                return dict_constructor(((el.tag, text),))
    
>       return dict_constructor(((el.tag, node_map)))
E       ValueError: too many values to unpack (expected 2)

generation\Xmltodict\xmltodict.py:142: ValueError
_____________ test_custom_attr_prefix_and_cdata_key_if_supported ______________

    def test_custom_attr_prefix_and_cdata_key_if_supported() -> None:
        """attr_prefix / cdata_key customization should reflect in output when supported."""
        xml = '<user id="7">Bob</user>'
    
>       data = _parse(xml, attr_prefix="$", cdata_key="text")

tests\Xmltodict\functional_test.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:144: in parse
    return _convert(root)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

el = <Element 'user' at 0x0000027F591ECF40>

    def _convert(el: _ET.Element) -> Mapping[str, Any]:
        """
        Convert *el* into mapping according to the rules described above and
        return ``{el.tag: value}``.
        """
        node_map: MutableMapping[str, Any] = dict_constructor()
    
        # Attributes ---------------------------------------------------- #
        for k, v in el.attrib.items():
            node_map[f"{attr_prefix}{k}"] = v
    
        # Children ------------------------------------------------------ #
        for child in el:
            child_mapping = _convert(child)
            tag, value = next(iter(child_mapping.items()))
    
            if tag in node_map:
                existing = node_map[tag]
                if isinstance(existing, list):
                    existing.append(value)
                else:
                    node_map[tag] = [existing, value]
            else:
                node_map[tag] = value
    
        # Text ---------------------------------------------------------- #
        text = (el.text or "").strip()
        if text:
            if node_map:
                node_map[cdata_key] = text
            else:
                # No attributes/children – represent directly as text
                return dict_constructor(((el.tag, text),))
    
>       return dict_constructor(((el.tag, node_map)))
E       ValueError: too many values to unpack (expected 2)

generation\Xmltodict\xmltodict.py:142: ValueError
____________ test_xml_attribs_false_drops_attributes_if_supported _____________

    def test_xml_attribs_false_drops_attributes_if_supported() -> None:
        """xml_attribs=False should omit attribute keys when supported."""
        xml = '<user id="9"><name>Alice</name></user>'
    
>       data = _parse(xml, xml_attribs=False)

tests\Xmltodict\functional_test.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:144: in parse
    return _convert(root)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

el = <Element 'user' at 0x0000027F5928FC20>

    def _convert(el: _ET.Element) -> Mapping[str, Any]:
        """
        Convert *el* into mapping according to the rules described above and
        return ``{el.tag: value}``.

