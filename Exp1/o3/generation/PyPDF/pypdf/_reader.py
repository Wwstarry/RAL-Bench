"""
Very small stand-in for pypdf.PdfReader.
"""
from __future__ import annotations

import io
from pathlib import Path
from typing import Dict, List, Union, IO

from ._page import PageObject
from ._pages import _Pages
from ._utils import loads_doc


class PdfReader:
    """
    Minimal reader able to consume files previously generated by
    :class:`pypdf.PdfWriter`.
    """

    def __init__(self, stream: Union[str, IO[bytes], Path]):
        if isinstance(stream, (str, bytes, Path)):
            with open(stream, "rb") as fp:
                self._raw_data = fp.read()
        else:
            # assume file-like – we read everything into memory
            self._raw_data = stream.read()

        self._doc: Dict = loads_doc(self._raw_data)

        # Encryption flags
        self._encrypted: bool = bool(self._doc.get("encrypted", False))
        self._password: str = str(self._doc.get("password", ""))
        self._decrypted: bool = not self._encrypted

        # Pages – will be initialised lazily after decryption
        self._pages_cache: List[PageObject] | None = None

    # ------------------------------------------------------------------ #
    # Encryption handling
    # ------------------------------------------------------------------ #
    @property
    def is_encrypted(self) -> bool:
        return self._encrypted

    def decrypt(self, password: str) -> int:
        """
        Fake decryption routine – simply compares *password* with whatever was
        stored by :pymeth:`pypdf.PdfWriter.encrypt`.
        """
        if not self._encrypted:
            # Not encrypted: treat as success
            return 1

        if password == self._password:
            self._decrypted = True
            return 1
        return 0

    # ------------------------------------------------------------------ #
    # Metadata
    # ------------------------------------------------------------------ #
    @property
    def metadata(self) -> Dict[str, str]:
        if not self._decrypted:
            raise ValueError("Document is encrypted – call decrypt() first")
        return dict(self._doc.get("metadata", {}))

    # ------------------------------------------------------------------ #
    # Pages access
    # ------------------------------------------------------------------ #
    @property
    def pages(self) -> _Pages:
        if not self._decrypted:
            raise ValueError("Document is encrypted – call decrypt() first")
        if self._pages_cache is None:
            self._pages_cache = [PageObject.from_dict(d) for d in self._doc.get("pages", [])]
        return _Pages(self._pages_cache)