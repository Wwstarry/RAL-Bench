FFFFFFFFFsFFF                                                            [100%]
================================== FAILURES ===================================
_____________________ test_parse_and_timezone_conversion ______________________

    def test_parse_and_timezone_conversion() -> None:
        """Parse an ISO string and convert between timezones."""
        dt_utc = pendulum.parse("2020-01-01T12:00:00+00:00")
    
>       assert dt_utc.year == 2020
E       AttributeError: 'DateTime' object has no attribute 'year'

tests\Pendulum\functional_test.py:68: AttributeError
____________________ test_datetime_arithmetic_and_duration ____________________

    def test_datetime_arithmetic_and_duration() -> None:
        """Basic arithmetic with pendulum.datetime and pendulum.duration."""
>       base = pendulum.datetime(2021, 3, 15, 10, 30, 0, tz="UTC")

tests\Pendulum\functional_test.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4ab81490>
year = 2021, month = 3, day = 15, hour = 10, minute = 30, second = 0
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
_________________________ test_diff_for_humans_months _________________________

    def test_diff_for_humans_months() -> None:
        """Human-readable differences between two datetimes."""
>       start = pendulum.datetime(2011, 8, 1, tz="UTC")

tests\Pendulum\functional_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4abd5b20>
year = 2011, month = 8, day = 1, hour = 0, minute = 0, second = 0
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
_____________________ test_parse_date_only_to_date_string _____________________

    def test_parse_date_only_to_date_string() -> None:
        """Parse a date-only string and verify normalized date output."""
        d = pendulum.parse("2020-02-29")
>       assert d.year == 2020
E       AttributeError: 'DateTime' object has no attribute 'year'

tests\Pendulum\functional_test.py:118: AttributeError
__________________ test_datetime_to_iso8601_string_roundtrip __________________

    def test_datetime_to_iso8601_string_roundtrip() -> None:
        """Create a datetime and verify ISO8601 string contains expected offset."""
>       dt = pendulum.datetime(2020, 1, 1, 12, 0, 0, tz="UTC")

tests\Pendulum\functional_test.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4abf5ac0>
year = 2020, month = 1, day = 1, hour = 12, minute = 0, second = 0
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
_____________________ test_formatting_with_custom_pattern _____________________

    def test_formatting_with_custom_pattern() -> None:
        """Verify formatting with a custom pattern is stable for a fixed datetime."""
>       dt = pendulum.datetime(2021, 12, 31, 23, 59, 58, tz="UTC")

tests\Pendulum\functional_test.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4ab727f0>
year = 2021, month = 12, day = 31, hour = 23, minute = 59, second = 58
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
__________________________ test_start_of_end_of_day ___________________________

    def test_start_of_end_of_day() -> None:
        """Check start_of and end_of for a day boundary."""
>       dt = pendulum.datetime(2020, 5, 20, 13, 14, 15, tz="UTC")

tests\Pendulum\functional_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4ab742e0>
year = 2020, month = 5, day = 20, hour = 13, minute = 14, second = 15
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
_____________________ test_weekday_and_isoweekday_values ______________________

    def test_weekday_and_isoweekday_values() -> None:
        """Validate weekday values for a known date (2020-01-01 is Wednesday)."""
>       dt = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:155: AttributeError
_________________ test_duration_total_seconds_and_components __________________

    def test_duration_total_seconds_and_components() -> None:
        """Verify duration reports correct total seconds and has component attributes."""
        dur = pendulum.duration(days=1, hours=2, minutes=3, seconds=4)
    
        # Total seconds is the most stable cross-version contract.
        assert dur.total_seconds() == 1 * 86400 + 2 * 3600 + 3 * 60 + 4
    
        # Component attributes commonly exist; assert them when present.
>       assert dur.days == 1
E       AttributeError: 'Duration' object has no attribute 'days'

tests\Pendulum\functional_test.py:168: AttributeError
_____________________ test_in_timezone_preserves_instant ______________________

    def test_in_timezone_preserves_instant() -> None:
        """Converting timezones should preserve the instant (timestamp)."""
>       dt_utc = pendulum.datetime(2020, 6, 1, 0, 0, 0, tz="UTC")

tests\Pendulum\functional_test.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4abe7550>
year = 2020, month = 6, day = 1, hour = 0, minute = 0, second = 0
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
________________________ test_diff_in_days_is_integer _________________________

    def test_diff_in_days_is_integer() -> None:
        """Compute diff in days between two dates."""
>       a = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:207: AttributeError
____________________ test_add_months_across_year_boundary _____________________

    def test_add_months_across_year_boundary() -> None:
        """Add months and verify year boundary transitions."""
>       dt = pendulum.date(2019, 12, 15)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:217: AttributeError
=========================== short test summary info ===========================
FAILED tests/Pendulum/functional_test.py::test_parse_and_timezone_conversion
FAILED tests/Pendulum/functional_test.py::test_datetime_arithmetic_and_duration
FAILED tests/Pendulum/functional_test.py::test_diff_for_humans_months - TypeE...
FAILED tests/Pendulum/functional_test.py::test_parse_date_only_to_date_string
FAILED tests/Pendulum/functional_test.py::test_datetime_to_iso8601_string_roundtrip
FAILED tests/Pendulum/functional_test.py::test_formatting_with_custom_pattern
FAILED tests/Pendulum/functional_test.py::test_start_of_end_of_day - TypeErro...
FAILED tests/Pendulum/functional_test.py::test_weekday_and_isoweekday_values
FAILED tests/Pendulum/functional_test.py::test_duration_total_seconds_and_components
FAILED tests/Pendulum/functional_test.py::test_in_timezone_preserves_instant
FAILED tests/Pendulum/functional_test.py::test_diff_in_days_is_integer - Attr...
FAILED tests/Pendulum/functional_test.py::test_add_months_across_year_boundary
12 failed, 1 skipped in 0.87s
