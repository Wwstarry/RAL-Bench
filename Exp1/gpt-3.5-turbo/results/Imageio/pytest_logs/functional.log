.F.F..FFF.                                                               [100%]
================================== FAILURES ===================================
__________________ test_gif_multiframe_roundtrip_with_imiter __________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-337/test_gif_multiframe_roundtrip_0')

    def test_gif_multiframe_roundtrip_with_imiter(tmp_path: Path) -> None:
        """Write a small animated GIF and iterate frames using imiter."""
        frames = _make_grayscale_frames(num_frames=6, height=24, width=24)
        path = tmp_path / "anim.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       loaded_frames = list(iio.imiter(path))

tests\Imageio\functional_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Imageio\imageio\v3.py:618: in imiter
    arr = _read_gif(path)
generation\Imageio\imageio\v3.py:379: in _read_gif
    frame_indices = _decode_lzw(bytes(compressed_data), min_code_size, w*h)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b'\x00\xaf\x01(\'\xee\xdc9\x00\xe0\xb4q3\xe7\xad \x00m\xe2\xcai;\xa7\x8d\xd5\xb5\x8b\xd7\xcc\x91\x03\xb0\xa2\\ t\xda\x...7\xa2\xda\x12j\xeb\xb8B\xa6\xb8\x91\x12C\x9e\xb3\xb2b*:tg\xf1Z9\x87.\x10\x80@\xe2\xcc\xad\xf8\x08\xd3\x9b\xd0s\x01\x01'
min_code_size = 8, expected_size = 576

    def _decode_lzw(data, min_code_size, expected_size):
        # Minimal LZW decoder for GIF
        # data: bytes of compressed data
        # min_code_size: int
        # expected_size: number of pixels expected in output
        # Returns list of indices
    
        clear_code = 1 << min_code_size
        end_code = clear_code + 1
        code_size = min_code_size + 1
        max_code = (1 << code_size) - 1
    
        # Initialize dictionary
        dict_size = end_code + 1
        dictionary = {i: bytes([i]) for i in range(clear_code)}
        dictionary[clear_code] = None
        dictionary[end_code] = None
    
        bit_pos = 0
        bit_len = len(data) * 8
    
        def get_code():
            nonlocal bit_pos
            code = 0
            bits_read = 0
            while bits_read < code_size and bit_pos < bit_len:
                byte_pos = bit_pos // 8
                bit_offset = bit_pos % 8
                bits_left = 8 - bit_offset
                bits_to_read = min(bits_left, code_size - bits_read)
                mask = (1 << bits_to_read) - 1
                bits = (data[byte_pos] >> bit_offset) & mask
                code |= bits << bits_read
                bits_read += bits_to_read
                bit_pos += bits_to_read
            if bits_read < code_size:
                return None
            return code
    
        result = bytearray()
        prev_code = None
        while True:
            code = get_code()
            if code is None:
                break
            if code == clear_code:
                dictionary = {i: bytes([i]) for i in range(clear_code)}
                dictionary[clear_code] = None
                dictionary[end_code] = None
                dict_size = end_code + 1
                code_size = min_code_size + 1
                max_code = (1 << code_size) - 1
                prev_code = None
                continue
            if code == end_code:
                break
            if code in dictionary:
                entry = dictionary[code]
                if prev_code is not None:
                    dictionary[dict_size] = dictionary[prev_code] + entry[:1]
                    dict_size += 1
            elif code == dict_size:
                entry = dictionary[prev_code] + dictionary[prev_code][:1]
                dictionary[dict_size] = entry
                dict_size += 1
            else:
>               raise ValueError("Invalid LZW code")
E               ValueError: Invalid LZW code

generation\Imageio\imageio\v3.py:486: ValueError
_____________________ test_png_roundtrip_via_bytes_buffer _____________________

    def test_png_roundtrip_via_bytes_buffer() -> None:
        """Write PNG to in-memory bytes, then read back using extension."""
        img = _make_color_image(height=20, width=31)
    
>       blob = iio.imwrite("<bytes>", img, extension=".png")
E       TypeError: imwrite() got an unexpected keyword argument 'extension'

tests\Imageio\functional_test.py:139: TypeError
___________ test_gif_imread_returns_stack_with_expected_frame_count ___________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-337/test_gif_imread_returns_stack_0')

    def test_gif_imread_returns_stack_with_expected_frame_count(tmp_path: Path) -> None:
        """Reading a GIF via imread should produce a stack/sequence with the right number of frames."""
        frames = _make_grayscale_frames(num_frames=5, height=20, width=21)
        path = tmp_path / "stack.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       loaded = iio.imread(path)

tests\Imageio\functional_test.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Imageio\imageio\v3.py:602: in imread
    arr = _read_gif(path)
generation\Imageio\imageio\v3.py:379: in _read_gif
    frame_indices = _decode_lzw(bytes(compressed_data), min_code_size, w*h)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\x00\xaf\x01('\xee\xdc9\x00\xe0\xb4q3\xe7\xad \x00m\xe2\xcai;\xa7\x8d\xd5\xb5\x8b\xd7\xcc\x91\x03\xb0\xa2\\ t\xda\x0...x1c\x00\x00V\xac\\[\xa1P\xdb5\x00\xe6\xac\x00\xf0V\xce\x9c\xb8\x15\xdc\xc0q\xbbVN\x1b+\x95\xe8\xca%\\9\xd0\n9t\x01\x01"
min_code_size = 8, expected_size = 420

    def _decode_lzw(data, min_code_size, expected_size):
        # Minimal LZW decoder for GIF
        # data: bytes of compressed data
        # min_code_size: int
        # expected_size: number of pixels expected in output
        # Returns list of indices
    
        clear_code = 1 << min_code_size
        end_code = clear_code + 1
        code_size = min_code_size + 1
        max_code = (1 << code_size) - 1
    
        # Initialize dictionary
        dict_size = end_code + 1
        dictionary = {i: bytes([i]) for i in range(clear_code)}
        dictionary[clear_code] = None
        dictionary[end_code] = None
    
        bit_pos = 0
        bit_len = len(data) * 8
    
        def get_code():
            nonlocal bit_pos
            code = 0
            bits_read = 0
            while bits_read < code_size and bit_pos < bit_len:
                byte_pos = bit_pos // 8
                bit_offset = bit_pos % 8
                bits_left = 8 - bit_offset
                bits_to_read = min(bits_left, code_size - bits_read)
                mask = (1 << bits_to_read) - 1
                bits = (data[byte_pos] >> bit_offset) & mask
                code |= bits << bits_read
                bits_read += bits_to_read
                bit_pos += bits_to_read
            if bits_read < code_size:
                return None
            return code
    
        result = bytearray()
        prev_code = None
        while True:
            code = get_code()
            if code is None:
                break
            if code == clear_code:
                dictionary = {i: bytes([i]) for i in range(clear_code)}
                dictionary[clear_code] = None
                dictionary[end_code] = None
                dict_size = end_code + 1
                code_size = min_code_size + 1
                max_code = (1 << code_size) - 1
                prev_code = None
                continue
            if code == end_code:
                break
            if code in dictionary:
                entry = dictionary[code]
                if prev_code is not None:
                    dictionary[dict_size] = dictionary[prev_code] + entry[:1]
                    dict_size += 1
            elif code == dict_size:
                entry = dictionary[prev_code] + dictionary[prev_code][:1]
                dictionary[dict_size] = entry
                dict_size += 1
            else:
>               raise ValueError("Invalid LZW code")
E               ValueError: Invalid LZW code

generation\Imageio\imageio\v3.py:486: ValueError
___________ test_gif_imread_index0_matches_first_imiter_frame_shape ___________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-337/test_gif_imread_index0_matches0')

    def test_gif_imread_index0_matches_first_imiter_frame_shape(tmp_path: Path) -> None:
        """Read first GIF frame using both index=0 and imiter; verify consistent spatial shape."""
        frames = _make_grayscale_frames(num_frames=4, height=19, width=23)
        path = tmp_path / "index0.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       first_by_index = iio.imread(path, index=0)
E       TypeError: imread() got an unexpected keyword argument 'index'

tests\Imageio\functional_test.py:206: TypeError
_______________________ test_imopen_write_then_read_png _______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-337/test_imopen_write_then_read_pn0')

    def test_imopen_write_then_read_png(tmp_path: Path) -> None:
        """Use the v3 imopen context manager to write then read a PNG."""
        img = _make_color_image(height=16, width=20)
        path = tmp_path / "imopen.png"
    
>       with iio.imopen(path, "w") as f:
E       AttributeError: module 'imageio.v3' has no attribute 'imopen'

tests\Imageio\functional_test.py:221: AttributeError
=========================== short test summary info ===========================
FAILED tests/Imageio/functional_test.py::test_gif_multiframe_roundtrip_with_imiter
FAILED tests/Imageio/functional_test.py::test_png_roundtrip_via_bytes_buffer
FAILED tests/Imageio/functional_test.py::test_gif_imread_returns_stack_with_expected_frame_count
FAILED tests/Imageio/functional_test.py::test_gif_imread_index0_matches_first_imiter_frame_shape
FAILED tests/Imageio/functional_test.py::test_imopen_write_then_read_png - At...
5 failed, 5 passed in 1.22s
