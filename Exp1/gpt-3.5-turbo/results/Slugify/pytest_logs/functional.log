...F...F..F.                                                             [100%]
================================== FAILURES ===================================
_________________ test_allow_unicode_true_preserves_non_ascii _________________

    def test_allow_unicode_true_preserves_non_ascii() -> None:
        """When allow_unicode is True, unicode characters can be preserved."""
        text = "影師嗎"
>       result = slugify(text, allow_unicode=True)

tests\Slugify\functional_test.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Slugify\slugify\slugify.py:69: in slugify
    pattern = re.compile(r'[^\w\s\p{L}\p{N}\p{M}\p{Pc}\p{Pd}]', re.UNICODE)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\re.py:252: in compile
    return _compile(pattern, flags)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\re.py:304: in _compile
    p = sre_compile.compile(pattern, flags)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_compile.py:764: in compile
    p = sre_parse.parse(p, flags)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:948: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:443: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:554: in _parse
    code1 = _class_escape(source, this)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <sre_parse.Tokenizer object at 0x00000238DC5371C0>, escape = '\\p'

    def _class_escape(source, escape):
        # handle escape code inside character class
        code = ESCAPES.get(escape)
        if code:
            return code
        code = CATEGORIES.get(escape)
        if code and code[0] is IN:
            return code
        try:
            c = escape[1:2]
            if c == "x":
                # hexadecimal escape (exactly two digits)
                escape += source.getwhile(2, HEXDIGITS)
                if len(escape) != 4:
                    raise source.error("incomplete escape %s" % escape, len(escape))
                return LITERAL, int(escape[2:], 16)
            elif c == "u" and source.istext:
                # unicode escape (exactly four digits)
                escape += source.getwhile(4, HEXDIGITS)
                if len(escape) != 6:
                    raise source.error("incomplete escape %s" % escape, len(escape))
                return LITERAL, int(escape[2:], 16)
            elif c == "U" and source.istext:
                # unicode escape (exactly eight digits)
                escape += source.getwhile(8, HEXDIGITS)
                if len(escape) != 10:
                    raise source.error("incomplete escape %s" % escape, len(escape))
                c = int(escape[2:], 16)
                chr(c) # raise ValueError for invalid code
                return LITERAL, c
            elif c == "N" and source.istext:
                import unicodedata
                # named unicode escape e.g. \N{EM DASH}
                if not source.match('{'):
                    raise source.error("missing {")
                charname = source.getuntil('}', 'character name')
                try:
                    c = ord(unicodedata.lookup(charname))
                except KeyError:
                    raise source.error("undefined character name %r" % charname,
                                       len(charname) + len(r'\N{}'))
                return LITERAL, c
            elif c in OCTDIGITS:
                # octal escape (up to three digits)
                escape += source.getwhile(2, OCTDIGITS)
                c = int(escape[1:], 8)
                if c > 0o377:
                    raise source.error('octal escape value %s outside of '
                                       'range 0-0o377' % escape, len(escape))
                return LITERAL, c
            elif c in DIGITS:
                raise ValueError
            if len(escape) == 2:
                if c in ASCIILETTERS:
>                   raise source.error('bad escape %s' % escape, len(escape))
E                   re.error: bad escape \p at position 6

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:349: error
________________ test_regex_pattern_allows_underscore_prefixes ________________

    def test_regex_pattern_allows_underscore_prefixes() -> None:
        """Custom regex_pattern can allow underscores to remain."""
        text = "___This is a test___"
        regex_pattern = r"[^-a-z0-9_]+"
    
        result_default_sep = slugify(text, regex_pattern=regex_pattern)
>       assert result_default_sep.startswith("___")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x00000238D9704670>('___')
E        +    where <built-in method startswith of str object at 0x00000238D9704670> = ''.startswith

tests\Slugify\functional_test.py:173: AssertionError
___________________ test_replacements_apply_before_slugging ___________________

    def test_replacements_apply_before_slugging() -> None:
        """replacements should transform substrings before final slug is produced."""
        text = "C# is not C++"
>       result = slugify(text, replacements=[["C#", "Csharp"], ["C++", "Cpp"]])

tests\Slugify\functional_test.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

text = 'C# is not C++', allow_unicode = False, max_length = None
word_boundary = False, separator = '-', regex_pattern = None, stopwords = None
lowercase = True, replacements = [['C#', 'Csharp'], ['C++', 'Cpp']], kwargs = {}

    def slugify(
        text,
        allow_unicode=False,
        max_length=None,
        word_boundary=False,
        separator='-',
        regex_pattern=None,
        stopwords=None,
        lowercase=True,
        replacements=None,
        **kwargs
    ):
        """
        Generate an ASCII-only slug or a unicode slug from the given text.
    
        Parameters
        ----------
        text : str
            Text to slugify.
        allow_unicode : bool, optional
            Whether to allow unicode characters in the slug. Defaults to False.
        max_length : int or None, optional
            Maximum length of the slug. If set, slug will be truncated.
        word_boundary : bool, optional
            If True and max_length is set, truncate at the last separator before max_length.
        separator : str, optional
            Separator character to use in the slug. Defaults to '-'.
        regex_pattern : str or None, optional
            Custom regex pattern to filter characters. Defaults to None.
        stopwords : iterable or None, optional
            Words to exclude from the slug. Defaults to None.
        lowercase : bool, optional
            Whether to lowercase the slug. Defaults to True.
        replacements : dict or None, optional
            Custom replacements to apply before slugification. Defaults to None.
        **kwargs
            Additional keyword arguments (ignored).
    
        Returns
        -------
        str
            The slugified string.
        """
        if not isinstance(text, str):
            text = str(text)
    
        # Apply custom replacements first
        if replacements:
>           for search, replace in replacements.items():
E           AttributeError: 'list' object has no attribute 'items'

generation\Slugify\slugify\slugify.py:52: AttributeError
=========================== short test summary info ===========================
FAILED tests/Slugify/functional_test.py::test_allow_unicode_true_preserves_non_ascii
FAILED tests/Slugify/functional_test.py::test_regex_pattern_allows_underscore_prefixes
FAILED tests/Slugify/functional_test.py::test_replacements_apply_before_slugging
3 failed, 9 passed in 0.59s
