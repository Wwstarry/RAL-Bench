####################################################################################################
# MODEL: gpt-3.5-turbo
# NUM_PROJECT_LOGS: 37
####################################################################################################

==========================================================================================
PROJECT: Astral
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Astral\pytest_logs\functional.log
==========================================================================================
FF.F.FFF...                                                              [100%]
================================== FAILURES ===================================
_________________________ test_sun_times_basic_sanity _________________________

    def test_sun_times_basic_sanity() -> None:
        """sun() returns expected keys and times are in a plausible order."""
        loc = _london_location()
        d = dt.date(2020, 6, 1)
    
>       s = sun(_observer_from_location(loc), date=d, tzinfo=_safe_tzinfo())

tests\Astral\functional_test.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Astral\astral\sun.py:208: in sun
    return _sun_times(observer, dt, tzinfo)
generation\Astral\astral\sun.py:155: in _sun_times
    ha = _hour_angle(observer.latitude, decl, ZENITH_OFFICIAL)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

latitude = 'Europe/London', declination = 0.38468842668571496, zenith = 90.8333

    def _hour_angle(latitude: float, declination: float, zenith: float) -> Optional[float]:
        """
        Calculate the hour angle for the sun at the given zenith.
        Returns hour angle in degrees or None if sun never rises/sets.
        """
>       lat_rad = radians(latitude)
E       TypeError: must be real number, not str

generation\Astral\astral\sun.py:100: TypeError
______________________ test_sun_time_changes_across_days ______________________

    def test_sun_time_changes_across_days() -> None:
        """Sunrise and sunset should change slightly between consecutive days."""
        loc = _london_location()
        d1 = dt.date(2020, 1, 1)
        d2 = d1 + dt.timedelta(days=1)
    
>       s1 = sun(_observer_from_location(loc), date=d1, tzinfo=_safe_tzinfo())

tests\Astral\functional_test.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Astral\astral\sun.py:208: in sun
    return _sun_times(observer, dt, tzinfo)
generation\Astral\astral\sun.py:155: in _sun_times
    ha = _hour_angle(observer.latitude, decl, ZENITH_OFFICIAL)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

latitude = 'Europe/London', declination = -0.4029454635354721, zenith = 90.8333

    def _hour_angle(latitude: float, declination: float, zenith: float) -> Optional[float]:
        """
        Calculate the hour angle for the sun at the given zenith.
        Returns hour angle in degrees or None if sun never rises/sets.
        """
>       lat_rad = radians(latitude)
E       TypeError: must be real number, not str

generation\Astral\astral\sun.py:100: TypeError
______________ test_locationinfo_has_lat_lon_fields_or_observer _______________

    def test_locationinfo_has_lat_lon_fields_or_observer() -> None:
        loc = _london_location()
    
        if hasattr(loc, "observer"):
            obs = _observer_from_location(loc)
            lat = getattr(obs, "latitude", None)
            lon = getattr(obs, "longitude", None)
        else:
            lat = getattr(loc, "latitude", None)
            lon = getattr(loc, "longitude", None)
    
>       assert isinstance(lat, (int, float))
E       AssertionError: assert False
E        +  where False = isinstance('Europe/London', (<class 'int'>, <class 'float'>))

tests\Astral\functional_test.py:169: AssertionError
_________________________ test_sun_returns_datetimes __________________________

    def test_sun_returns_datetimes() -> None:
        loc = _london_location()
        d = dt.date(2020, 6, 1)
>       s = sun(_observer_from_location(loc), date=d, tzinfo=_safe_tzinfo())

tests\Astral\functional_test.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Astral\astral\sun.py:208: in sun
    return _sun_times(observer, dt, tzinfo)
generation\Astral\astral\sun.py:155: in _sun_times
    ha = _hour_angle(observer.latitude, decl, ZENITH_OFFICIAL)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

latitude = 'Europe/London', declination = 0.38468842668571496, zenith = 90.8333

    def _hour_angle(latitude: float, declination: float, zenith: float) -> Optional[float]:
        """
        Calculate the hour angle for the sun at the given zenith.
        Returns hour angle in degrees or None if sun never rises/sets.
        """
>       lat_rad = radians(latitude)
E       TypeError: must be real number, not str

generation\Astral\astral\sun.py:100: TypeError
_________________ test_sun_noon_is_between_sunrise_and_sunset _________________

    def test_sun_noon_is_between_sunrise_and_sunset() -> None:
        loc = _london_location()
        d = dt.date(2020, 3, 1)
>       s = sun(_observer_from_location(loc), date=d, tzinfo=_safe_tzinfo())

tests\Astral\functional_test.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Astral\astral\sun.py:208: in sun
    return _sun_times(observer, dt, tzinfo)
generation\Astral\astral\sun.py:155: in _sun_times
    ha = _hour_angle(observer.latitude, decl, ZENITH_OFFICIAL)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

latitude = 'Europe/London', declination = -0.13301090125781806, zenith = 90.8333

    def _hour_angle(latitude: float, declination: float, zenith: float) -> Optional[float]:
        """
        Calculate the hour angle for the sun at the given zenith.
        Returns hour angle in degrees or None if sun never rises/sets.
        """
>       lat_rad = radians(latitude)
E       TypeError: must be real number, not str

generation\Astral\astral\sun.py:100: TypeError
_______ test_sun_times_differ_between_locations_same_date_or_one_raises _______

    def test_sun_times_differ_between_locations_same_date_or_one_raises() -> None:
        """
        Some generated implementations have edge-case bugs for certain longitudes that can
        yield out-of-range hours (e.g., hour < 0 or > 23) and raise ValueError.
        This test remains targeted (different locations) while being compatible across
        implementations by accepting either:
          - both computations succeed and differ, OR
          - one implementation raises a clear exception for the second location.
        """
        london = _london_location()
        nyc = _new_york_location()
        d = dt.date(2020, 6, 1)
    
>       s_l = sun(_observer_from_location(london), date=d, tzinfo=_safe_tzinfo())

tests\Astral\functional_test.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Astral\astral\sun.py:208: in sun
    return _sun_times(observer, dt, tzinfo)
generation\Astral\astral\sun.py:155: in _sun_times
    ha = _hour_angle(observer.latitude, decl, ZENITH_OFFICIAL)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

latitude = 'Europe/London', declination = 0.38468842668571496, zenith = 90.8333

    def _hour_angle(latitude: float, declination: float, zenith: float) -> Optional[float]:
        """
        Calculate the hour angle for the sun at the given zenith.
        Returns hour angle in degrees or None if sun never rises/sets.
        """
>       lat_rad = radians(latitude)
E       TypeError: must be real number, not str

generation\Astral\astral\sun.py:100: TypeError
=========================== short test summary info ===========================
FAILED tests/Astral/functional_test.py::test_sun_times_basic_sanity - TypeErr...
FAILED tests/Astral/functional_test.py::test_sun_time_changes_across_days - T...
FAILED tests/Astral/functional_test.py::test_locationinfo_has_lat_lon_fields_or_observer
FAILED tests/Astral/functional_test.py::test_sun_returns_datetimes - TypeErro...
FAILED tests/Astral/functional_test.py::test_sun_noon_is_between_sunrise_and_sunset
FAILED tests/Astral/functional_test.py::test_sun_times_differ_between_locations_same_date_or_one_raises
6 failed, 5 passed in 0.51s

==========================================================================================
PROJECT: Cachetools
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Cachetools\pytest_logs\functional.log
==========================================================================================
.............                                                            [100%]
13 passed in 1.69s

==========================================================================================
PROJECT: Celery
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Celery\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFF                                                               [100%]
================================== FAILURES ===================================
___________________ test_001_import_celery_and_core_symbols ___________________

    def test_001_import_celery_and_core_symbols() -> None:
        _ensure_celery_importable()
        import celery  # noqa: F401
    
        from celery import Celery  # noqa: F401
>       from celery import chain, chord, group, signature  # noqa: F401
E       ImportError: cannot import name 'chain' from 'celery' (D:\桌面\RealAppCodeBench_generic_eval\generation\Celery\celery\__init__.py)

tests\Celery\functional_test.py:61: ImportError
______________ test_002_create_app_and_register_task_runs_delay _______________

    def test_002_create_app_and_register_task_runs_delay() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
>       app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
E       TypeError: __init__() got an unexpected keyword argument 'include'

tests\Celery\functional_test.py:34: TypeError
____ test_003_apply_async_supports_kwargs_and_counts_down_ignored_in_eager ____

    def test_003_apply_async_supports_kwargs_and_counts_down_ignored_in_eager() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
>       app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
E       TypeError: __init__() got an unexpected keyword argument 'include'

tests\Celery\functional_test.py:34: TypeError
__________________ test_004_group_collects_results_in_order ___________________

    def test_004_group_collects_results_in_order() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
>       app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
E       TypeError: __init__() got an unexpected keyword argument 'include'

tests\Celery\functional_test.py:34: TypeError
____________________ test_005_chain_passes_previous_result ____________________

    def test_005_chain_passes_previous_result() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
>       app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
E       TypeError: __init__() got an unexpected keyword argument 'include'

tests\Celery\functional_test.py:34: TypeError
_______________ test_006_chord_runs_callback_over_group_results _______________

    def test_006_chord_runs_callback_over_group_results() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
>       app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
E       TypeError: __init__() got an unexpected keyword argument 'include'

tests\Celery\functional_test.py:34: TypeError
______________ test_007_task_exception_propagates_in_eager_mode _______________

    def test_007_task_exception_propagates_in_eager_mode() -> None:
        """
        In some Celery versions/configs with task_always_eager=True and
        task_eager_propagates=True, the exception is raised immediately during
        delay()/apply_async() rather than on AsyncResult.get().
    
        This test accepts both correct behaviors:
        - delay raises ValueError directly, OR
        - delay returns a result whose .get() raises ValueError.
        """
>       app = _make_app()

tests\Celery\functional_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
>       app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
E       TypeError: __init__() got an unexpected keyword argument 'include'

tests\Celery\functional_test.py:34: TypeError
_____________ test_008_disable_propagation_returns_failed_result ______________

    def test_008_disable_propagation_returns_failed_result() -> None:
        """
        With task_eager_propagates=False:
          - Some Celery builds still raise on get(..., propagate=True)
          - get(..., propagate=False) may return None OR return the exception object
        We accept both behaviors as long as the task is marked failed.
        """
>       app = _make_app()

tests\Celery\functional_test.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
>       app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
E       TypeError: __init__() got an unexpected keyword argument 'include'

tests\Celery\functional_test.py:34: TypeError
_______________ test_009_signature_freeze_has_id_and_task_name ________________

    def test_009_signature_freeze_has_id_and_task_name() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
>       app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
E       TypeError: __init__() got an unexpected keyword argument 'include'

tests\Celery\functional_test.py:34: TypeError
____________ test_010_default_app_does_not_break_custom_app_usage _____________

    def test_010_default_app_does_not_break_custom_app_usage() -> None:
        """
        Ensure that importing celery and using a custom app is not polluted by globals.
        """
>       app = _make_app("celery_test_app_2")

tests\Celery\functional_test.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app_2'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
>       app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
E       TypeError: __init__() got an unexpected keyword argument 'include'

tests\Celery\functional_test.py:34: TypeError
=========================== short test summary info ===========================
FAILED tests/Celery/functional_test.py::test_001_import_celery_and_core_symbols
FAILED tests/Celery/functional_test.py::test_002_create_app_and_register_task_runs_delay
FAILED tests/Celery/functional_test.py::test_003_apply_async_supports_kwargs_and_counts_down_ignored_in_eager
FAILED tests/Celery/functional_test.py::test_004_group_collects_results_in_order
FAILED tests/Celery/functional_test.py::test_005_chain_passes_previous_result
FAILED tests/Celery/functional_test.py::test_006_chord_runs_callback_over_group_results
FAILED tests/Celery/functional_test.py::test_007_task_exception_propagates_in_eager_mode
FAILED tests/Celery/functional_test.py::test_008_disable_propagation_returns_failed_result
FAILED tests/Celery/functional_test.py::test_009_signature_freeze_has_id_and_task_name
FAILED tests/Celery/functional_test.py::test_010_default_app_does_not_break_custom_app_usage
10 failed in 0.48s

==========================================================================================
PROJECT: Click
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Click\pytest_logs\functional.log
==========================================================================================
FFFFF...FFF                                                              [100%]
================================== FAILURES ===================================
________________ test_simple_command_with_argument_and_option _________________

    def test_simple_command_with_argument_and_option():
        @click.command()
        @click.option("--count", "-c", type=int, default=1)
        @click.argument("name")
        def greet(count: int, name: str) -> None:
            for _ in range(count):
                click.echo(f"Hello {name}!")
    
        runner = CliRunner()
        result = runner.invoke(greet, ["--count", "3", "World"])
    
>       assert result.exit_code == 0
E       assert 1 == 0
E        +  where 1 = <click.testing.Result object at 0x000001ECCEC94E80>.exit_code

tests\Click\functional_test.py:143: AssertionError
________________________ test_boolean_flag_option_pair ________________________

    def test_boolean_flag_option_pair():
        @click.command()
        @click.option("--flag/--no-flag", default=False)
        def cli(flag: bool) -> None:
            click.echo(f"FLAG={flag}")
    
        runner = CliRunner()
    
        r1 = runner.invoke(cli, ["--flag"])
>       assert r1.exit_code == 0
E       assert 2 == 0
E        +  where 2 = <click.testing.Result object at 0x000001ECCEC72310>.exit_code

tests\Click\functional_test.py:157: AssertionError
_________________________ test_group_with_subcommands _________________________

    def test_group_with_subcommands():
        @click.group()
>       def cli() -> None:

tests\Click\functional_test.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Click\click\decorators.py:67: in decorator
    grp = _make_group(f, name=name, cls=cls, **attrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <function test_group_with_subcommands.<locals>.cli at 0x000001ECCECB2B80>
name = None, cls = None, attrs = {}, grp_name = 'cli'
grp_cls = <class 'click.core.Group'>
grp = <click.core.Group object at 0x000001ECCECAC1C0>

    def _make_group(f, name=None, cls=None, **attrs):
        grp_name = name or f.__name__
        grp_cls = cls or Group
        grp = grp_cls(name=grp_name, **attrs)
        # Add commands from decorated functions attached to group
>       f(grp)
E       TypeError: cli() takes 0 positional arguments but 1 was given

generation\Click\click\decorators.py:54: TypeError
___________________ test_help_output_for_command_and_group ____________________

    def test_help_output_for_command_and_group():
        @click.group(help="Top level group")
>       def cli() -> None:

tests\Click\functional_test.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Click\click\decorators.py:67: in decorator
    grp = _make_group(f, name=name, cls=cls, **attrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <function test_help_output_for_command_and_group.<locals>.cli at 0x000001ECCECB2D30>
name = None, cls = None, attrs = {'help': 'Top level group'}, grp_name = 'cli'
grp_cls = <class 'click.core.Group'>
grp = <click.core.Group object at 0x000001ECCEC727F0>

    def _make_group(f, name=None, cls=None, **attrs):
        grp_name = name or f.__name__
        grp_cls = cls or Group
        grp = grp_cls(name=grp_name, **attrs)
        # Add commands from decorated functions attached to group
>       f(grp)
E       TypeError: cli() takes 0 positional arguments but 1 was given

generation\Click\click\decorators.py:54: TypeError
____________________ test_get_current_context_propagation _____________________

    def test_get_current_context_propagation():
        @click.group()
        @click.option("--config", type=str, default="default.cfg")
>       def cli(config: str) -> None:

tests\Click\functional_test.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Click\click\decorators.py:67: in decorator
    grp = _make_group(f, name=name, cls=cls, **attrs)
generation\Click\click\decorators.py:54: in _make_group
    f(grp)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

config = <click.core.Group object at 0x000001ECCED08880>

    @click.group()
    @click.option("--config", type=str, default="default.cfg")
    def cli(config: str) -> None:
>       ctx = click.get_current_context()
E       AttributeError: module 'click' has no attribute 'get_current_context'

tests\Click\functional_test.py:223: AttributeError
_______________ test_default_map_provides_default_option_value ________________

    def test_default_map_provides_default_option_value():
        @click.group()
>       def cli() -> None:

tests\Click\functional_test.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Click\click\decorators.py:67: in decorator
    grp = _make_group(f, name=name, cls=cls, **attrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

f = <function test_default_map_provides_default_option_value.<locals>.cli at 0x000001ECCEC29310>
name = None, cls = None, attrs = {}, grp_name = 'cli'
grp_cls = <class 'click.core.Group'>
grp = <click.core.Group object at 0x000001ECCED0D1F0>

    def _make_group(f, name=None, cls=None, **attrs):
        grp_name = name or f.__name__
        grp_cls = cls or Group
        grp = grp_cls(name=grp_name, **attrs)
        # Add commands from decorated functions attached to group
>       f(grp)
E       TypeError: cli() takes 0 positional arguments but 1 was given

generation\Click\click\decorators.py:54: TypeError
_______________ test_parameter_type_validation_error_exit_code ________________

    def test_parameter_type_validation_error_exit_code():
        @click.command()
        @click.option("--count", type=int, required=True)
        def cli(count: int) -> None:
            click.echo(f"COUNT={count}")
    
        runner = CliRunner()
        r = runner.invoke(cli, ["--count", "not-an-int"])
>       assert r.exit_code != 0
E       assert 0 != 0
E        +  where 0 = <click.testing.Result object at 0x000001ECCED05910>.exit_code

tests\Click\functional_test.py:313: AssertionError
_____________ test_path_type_creates_writable_path_in_isolated_fs _____________

    def test_path_type_creates_writable_path_in_isolated_fs():
        @click.command()
>       @click.option("--out", type=click.Path(dir_okay=False, writable=True))
E       AttributeError: module 'click' has no attribute 'Path'

tests\Click\functional_test.py:319: AttributeError
=========================== short test summary info ===========================
FAILED tests/Click/functional_test.py::test_simple_command_with_argument_and_option
FAILED tests/Click/functional_test.py::test_boolean_flag_option_pair - assert...
FAILED tests/Click/functional_test.py::test_group_with_subcommands - TypeErro...
FAILED tests/Click/functional_test.py::test_help_output_for_command_and_group
FAILED tests/Click/functional_test.py::test_get_current_context_propagation
FAILED tests/Click/functional_test.py::test_default_map_provides_default_option_value
FAILED tests/Click/functional_test.py::test_parameter_type_validation_error_exit_code
FAILED tests/Click/functional_test.py::test_path_type_creates_writable_path_in_isolated_fs
8 failed, 3 passed in 3.18s

==========================================================================================
PROJECT: Cmd2
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Cmd2\pytest_logs\functional.log
==========================================================================================
...........                                                              [100%]
11 passed in 2.70s

==========================================================================================
PROJECT: Dataset
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Dataset\pytest_logs\functional.log
==========================================================================================
FFF..FF.F.F                                                              [100%]
================================== FAILURES ===================================
______________________ test_insert_and_query_basic_rows _______________________

    def test_insert_and_query_basic_rows() -> None:
        db = create_in_memory_db()
        table = db["users"]
    
        table.insert({"name": "Alice", "age": 30, "country": "DE"})
        table.insert({"name": "Bob", "age": 41, "country": "US", "active": True})
        table.insert({"name": "Charlie", "age": 41, "country": "US", "active": False})
    
>       assert "id" in _table_columns(table)
E       AssertionError: assert 'id' in ['name', 'age', 'country', 'active']
E        +  where ['name', 'age', 'country', 'active'] = _table_columns(<dataset.table.Table object at 0x0000025575C01E20>)

tests\Dataset\functional_test.py:146: AssertionError
_______________________ test_update_upsert_and_indexes ________________________

    def test_update_upsert_and_indexes() -> None:
        db = create_in_memory_db()
        table = db["accounts"]
    
        rows = [
            {"account_id": 1, "owner": "Alice", "balance": 100.0, "currency": "EUR"},
            {"account_id": 2, "owner": "Bob", "balance": 250.0, "currency": "USD"},
        ]
        table.insert_many(rows)
    
        if hasattr(table, "create_index") and hasattr(table, "has_index"):
            table.create_index(["owner", "currency"])
            assert table.has_index(["owner", "currency"])
    
        table.update({"account_id": 1, "balance": 150.0}, ["account_id"])
        updated = table.find_one(account_id=1)
        assert updated is not None
>       assert pytest.approx(updated["balance"]) == 150.0
E       assert 150.0 == 150.0
E         
E         comparison failed
E         Obtained: 150.0
E         Expected: 150.0

tests\Dataset\functional_test.py:184: AssertionError
____________________ test_transactions_commit_and_rollback ____________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-333/test_transactions_commit_and_r0')

    def test_transactions_commit_and_rollback(tmp_path: Path) -> None:
        db_path = tmp_path / "tx_sample.db"
        db_url = "sqlite:///%s" % str(db_path)
        db = dataset.connect(db_url)
        table = db["events"]
    
        db.begin()
        table.insert({"name": "committed", "category": "ok"})
>       db.commit()

tests\Dataset\functional_test.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <dataset.database.Database object at 0x0000025575C7FB50>

    def commit(self):
        if not self._transaction_active:
            return
>       self._conn.execute("COMMIT")
E       sqlite3.OperationalError: cannot commit - no transaction is active

generation\Dataset\dataset\database.py:36: OperationalError
_______________________ test_find_order_by_limit_offset _______________________

    def test_find_order_by_limit_offset() -> None:
        db = create_in_memory_db()
        table = db["nums"]
        for i in range(10):
            table.insert({"n": i})
    
        rows = list(table.find(order_by="n", _limit=3, _offset=4))
>       assert [r["n"] for r in rows] == [4, 5, 6]
E       assert [] == [4, 5, 6]
E         
E         Right contains 3 more items, first extra item: 4
E         Use -v to get more diff

tests\Dataset\functional_test.py:249: AssertionError
___________________ test_table_all_iteration_and_row_shape ____________________

    def test_table_all_iteration_and_row_shape() -> None:
        db = create_in_memory_db()
        table = db["people"]
        table.insert({"name": "Alice", "age": 30})
        table.insert({"name": "Bob", "age": 31})
    
        rows = list(table.all())
        assert len(rows) == 2
>       assert all(("id" in r and "name" in r) for r in rows)
E       assert False
E        +  where False = all(<generator object test_table_all_iteration_and_row_shape.<locals>.<genexpr> at 0x0000025575BC8350>)

tests\Dataset\functional_test.py:260: AssertionError
___________________ test_drop_table_removes_from_db_tables ____________________

    def test_drop_table_removes_from_db_tables() -> None:
        db = create_in_memory_db()
        table = db["to_drop"]
        table.insert({"x": 1})
    
>       assert "to_drop" in _db_tables(db)
E       AssertionError: assert 'to_drop' in []
E        +  where [] = _db_tables(<dataset.database.Database object at 0x0000025575BF9A90>)

tests\Dataset\functional_test.py:301: AssertionError
_____________________ test_distinct_returns_unique_values _____________________

    def test_distinct_returns_unique_values() -> None:
        db = create_in_memory_db()
        table = db["colors"]
        table.insert_many([{"c": "red"}, {"c": "red"}, {"c": "blue"}])
    
        distinct = list(table.distinct("c"))
>       values = {r["c"] for r in distinct}

tests\Dataset\functional_test.py:333: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x0000025575C7F970>

>   values = {r["c"] for r in distinct}
E   TypeError: string indices must be integers

tests\Dataset\functional_test.py:333: TypeError
=========================== short test summary info ===========================
FAILED tests/Dataset/functional_test.py::test_insert_and_query_basic_rows - A...
FAILED tests/Dataset/functional_test.py::test_update_upsert_and_indexes - ass...
FAILED tests/Dataset/functional_test.py::test_transactions_commit_and_rollback
FAILED tests/Dataset/functional_test.py::test_find_order_by_limit_offset - as...
FAILED tests/Dataset/functional_test.py::test_table_all_iteration_and_row_shape
FAILED tests/Dataset/functional_test.py::test_drop_table_removes_from_db_tables
FAILED tests/Dataset/functional_test.py::test_distinct_returns_unique_values
7 failed, 4 passed in 3.10s

==========================================================================================
PROJECT: Fail2ban
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Fail2ban\pytest_logs\functional.log
==========================================================================================
...F....F...                                                             [100%]
================================== FAILURES ===================================
________________ test_004_filter_core_symbols_exist_statically ________________

    def test_004_filter_core_symbols_exist_statically():
        """
        Do not assume helper names like isValidIP/searchIP (they vary across versions).
        Instead, require stable core anchors in fail2ban.server.filter:
          - A Filter class (or similarly named core filter object), OR
          - presence of key tokens that indicate regex-driven filtering (failregex/<HOST>).
        """
        filter_py = _pkg_dir() / "server" / "filter.py"
        src = _read_text(filter_py)
    
        has_filter_class = _ast_has_class(filter_py, "Filter") or ("class Filter" in src)
        has_regex_tokens = ("failregex" in src.lower()) or ("<host>" in src.lower())
    
>       assert has_filter_class or has_regex_tokens, "Expected core filter anchors (Filter class or failregex/<HOST> tokens)."
E       AssertionError: Expected core filter anchors (Filter class or failregex/<HOST> tokens).
E       assert (False or False)

tests\Fail2ban\functional_test.py:129: AssertionError
____________ test_009_import_filter_and_basic_behavior_if_possible ____________

    def test_009_import_filter_and_basic_behavior_if_possible():
        _prepend_import_path()
        try:
            from fail2ban.server import filter as f
        except ModuleNotFoundError as e:
            msg = str(e).lower()
            assert any(k in msg for k in ["pwd", "grp", "resource", "fcntl"]), f"Unexpected import failure: {e}"
            return
    
        # If import works, ensure the module exposes a core Filter-like object or regex constants.
        if hasattr(f, "Filter"):
            assert callable(getattr(f, "Filter"))
        else:
            src = _read_text(_pkg_dir() / "server" / "filter.py").lower()
>           assert ("failregex" in src) or ("<host>" in src)
E           assert ('failregex' in 'import re\nimport ipaddress\n\ndef isvalidip(ip):\n    """check if the given string is a valid ipv4 or ipv6 address."...   candidate = match.group(0)\n            if isvalidip(candidate):\n                return candidate\n    return none' or '<host>' in 'import re\nimport ipaddress\n\ndef isvalidip(ip):\n    """check if the given string is a valid ipv4 or ipv6 address."...   candidate = match.group(0)\n            if isvalidip(candidate):\n                return candidate\n    return none')

tests\Fail2ban\functional_test.py:187: AssertionError
=========================== short test summary info ===========================
FAILED tests/Fail2ban/functional_test.py::test_004_filter_core_symbols_exist_statically
FAILED tests/Fail2ban/functional_test.py::test_009_import_filter_and_basic_behavior_if_possible
2 failed, 10 passed in 1.29s

==========================================================================================
PROJECT: Folium
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Folium\pytest_logs\functional.log
==========================================================================================
..FFFFFFFF.F                                                             [100%]
================================== FAILURES ===================================
__________________ test_002_create_basic_map_renders_leaflet __________________

    def test_002_create_basic_map_renders_leaflet():
        _prepend_import_path()
        import folium
    
        m = folium.Map(location=[0, 0], zoom_start=2)
>       html = m.get_root().render()

tests\Folium\functional_test.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Folium\folium\map.py:63: in render
    if any(child.get_name().startswith('marker_cluster') for child in self._children.values()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <odict_iterator object at 0x000001AECF2B4CC0>

>   if any(child.get_name().startswith('marker_cluster') for child in self._children.values()):
E   AttributeError: 'NoneType' object has no attribute 'get_name'

generation\Folium\folium\map.py:63: AttributeError
_________________________ test_003_map_has_html_root __________________________

    def test_003_map_has_html_root():
        _prepend_import_path()
        import folium
    
        m = folium.Map(location=[0, 0], zoom_start=2)
        root = m.get_root()
        assert hasattr(root, "render")
>       html = root.render().lower()

tests\Folium\functional_test.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Folium\folium\map.py:63: in render
    if any(child.get_name().startswith('marker_cluster') for child in self._children.values()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <odict_iterator object at 0x000001AECCFE80E0>

>   if any(child.get_name().startswith('marker_cluster') for child in self._children.values()):
E   AttributeError: 'NoneType' object has no attribute 'get_name'

generation\Folium\folium\map.py:63: AttributeError
__________________ test_004_add_marker_layer_changes_output ___________________

    def test_004_add_marker_layer_changes_output():
        _prepend_import_path()
        import folium
    
        m = folium.Map(location=[0, 0], zoom_start=2)
>       base = m.get_root().render()

tests\Folium\functional_test.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Folium\folium\map.py:63: in render
    if any(child.get_name().startswith('marker_cluster') for child in self._children.values()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <odict_iterator object at 0x000001AECF351090>

>   if any(child.get_name().startswith('marker_cluster') for child in self._children.values()):
E   AttributeError: 'NoneType' object has no attribute 'get_name'

generation\Folium\folium\map.py:63: AttributeError
__________________ test_005_add_circle_marker_changes_output __________________

    def test_005_add_circle_marker_changes_output():
        _prepend_import_path()
        import folium
    
        m = folium.Map(location=[0, 0], zoom_start=2)
>       base = m.get_root().render()

tests\Folium\functional_test.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Folium\folium\map.py:63: in render
    if any(child.get_name().startswith('marker_cluster') for child in self._children.values()):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <odict_iterator object at 0x000001AECF30C400>

>   if any(child.get_name().startswith('marker_cluster') for child in self._children.values()):
E   AttributeError: 'NoneType' object has no attribute 'get_name'

generation\Folium\folium\map.py:63: AttributeError
__________________ test_006_add_tile_layer_and_layer_control __________________

    def test_006_add_tile_layer_and_layer_control():
        _prepend_import_path()
        import folium
    
        m = folium.Map(location=[0, 0], zoom_start=2, tiles=None)
>       folium.TileLayer("OpenStreetMap", name="osm").add_to(m)
E       AttributeError: 'TileLayer' object has no attribute 'add_to'

tests\Folium\functional_test.py:92: AttributeError
__________________ test_007_geojson_adds_feature_collection ___________________

    def test_007_geojson_adds_feature_collection():
        _prepend_import_path()
        import folium
    
        gj = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "properties": {"name": "p"},
                    "geometry": {"type": "Point", "coordinates": [0.0, 0.0]},
                }
            ],
        }
    
        m = folium.Map(location=[0, 0], zoom_start=2)
>       folium.GeoJson(gj, name="g").add_to(m)
E       AttributeError: 'GeoJson' object has no attribute 'add_to'

tests\Folium\functional_test.py:115: AttributeError
_________________ test_008_geojson_style_function_serializes __________________

    def test_008_geojson_style_function_serializes():
        _prepend_import_path()
        import folium
    
        gj = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "properties": {"style": "x"},
                    "geometry": {"type": "Point", "coordinates": [0.0, 0.0]},
                }
            ],
        }
    
        def style_fn(feature):
            _ = feature
            return {"color": "red", "weight": 2}
    
        m = folium.Map(location=[0, 0], zoom_start=2)
>       folium.GeoJson(gj, style_function=style_fn).add_to(m)
E       TypeError: __init__() got an unexpected keyword argument 'style_function'

tests\Folium\functional_test.py:141: TypeError
________________________ test_009_map_save_writes_html ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-334/test_009_map_save_writes_html0')

    def test_009_map_save_writes_html(tmp_path: Path):
        _prepend_import_path()
        import folium
    
        out = tmp_path / "m.html"
        m = folium.Map(location=[0, 0], zoom_start=2)
>       m.save(str(out))
E       AttributeError: 'Map' object has no attribute 'save'

tests\Folium\functional_test.py:153: AttributeError
_________________ test_011_markercluster_adds_cluster_snippet _________________

    def test_011_markercluster_adds_cluster_snippet():
        _prepend_import_path()
        import folium
    
        plugins = _plugins_module()
        MarkerCluster = getattr(plugins, "MarkerCluster")
    
        m = folium.Map(location=[0, 0], zoom_start=2)
>       mc = MarkerCluster(name="mc").add_to(m)
E       AttributeError: 'MarkerCluster' object has no attribute 'add_to'

tests\Folium\functional_test.py:174: AttributeError
=========================== short test summary info ===========================
FAILED tests/Folium/functional_test.py::test_002_create_basic_map_renders_leaflet
FAILED tests/Folium/functional_test.py::test_003_map_has_html_root - Attribut...
FAILED tests/Folium/functional_test.py::test_004_add_marker_layer_changes_output
FAILED tests/Folium/functional_test.py::test_005_add_circle_marker_changes_output
FAILED tests/Folium/functional_test.py::test_006_add_tile_layer_and_layer_control
FAILED tests/Folium/functional_test.py::test_007_geojson_adds_feature_collection
FAILED tests/Folium/functional_test.py::test_008_geojson_style_function_serializes
FAILED tests/Folium/functional_test.py::test_009_map_save_writes_html - Attri...
FAILED tests/Folium/functional_test.py::test_011_markercluster_adds_cluster_snippet
9 failed, 3 passed in 0.72s

==========================================================================================
PROJECT: Glances
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Glances\pytest_logs\functional.log
==========================================================================================
............                                                             [100%]
12 passed in 1.63s

==========================================================================================
PROJECT: Humanize
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Humanize\pytest_logs\functional.log
==========================================================================================
..FF.FF..Fsssss                                                          [100%]
================================== FAILURES ===================================
______________________________ test_naturalsize _______________________________

    def test_naturalsize() -> None:
>       assert humanize.naturalsize(1024) == "1.0 kB"
E       AssertionError: assert '1.0 KB' == '1.0 kB'
E         
E         - 1.0 kB
E         ?     ^
E         + 1.0 KB
E         ?     ^

tests\Humanize\functional_test.py:107: AssertionError
__________________________ test_precisedelta_numeric __________________________

    def test_precisedelta_numeric() -> None:
        d = humanize.precisedelta(3661)  # seconds
>       assert "1 hour" in d
E       AssertionError: assert '1 hour' in '3661'

tests\Humanize\functional_test.py:113: AssertionError
______________________ test_naturaltime_reference_point _______________________

    def test_naturaltime_reference_point() -> None:
        ref = datetime(2020, 1, 1, 12, 0, 0)
        earlier = ref - timedelta(minutes=10)
>       s = humanize.naturaltime(earlier, when=ref)
E       TypeError: naturaltime() got an unexpected keyword argument 'when'

tests\Humanize\functional_test.py:129: TypeError
_____________________ test_intcomma_float_keeps_decimals ______________________

    def test_intcomma_float_keeps_decimals() -> None:
        s = humanize.intcomma(1234.56)
        assert isinstance(s, str)
>       assert s == "1,234.56"
E       AssertionError: assert '1,234' == '1,234.56'
E         
E         - 1,234.56
E         ?      ---
E         + 1,234

tests\Humanize\functional_test.py:140: AssertionError
___________________ test_naturaltime_future_reference_point ___________________

    def test_naturaltime_future_reference_point() -> None:
        ref = datetime(2020, 1, 1, 12, 0, 0)
        later = ref + timedelta(minutes=10)
>       s = humanize.naturaltime(later, when=ref)
E       TypeError: naturaltime() got an unexpected keyword argument 'when'

tests\Humanize\functional_test.py:165: TypeError
=========================== short test summary info ===========================
FAILED tests/Humanize/functional_test.py::test_naturalsize - AssertionError: ...
FAILED tests/Humanize/functional_test.py::test_precisedelta_numeric - Asserti...
FAILED tests/Humanize/functional_test.py::test_naturaltime_reference_point - ...
FAILED tests/Humanize/functional_test.py::test_intcomma_float_keeps_decimals
FAILED tests/Humanize/functional_test.py::test_naturaltime_future_reference_point
5 failed, 5 passed, 5 skipped in 0.57s

==========================================================================================
PROJECT: Imageio
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Imageio\pytest_logs\functional.log
==========================================================================================
.F.F..FFF.                                                               [100%]
================================== FAILURES ===================================
__________________ test_gif_multiframe_roundtrip_with_imiter __________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-337/test_gif_multiframe_roundtrip_0')

    def test_gif_multiframe_roundtrip_with_imiter(tmp_path: Path) -> None:
        """Write a small animated GIF and iterate frames using imiter."""
        frames = _make_grayscale_frames(num_frames=6, height=24, width=24)
        path = tmp_path / "anim.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       loaded_frames = list(iio.imiter(path))

tests\Imageio\functional_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Imageio\imageio\v3.py:618: in imiter
    arr = _read_gif(path)
generation\Imageio\imageio\v3.py:379: in _read_gif
    frame_indices = _decode_lzw(bytes(compressed_data), min_code_size, w*h)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b'\x00\xaf\x01(\'\xee\xdc9\x00\xe0\xb4q3\xe7\xad \x00m\xe2\xcai;\xa7\x8d\xd5\xb5\x8b\xd7\xcc\x91\x03\xb0\xa2\\ t\xda\x...7\xa2\xda\x12j\xeb\xb8B\xa6\xb8\x91\x12C\x9e\xb3\xb2b*:tg\xf1Z9\x87.\x10\x80@\xe2\xcc\xad\xf8\x08\xd3\x9b\xd0s\x01\x01'
min_code_size = 8, expected_size = 576

    def _decode_lzw(data, min_code_size, expected_size):
        # Minimal LZW decoder for GIF
        # data: bytes of compressed data
        # min_code_size: int
        # expected_size: number of pixels expected in output
        # Returns list of indices
    
        clear_code = 1 << min_code_size
        end_code = clear_code + 1
        code_size = min_code_size + 1
        max_code = (1 << code_size) - 1
    
        # Initialize dictionary
        dict_size = end_code + 1
        dictionary = {i: bytes([i]) for i in range(clear_code)}
        dictionary[clear_code] = None
        dictionary[end_code] = None
    
        bit_pos = 0
        bit_len = len(data) * 8
    
        def get_code():
            nonlocal bit_pos
            code = 0
            bits_read = 0
            while bits_read < code_size and bit_pos < bit_len:
                byte_pos = bit_pos // 8
                bit_offset = bit_pos % 8
                bits_left = 8 - bit_offset
                bits_to_read = min(bits_left, code_size - bits_read)
                mask = (1 << bits_to_read) - 1
                bits = (data[byte_pos] >> bit_offset) & mask
                code |= bits << bits_read
                bits_read += bits_to_read
                bit_pos += bits_to_read
            if bits_read < code_size:
                return None
            return code
    
        result = bytearray()
        prev_code = None
        while True:
            code = get_code()
            if code is None:
                break
            if code == clear_code:
                dictionary = {i: bytes([i]) for i in range(clear_code)}
                dictionary[clear_code] = None
                dictionary[end_code] = None
                dict_size = end_code + 1
                code_size = min_code_size + 1
                max_code = (1 << code_size) - 1
                prev_code = None
                continue
            if code == end_code:
                break
            if code in dictionary:
                entry = dictionary[code]
                if prev_code is not None:
                    dictionary[dict_size] = dictionary[prev_code] + entry[:1]
                    dict_size += 1
            elif code == dict_size:
                entry = dictionary[prev_code] + dictionary[prev_code][:1]
                dictionary[dict_size] = entry
                dict_size += 1
            else:
>               raise ValueError("Invalid LZW code")
E               ValueError: Invalid LZW code

generation\Imageio\imageio\v3.py:486: ValueError
_____________________ test_png_roundtrip_via_bytes_buffer _____________________

    def test_png_roundtrip_via_bytes_buffer() -> None:
        """Write PNG to in-memory bytes, then read back using extension."""
        img = _make_color_image(height=20, width=31)
    
>       blob = iio.imwrite("<bytes>", img, extension=".png")
E       TypeError: imwrite() got an unexpected keyword argument 'extension'

tests\Imageio\functional_test.py:139: TypeError
___________ test_gif_imread_returns_stack_with_expected_frame_count ___________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-337/test_gif_imread_returns_stack_0')

    def test_gif_imread_returns_stack_with_expected_frame_count(tmp_path: Path) -> None:
        """Reading a GIF via imread should produce a stack/sequence with the right number of frames."""
        frames = _make_grayscale_frames(num_frames=5, height=20, width=21)
        path = tmp_path / "stack.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       loaded = iio.imread(path)

tests\Imageio\functional_test.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Imageio\imageio\v3.py:602: in imread
    arr = _read_gif(path)
generation\Imageio\imageio\v3.py:379: in _read_gif
    frame_indices = _decode_lzw(bytes(compressed_data), min_code_size, w*h)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data = b"\x00\xaf\x01('\xee\xdc9\x00\xe0\xb4q3\xe7\xad \x00m\xe2\xcai;\xa7\x8d\xd5\xb5\x8b\xd7\xcc\x91\x03\xb0\xa2\\ t\xda\x0...x1c\x00\x00V\xac\\[\xa1P\xdb5\x00\xe6\xac\x00\xf0V\xce\x9c\xb8\x15\xdc\xc0q\xbbVN\x1b+\x95\xe8\xca%\\9\xd0\n9t\x01\x01"
min_code_size = 8, expected_size = 420

    def _decode_lzw(data, min_code_size, expected_size):
        # Minimal LZW decoder for GIF
        # data: bytes of compressed data
        # min_code_size: int
        # expected_size: number of pixels expected in output
        # Returns list of indices
    
        clear_code = 1 << min_code_size
        end_code = clear_code + 1
        code_size = min_code_size + 1
        max_code = (1 << code_size) - 1
    
        # Initialize dictionary
        dict_size = end_code + 1
        dictionary = {i: bytes([i]) for i in range(clear_code)}
        dictionary[clear_code] = None
        dictionary[end_code] = None
    
        bit_pos = 0
        bit_len = len(data) * 8
    
        def get_code():
            nonlocal bit_pos
            code = 0
            bits_read = 0
            while bits_read < code_size and bit_pos < bit_len:
                byte_pos = bit_pos // 8
                bit_offset = bit_pos % 8
                bits_left = 8 - bit_offset
                bits_to_read = min(bits_left, code_size - bits_read)
                mask = (1 << bits_to_read) - 1
                bits = (data[byte_pos] >> bit_offset) & mask
                code |= bits << bits_read
                bits_read += bits_to_read
                bit_pos += bits_to_read
            if bits_read < code_size:
                return None
            return code
    
        result = bytearray()
        prev_code = None
        while True:
            code = get_code()
            if code is None:
                break
            if code == clear_code:
                dictionary = {i: bytes([i]) for i in range(clear_code)}
                dictionary[clear_code] = None
                dictionary[end_code] = None
                dict_size = end_code + 1
                code_size = min_code_size + 1
                max_code = (1 << code_size) - 1
                prev_code = None
                continue
            if code == end_code:
                break
            if code in dictionary:
                entry = dictionary[code]
                if prev_code is not None:
                    dictionary[dict_size] = dictionary[prev_code] + entry[:1]
                    dict_size += 1
            elif code == dict_size:
                entry = dictionary[prev_code] + dictionary[prev_code][:1]
                dictionary[dict_size] = entry
                dict_size += 1
            else:
>               raise ValueError("Invalid LZW code")
E               ValueError: Invalid LZW code

generation\Imageio\imageio\v3.py:486: ValueError
___________ test_gif_imread_index0_matches_first_imiter_frame_shape ___________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-337/test_gif_imread_index0_matches0')

    def test_gif_imread_index0_matches_first_imiter_frame_shape(tmp_path: Path) -> None:
        """Read first GIF frame using both index=0 and imiter; verify consistent spatial shape."""
        frames = _make_grayscale_frames(num_frames=4, height=19, width=23)
        path = tmp_path / "index0.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       first_by_index = iio.imread(path, index=0)
E       TypeError: imread() got an unexpected keyword argument 'index'

tests\Imageio\functional_test.py:206: TypeError
_______________________ test_imopen_write_then_read_png _______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-337/test_imopen_write_then_read_pn0')

    def test_imopen_write_then_read_png(tmp_path: Path) -> None:
        """Use the v3 imopen context manager to write then read a PNG."""
        img = _make_color_image(height=16, width=20)
        path = tmp_path / "imopen.png"
    
>       with iio.imopen(path, "w") as f:
E       AttributeError: module 'imageio.v3' has no attribute 'imopen'

tests\Imageio\functional_test.py:221: AttributeError
=========================== short test summary info ===========================
FAILED tests/Imageio/functional_test.py::test_gif_multiframe_roundtrip_with_imiter
FAILED tests/Imageio/functional_test.py::test_png_roundtrip_via_bytes_buffer
FAILED tests/Imageio/functional_test.py::test_gif_imread_returns_stack_with_expected_frame_count
FAILED tests/Imageio/functional_test.py::test_gif_imread_index0_matches_first_imiter_frame_shape
FAILED tests/Imageio/functional_test.py::test_imopen_write_then_read_png - At...
5 failed, 5 passed in 1.22s

==========================================================================================
PROJECT: Lifelines
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Lifelines\pytest_logs\functional.log
==========================================================================================
FFFFFFFFF.FFFF.                                                          [100%]
================================== FAILURES ===================================
______________________ test_kmf_on_small_manual_dataset _______________________

    def test_kmf_on_small_manual_dataset() -> None:
        """Basic sanity check for KaplanMeierFitter on a tiny dataset."""
        durations, events = _toy_kmf_data()
    
        kmf = KaplanMeierFitter()
>       kmf.fit(durations=durations, event_observed=events, label="test")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:84: TypeError
_________________________ test_kmf_on_waltons_groups __________________________

    def test_kmf_on_waltons_groups() -> None:
        """Fit KMF on the Waltons dataset for two groups."""
        df = load_waltons()
        assert {"T", "E", "group"}.issubset(df.columns)
    
        control = df[df["group"] == "control"]
        treated = df[df["group"] != "control"]
    
        kmf_control = KaplanMeierFitter()
        kmf_treated = KaplanMeierFitter()
    
>       kmf_control.fit(control["T"], control["E"], label="control")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:105: TypeError
____________________________ test_coxph_basic_fit _____________________________

    def test_coxph_basic_fit() -> None:
        """Fit a simple Cox proportional hazards model on a toy dataset."""
        df = _toy_cox_df()
    
        cph = CoxPHFitter()
        cph.fit(df, duration_col="duration", event_col="event")
        summary = cph.summary
    
        assert "coef" in summary.columns
        assert "se(coef)" in summary.columns
>       assert "p" in summary.columns or "p" in "".join(summary.columns).lower()
E       AssertionError: assert ('p' in Index(['coef', 'se(coef)'], dtype='object') or 'p' in 'coefse(coef)')
E        +  where Index(['coef', 'se(coef)'], dtype='object') =                coef  se(coef)\nage       -0.042724       NaN\ntreatment  0.593058       NaN.columns
E        +  and   'coefse(coef)' = <built-in method lower of str object at 0x000001DF7FEFA730>()
E        +    where <built-in method lower of str object at 0x000001DF7FEFA730> = 'coefse(coef)'.lower
E        +      where 'coefse(coef)' = <built-in method join of str object at 0x000001DF5D254670>(Index(['coef', 'se(coef)'], dtype='object'))
E        +        where <built-in method join of str object at 0x000001DF5D254670> = ''.join
E        +        and   Index(['coef', 'se(coef)'], dtype='object') =                coef  se(coef)\nage       -0.042724       NaN\ntreatment  0.593058       NaN.columns

tests\Lifelines\functional_test.py:127: AssertionError
____________________ test_kmf_predict_at_time_zero_is_one _____________________

    def test_kmf_predict_at_time_zero_is_one() -> None:
        """KMF predict at t=0 should be 1.0 for standard KM survival."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:140: TypeError
________________ test_kmf_predict_is_non_increasing_over_time _________________

    def test_kmf_predict_is_non_increasing_over_time() -> None:
        """KMF predicted survival should not increase as time increases."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:148: TypeError
________________ test_kmf_cumulative_density_is_non_decreasing ________________

    def test_kmf_cumulative_density_is_non_decreasing() -> None:
        """Cumulative density should be non-decreasing and within [0, 1]."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:169: TypeError
__________________ test_kmf_event_table_has_standard_columns __________________

    def test_kmf_event_table_has_standard_columns() -> None:
        """KM event table should include standard bookkeeping columns."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:182: TypeError
_____________ test_kmf_confidence_interval_matches_survival_index _____________

    def test_kmf_confidence_interval_matches_survival_index() -> None:
        """Confidence intervals should align with survival function index."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:191: TypeError
___________ test_kmf_median_survival_time_is_within_duration_range ____________

    def test_kmf_median_survival_time_is_within_duration_range() -> None:
        """Median survival time should be within the observed duration range."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:204: TypeError
___________ test_coxph_baseline_cumulative_hazard_is_non_decreasing ___________

    def test_coxph_baseline_cumulative_hazard_is_non_decreasing() -> None:
        """Baseline cumulative hazard should be non-decreasing over time."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
>       bch = cph.baseline_cumulative_hazard_
E       AttributeError: 'CoxPHFitter' object has no attribute 'baseline_cumulative_hazard_'

tests\Lifelines\functional_test.py:225: AttributeError
__________ test_coxph_predict_partial_hazard_is_positive_and_varies ___________

    def test_coxph_predict_partial_hazard_is_positive_and_varies() -> None:
        """Partial hazards should be positive and reflect covariate differences."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
        x_low = pd.DataFrame({"age": [25], "treatment": [0]})
        x_high = pd.DataFrame({"age": [55], "treatment": [1]})
    
>       h_low = float(cph.predict_partial_hazard(x_low).iloc[0])
E       AttributeError: 'CoxPHFitter' object has no attribute 'predict_partial_hazard'

tests\Lifelines\functional_test.py:240: AttributeError
____________ test_coxph_predict_survival_function_shape_and_bounds ____________

    def test_coxph_predict_survival_function_shape_and_bounds() -> None:
        """Predict survival functions for two individuals; verify shape and bounds."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
        x = pd.DataFrame({"age": [30, 60], "treatment": [0, 1]})
>       sf = cph.predict_survival_function(x)

tests\Lifelines\functional_test.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <lifelines.fitters.CoxPHFitter object at 0x000001DF603E0A90>
row =    age  treatment
0   30          0
1   60          1

    def predict_survival_function(self, row):
        if not self._fitted:
            raise ValueError("Model must be fitted before prediction")
    
        if not isinstance(row, pd.DataFrame):
            raise ValueError("Input must be a single-row DataFrame")
    
        if row.shape[0] != 1:
>           raise ValueError("Input DataFrame must have exactly one row")
E           ValueError: Input DataFrame must have exactly one row

generation\Lifelines\lifelines\fitters.py:208: ValueError
________________ test_coxph_concordance_index_in_unit_interval ________________

    def test_coxph_concordance_index_in_unit_interval() -> None:
        """Concordance index should lie in [0, 1] after fitting."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
>       c = float(cph.concordance_index_)
E       AttributeError: 'CoxPHFitter' object has no attribute 'concordance_index_'

tests\Lifelines\functional_test.py:269: AttributeError
============================== warnings summary ===============================
tests/Lifelines/functional_test.py::test_coxph_basic_fit
tests/Lifelines/functional_test.py::test_coxph_params_index_matches_covariates
tests/Lifelines/functional_test.py::test_coxph_baseline_cumulative_hazard_is_non_decreasing
tests/Lifelines/functional_test.py::test_coxph_predict_partial_hazard_is_positive_and_varies
tests/Lifelines/functional_test.py::test_coxph_predict_survival_function_shape_and_bounds
tests/Lifelines/functional_test.py::test_coxph_concordance_index_in_unit_interval
tests/Lifelines/functional_test.py::test_coxph_fit_on_waltons_with_binary_group_feature
  D:\桌面\RealAppCodeBench_generic_eval\generation\Lifelines\lifelines\fitters.py:169: RuntimeWarning: invalid value encountered in sqrt
    se = np.sqrt(np.diag(cov_matrix))

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/Lifelines/functional_test.py::test_kmf_on_small_manual_dataset
FAILED tests/Lifelines/functional_test.py::test_kmf_on_waltons_groups - TypeE...
FAILED tests/Lifelines/functional_test.py::test_coxph_basic_fit - AssertionEr...
FAILED tests/Lifelines/functional_test.py::test_kmf_predict_at_time_zero_is_one
FAILED tests/Lifelines/functional_test.py::test_kmf_predict_is_non_increasing_over_time
FAILED tests/Lifelines/functional_test.py::test_kmf_cumulative_density_is_non_decreasing
FAILED tests/Lifelines/functional_test.py::test_kmf_event_table_has_standard_columns
FAILED tests/Lifelines/functional_test.py::test_kmf_confidence_interval_matches_survival_index
FAILED tests/Lifelines/functional_test.py::test_kmf_median_survival_time_is_within_duration_range
FAILED tests/Lifelines/functional_test.py::test_coxph_baseline_cumulative_hazard_is_non_decreasing
FAILED tests/Lifelines/functional_test.py::test_coxph_predict_partial_hazard_is_positive_and_varies
FAILED tests/Lifelines/functional_test.py::test_coxph_predict_survival_function_shape_and_bounds
FAILED tests/Lifelines/functional_test.py::test_coxph_concordance_index_in_unit_interval
13 failed, 2 passed, 7 warnings in 11.35s

==========================================================================================
PROJECT: Loguru
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Loguru\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFF                                                              [100%]
================================== FAILURES ===================================
______________________ test_basic_levels_and_formatting _______________________

    def test_basic_levels_and_formatting() -> None:
>       log, buf = make_buffer_logger(fmt="{level}:{message}", level="DEBUG")

tests\Loguru\functional_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

fmt = '{level}:{message}', level = 'DEBUG'

    def make_buffer_logger(
        fmt: str = "{level}:{message}",
        level: str = "DEBUG",
        *,
        colorize: bool = False,
        serialize: bool = False,
        filter_: Callable[..., bool] = None,
    ) -> Tuple["logger.__class__", io.StringIO]:
        """Create a logger configured with a single StringIO sink (happy-path)."""
        buf = io.StringIO()
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:81: TypeError
____________________________ test_level_filtering _____________________________

    def test_level_filtering() -> None:
>       log, buf = make_buffer_logger(fmt="{level}:{message}", level="INFO")

tests\Loguru\functional_test.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

fmt = '{level}:{message}', level = 'INFO'

    def make_buffer_logger(
        fmt: str = "{level}:{message}",
        level: str = "DEBUG",
        *,
        colorize: bool = False,
        serialize: bool = False,
        filter_: Callable[..., bool] = None,
    ) -> Tuple["logger.__class__", io.StringIO]:
        """Create a logger configured with a single StringIO sink (happy-path)."""
        buf = io.StringIO()
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:81: TypeError
_______________________ test_log_method_with_level_name _______________________

    def test_log_method_with_level_name() -> None:
>       log, buf = make_buffer_logger(fmt="{level}:{message}", level="DEBUG")

tests\Loguru\functional_test.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

fmt = '{level}:{message}', level = 'DEBUG'

    def make_buffer_logger(
        fmt: str = "{level}:{message}",
        level: str = "DEBUG",
        *,
        colorize: bool = False,
        serialize: bool = False,
        filter_: Callable[..., bool] = None,
    ) -> Tuple["logger.__class__", io.StringIO]:
        """Create a logger configured with a single StringIO sink (happy-path)."""
        buf = io.StringIO()
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:81: TypeError
_______________________ test_bind_extra_renders_fields ________________________

    def test_bind_extra_renders_fields() -> None:
>       log, buf = make_buffer_logger(fmt="{level}:{message} user={extra[user]} req={extra[request_id]}")

tests\Loguru\functional_test.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

fmt = '{level}:{message} user={extra[user]} req={extra[request_id]}'
level = 'DEBUG'

    def make_buffer_logger(
        fmt: str = "{level}:{message}",
        level: str = "DEBUG",
        *,
        colorize: bool = False,
        serialize: bool = False,
        filter_: Callable[..., bool] = None,
    ) -> Tuple["logger.__class__", io.StringIO]:
        """Create a logger configured with a single StringIO sink (happy-path)."""
        buf = io.StringIO()
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:81: TypeError
____________________ test_contextualize_adds_extra_fields _____________________

    def test_contextualize_adds_extra_fields() -> None:
>       log, buf = make_buffer_logger(fmt="{message} user={extra[user]}")

tests\Loguru\functional_test.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

fmt = '{message} user={extra[user]}', level = 'DEBUG'

    def make_buffer_logger(
        fmt: str = "{level}:{message}",
        level: str = "DEBUG",
        *,
        colorize: bool = False,
        serialize: bool = False,
        filter_: Callable[..., bool] = None,
    ) -> Tuple["logger.__class__", io.StringIO]:
        """Create a logger configured with a single StringIO sink (happy-path)."""
        buf = io.StringIO()
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:81: TypeError
__________________ test_multiple_sinks_receive_same_message ___________________

    def test_multiple_sinks_receive_same_message() -> None:
        buf1 = io.StringIO()
        buf2 = io.StringIO()
    
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:161: TypeError
_______________________ test_add_file_sink_writes_lines _______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-338/test_add_file_sink_writes_line0')

    def test_add_file_sink_writes_lines(tmp_path: Path) -> None:
        log_path = tmp_path / "loguru_test.log"
    
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:178: TypeError
______________ test_serialize_output_contains_message_and_level _______________

    def test_serialize_output_contains_message_and_level() -> None:
        # serialize=True should emit JSON per record into the sink
>       log, buf = make_buffer_logger(level="INFO", serialize=True)

tests\Loguru\functional_test.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

fmt = '{level}:{message}', level = 'INFO'

    def make_buffer_logger(
        fmt: str = "{level}:{message}",
        level: str = "DEBUG",
        *,
        colorize: bool = False,
        serialize: bool = False,
        filter_: Callable[..., bool] = None,
    ) -> Tuple["logger.__class__", io.StringIO]:
        """Create a logger configured with a single StringIO sink (happy-path)."""
        buf = io.StringIO()
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:81: TypeError
_____________________ test_patch_can_enrich_record_extra ______________________

    def test_patch_can_enrich_record_extra() -> None:
        # patch() lets us enrich record data in a typical usage pattern
>       log, buf = make_buffer_logger(fmt="{message} patched={extra[patched]}")

tests\Loguru\functional_test.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

fmt = '{message} patched={extra[patched]}', level = 'DEBUG'

    def make_buffer_logger(
        fmt: str = "{level}:{message}",
        level: str = "DEBUG",
        *,
        colorize: bool = False,
        serialize: bool = False,
        filter_: Callable[..., bool] = None,
    ) -> Tuple["logger.__class__", io.StringIO]:
        """Create a logger configured with a single StringIO sink (happy-path)."""
        buf = io.StringIO()
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:81: TypeError
________________ test_filter_callable_allows_subset_of_records ________________

    def test_filter_callable_allows_subset_of_records() -> None:
        def only_info(record) -> bool:
            return record["level"].name == "INFO"
    
>       log, buf = make_buffer_logger(fmt="{level}:{message}", level="DEBUG", filter_=only_info)

tests\Loguru\functional_test.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

fmt = '{level}:{message}', level = 'DEBUG'

    def make_buffer_logger(
        fmt: str = "{level}:{message}",
        level: str = "DEBUG",
        *,
        colorize: bool = False,
        serialize: bool = False,
        filter_: Callable[..., bool] = None,
    ) -> Tuple["logger.__class__", io.StringIO]:
        """Create a logger configured with a single StringIO sink (happy-path)."""
        buf = io.StringIO()
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:81: TypeError
____________________ test_time_and_level_in_default_format ____________________

    def test_time_and_level_in_default_format() -> None:
        # Default format should include some timestamp-like content, level, and message.
        buf = io.StringIO()
>       logger.remove()
E       TypeError: remove() missing 1 required positional argument: 'handler_id'

tests\Loguru\functional_test.py:237: TypeError
=========================== short test summary info ===========================
FAILED tests/Loguru/functional_test.py::test_basic_levels_and_formatting - Ty...
FAILED tests/Loguru/functional_test.py::test_level_filtering - TypeError: rem...
FAILED tests/Loguru/functional_test.py::test_log_method_with_level_name - Typ...
FAILED tests/Loguru/functional_test.py::test_bind_extra_renders_fields - Type...
FAILED tests/Loguru/functional_test.py::test_contextualize_adds_extra_fields
FAILED tests/Loguru/functional_test.py::test_multiple_sinks_receive_same_message
FAILED tests/Loguru/functional_test.py::test_add_file_sink_writes_lines - Typ...
FAILED tests/Loguru/functional_test.py::test_serialize_output_contains_message_and_level
FAILED tests/Loguru/functional_test.py::test_patch_can_enrich_record_extra - ...
FAILED tests/Loguru/functional_test.py::test_filter_callable_allows_subset_of_records
FAILED tests/Loguru/functional_test.py::test_time_and_level_in_default_format
11 failed in 0.75s

==========================================================================================
PROJECT: Mailpile
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Mailpile\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
_____________ ERROR collecting tests/Mailpile/functional_test.py ______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\Mailpile\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\Mailpile\functional_test.py:176: in <module>
    from mailpile.safe_popen import PIPE, Popen, Safe_Pipe  # type: ignore
E   ImportError: cannot import name 'PIPE' from 'mailpile.safe_popen' (D:\桌面\RealAppCodeBench_generic_eval\.converted\Mailpile\generated\mailpile\safe_popen.py)
=========================== short test summary info ===========================
ERROR tests/Mailpile/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 1.61s

==========================================================================================
PROJECT: Markdown
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Markdown\pytest_logs\functional.log
==========================================================================================
......F.FFsssssssss                                                      [100%]
================================== FAILURES ===================================
_________________ test_html_escaping_in_text_but_not_in_code __________________

    def test_html_escaping_in_text_but_not_in_code() -> None:
        src = textwrap.dedent(
            """
            Use <b>raw HTML</b> here.
    
            ```
            literal <b> tag in code block
            ```
            """
        )
        html = markdown.markdown(src)
        norm = normalize_html(html)
    
>       assert "<b>" in norm
E       AssertionError: assert '<b>' in '<p>Use &lt;b&gt;raw HTML&lt;/b&gt; here.</p>\n<pre><code>literal &lt;b&gt; tag in code block\n</code></pre>'

tests\Markdown\functional_test.py:209: AssertionError
___________________________ test_markdown_from_file ___________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-339/test_markdown_from_file0')

    def test_markdown_from_file(tmp_path: Path) -> None:
        src = textwrap.dedent(
            """
            # Title from file
    
            Some text from file.
            """
        )
        md_path = tmp_path / "input.md"
        md_path.write_text(src, encoding="utf-8")
    
        out_path = tmp_path / "output.html"
        markdown.markdownFromFile(input=str(md_path), output=str(out_path))
>       html = out_path.read_text(encoding="utf-8")

tests\Markdown\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\pathlib.py:1255: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\pathlib.py:1241: in open
    return io.open(self, mode, buffering, encoding, errors, newline,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-339/test_markdown_from_file0/output.html')
name = 'C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-339\\test_markdown_from_file0\\output.html'
flags = 32896, mode = 438

    def _opener(self, name, flags, mode=0o666):
        # A stub for the opener argument to built-in open()
>       return self._accessor.open(self, flags, mode)
E       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-339\\test_markdown_from_file0\\output.html'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\pathlib.py:1109: FileNotFoundError
_______________________ test_horizontal_rule_renders_hr _______________________

    def test_horizontal_rule_renders_hr() -> None:
        src = textwrap.dedent(
            """
            Paragraph above
    
            ---
    
            Paragraph below
            """
        )
        html = markdown.markdown(src)
        norm = normalize_html(html)
    
>       assert "<hr" in norm
E       AssertionError: assert '<hr' in '<p>Paragraph above</p>\n<p>---</p>\n<p>Paragraph below</p>'

tests\Markdown\functional_test.py:272: AssertionError
=========================== short test summary info ===========================
FAILED tests/Markdown/functional_test.py::test_html_escaping_in_text_but_not_in_code
FAILED tests/Markdown/functional_test.py::test_markdown_from_file - FileNotFo...
FAILED tests/Markdown/functional_test.py::test_horizontal_rule_renders_hr - A...
3 failed, 7 passed, 9 skipped in 0.67s

==========================================================================================
PROJECT: Mitmproxy
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Mitmproxy\pytest_logs\functional.log
==========================================================================================
..FF.FF.FFF                                                              [100%]
================================== FAILURES ===================================
_______ test_003_version_source_file_exists_and_has_version_like_token ________

    def test_003_version_source_file_exists_and_has_version_like_token():
        """
        Do NOT assume mitmproxy exposes __version__ at top-level.
        Instead, require a stable version source file under the package and a version-like token inside.
    
        This aligns better with how many projects store version information (e.g. version.py, __init__.py, or pyproject).
        """
        pkg = _mitmproxy_pkg_dir()
    
        candidates = [
            pkg / "version.py",
            pkg / "__init__.py",
        ]
    
        existing = [p for p in candidates if p.is_file()]
>       assert existing, f"Expected one of these to exist: {[str(p) for p in candidates]}"
E       AssertionError: Expected one of these to exist: ['D:\\桌面\\RealAppCodeBench_generic_eval\\generation\\Mitmproxy\\mitmproxy\\version.py', 'D:\\桌面\\RealAppCodeBench_generic_eval\\generation\\Mitmproxy\\mitmproxy\\__init__.py']
E       assert []

tests\Mitmproxy\functional_test.py:95: AssertionError
_______________________ test_004_tools_main_file_exists _______________________

    def test_004_tools_main_file_exists():
        pkg = _mitmproxy_pkg_dir()
>       assert (pkg / "tools" / "main.py").is_file()
E       AssertionError: assert False
E        +  where False = is_file()
E        +    where is_file = ((WindowsPath('D:/桌面/RealAppCodeBench_generic_eval/generation/Mitmproxy/mitmproxy') / 'tools') / 'main.py').is_file

tests\Mitmproxy\functional_test.py:112: AssertionError
_____________________ test_006_tools_cmdline_file_exists ______________________

    def test_006_tools_cmdline_file_exists():
        pkg = _mitmproxy_pkg_dir()
>       assert (pkg / "tools" / "cmdline.py").is_file()
E       AssertionError: assert False
E        +  where False = is_file()
E        +    where is_file = ((WindowsPath('D:/桌面/RealAppCodeBench_generic_eval/generation/Mitmproxy/mitmproxy') / 'tools') / 'cmdline.py').is_file

tests\Mitmproxy\functional_test.py:122: AssertionError
__________ test_007_tools_main_defines_mitmdump_function_or_wrapper ___________

    def test_007_tools_main_defines_mitmdump_function_or_wrapper():
        """
        Anchor: mitmproxy.tools.main.mitmdump should exist.
        If runtime import is blocked by missing mitmproxy_rs, we still enforce the symbol statically.
        """
        pkg = _mitmproxy_pkg_dir()
        main_py = pkg / "tools" / "main.py"
>       src = _file(main_py)

tests\Mitmproxy\functional_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Mitmproxy\functional_test.py:44: in _file
    return path.read_text(encoding="utf-8", errors="replace")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\pathlib.py:1255: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\pathlib.py:1241: in open
    return io.open(self, mode, buffering, encoding, errors, newline,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = WindowsPath('D:/桌面/RealAppCodeBench_generic_eval/generation/Mitmproxy/mitmproxy/tools/main.py')
name = 'D:\\桌面\\RealAppCodeBench_generic_eval\\generation\\Mitmproxy\\mitmproxy\\tools\\main.py'
flags = 32896, mode = 438

    def _opener(self, name, flags, mode=0o666):
        # A stub for the opener argument to built-in open()
>       return self._accessor.open(self, flags, mode)
E       FileNotFoundError: [Errno 2] No such file or directory: 'D:\\桌面\\RealAppCodeBench_generic_eval\\generation\\Mitmproxy\\mitmproxy\\tools\\main.py'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\pathlib.py:1109: FileNotFoundError
________________ test_009_proxy_mode_specs_mentions_ProxyMode _________________

    def test_009_proxy_mode_specs_mentions_ProxyMode():
        """
        Anchor: mitmproxy.proxy.mode_specs is part of the CLI import chain.
        Runtime import may require mitmproxy_rs; we assert the file contains ProxyMode constructs.
        """
        pkg = _mitmproxy_pkg_dir()
        ms_py = pkg / "proxy" / "mode_specs.py"
>       assert ms_py.is_file()
E       AssertionError: assert False
E        +  where False = is_file()
E        +    where is_file = WindowsPath('D:/桌面/RealAppCodeBench_generic_eval/generation/Mitmproxy/mitmproxy/proxy/mode_specs.py').is_file

tests\Mitmproxy\functional_test.py:156: AssertionError
_________ test_010_conditional_import_http_module_depends_on_OpenSSL __________

    def test_010_conditional_import_http_module_depends_on_OpenSSL():
        """
        Importing mitmproxy.http may require pyOpenSSL (OpenSSL module) through mitmproxy.certs.
        If OpenSSL is installed, import must succeed.
        If not installed, import must fail with ModuleNotFoundError mentioning OpenSSL.
        """
        _prepend_import_path()
        have_openssl = _has_module("OpenSSL")
        if have_openssl:
            import mitmproxy.http  # noqa: F401
        else:
            with pytest.raises(ModuleNotFoundError) as ei:
>               import mitmproxy.http  # noqa: F401
E               Failed: DID NOT RAISE <class 'ModuleNotFoundError'>

tests\Mitmproxy\functional_test.py:173: Failed
_______ test_011_conditional_import_tools_main_depends_on_mitmproxy_rs ________

    def test_011_conditional_import_tools_main_depends_on_mitmproxy_rs():
        """
        Importing mitmproxy.tools.main currently pulls in mitmproxy.proxy.mode_specs,
        which imports mitmproxy_rs. If mitmproxy_rs is installed, import should succeed.
        Otherwise, it should fail with ModuleNotFoundError mentioning mitmproxy_rs.
        """
        _prepend_import_path()
        have_rs = _has_module("mitmproxy_rs")
        if have_rs:
            from mitmproxy.tools import main as tools_main  # noqa: F401
            assert hasattr(tools_main, "mitmdump")
        else:
            with pytest.raises(ModuleNotFoundError) as ei:
>               from mitmproxy.tools import main as tools_main  # noqa: F401
E               Failed: DID NOT RAISE <class 'ModuleNotFoundError'>

tests\Mitmproxy\functional_test.py:190: Failed
=========================== short test summary info ===========================
FAILED tests/Mitmproxy/functional_test.py::test_003_version_source_file_exists_and_has_version_like_token
FAILED tests/Mitmproxy/functional_test.py::test_004_tools_main_file_exists - ...
FAILED tests/Mitmproxy/functional_test.py::test_006_tools_cmdline_file_exists
FAILED tests/Mitmproxy/functional_test.py::test_007_tools_main_defines_mitmdump_function_or_wrapper
FAILED tests/Mitmproxy/functional_test.py::test_009_proxy_mode_specs_mentions_ProxyMode
FAILED tests/Mitmproxy/functional_test.py::test_010_conditional_import_http_module_depends_on_OpenSSL
FAILED tests/Mitmproxy/functional_test.py::test_011_conditional_import_tools_main_depends_on_mitmproxy_rs
7 failed, 4 passed in 0.72s

==========================================================================================
PROJECT: Mutagen
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Mutagen\pytest_logs\functional.log
==========================================================================================

1 skipped in 0.15s

==========================================================================================
PROJECT: Pendulum
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Pendulum\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFsFFF                                                            [100%]
================================== FAILURES ===================================
_____________________ test_parse_and_timezone_conversion ______________________

    def test_parse_and_timezone_conversion() -> None:
        """Parse an ISO string and convert between timezones."""
        dt_utc = pendulum.parse("2020-01-01T12:00:00+00:00")
    
>       assert dt_utc.year == 2020
E       AttributeError: 'DateTime' object has no attribute 'year'

tests\Pendulum\functional_test.py:68: AttributeError
____________________ test_datetime_arithmetic_and_duration ____________________

    def test_datetime_arithmetic_and_duration() -> None:
        """Basic arithmetic with pendulum.datetime and pendulum.duration."""
>       base = pendulum.datetime(2021, 3, 15, 10, 30, 0, tz="UTC")

tests\Pendulum\functional_test.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4ab81490>
year = 2021, month = 3, day = 15, hour = 10, minute = 30, second = 0
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
_________________________ test_diff_for_humans_months _________________________

    def test_diff_for_humans_months() -> None:
        """Human-readable differences between two datetimes."""
>       start = pendulum.datetime(2011, 8, 1, tz="UTC")

tests\Pendulum\functional_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4abd5b20>
year = 2011, month = 8, day = 1, hour = 0, minute = 0, second = 0
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
_____________________ test_parse_date_only_to_date_string _____________________

    def test_parse_date_only_to_date_string() -> None:
        """Parse a date-only string and verify normalized date output."""
        d = pendulum.parse("2020-02-29")
>       assert d.year == 2020
E       AttributeError: 'DateTime' object has no attribute 'year'

tests\Pendulum\functional_test.py:118: AttributeError
__________________ test_datetime_to_iso8601_string_roundtrip __________________

    def test_datetime_to_iso8601_string_roundtrip() -> None:
        """Create a datetime and verify ISO8601 string contains expected offset."""
>       dt = pendulum.datetime(2020, 1, 1, 12, 0, 0, tz="UTC")

tests\Pendulum\functional_test.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4abf5ac0>
year = 2020, month = 1, day = 1, hour = 12, minute = 0, second = 0
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
_____________________ test_formatting_with_custom_pattern _____________________

    def test_formatting_with_custom_pattern() -> None:
        """Verify formatting with a custom pattern is stable for a fixed datetime."""
>       dt = pendulum.datetime(2021, 12, 31, 23, 59, 58, tz="UTC")

tests\Pendulum\functional_test.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4ab727f0>
year = 2021, month = 12, day = 31, hour = 23, minute = 59, second = 58
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
__________________________ test_start_of_end_of_day ___________________________

    def test_start_of_end_of_day() -> None:
        """Check start_of and end_of for a day boundary."""
>       dt = pendulum.datetime(2020, 5, 20, 13, 14, 15, tz="UTC")

tests\Pendulum\functional_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4ab742e0>
year = 2020, month = 5, day = 20, hour = 13, minute = 14, second = 15
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
_____________________ test_weekday_and_isoweekday_values ______________________

    def test_weekday_and_isoweekday_values() -> None:
        """Validate weekday values for a known date (2020-01-01 is Wednesday)."""
>       dt = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:155: AttributeError
_________________ test_duration_total_seconds_and_components __________________

    def test_duration_total_seconds_and_components() -> None:
        """Verify duration reports correct total seconds and has component attributes."""
        dur = pendulum.duration(days=1, hours=2, minutes=3, seconds=4)
    
        # Total seconds is the most stable cross-version contract.
        assert dur.total_seconds() == 1 * 86400 + 2 * 3600 + 3 * 60 + 4
    
        # Component attributes commonly exist; assert them when present.
>       assert dur.days == 1
E       AttributeError: 'Duration' object has no attribute 'days'

tests\Pendulum\functional_test.py:168: AttributeError
_____________________ test_in_timezone_preserves_instant ______________________

    def test_in_timezone_preserves_instant() -> None:
        """Converting timezones should preserve the instant (timestamp)."""
>       dt_utc = pendulum.datetime(2020, 6, 1, 0, 0, 0, tz="UTC")

tests\Pendulum\functional_test.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:168: in datetime
    return DateTime.datetime(year, month, day, hour, minute, second, microsecond, tz)
generation\Pendulum\pendulum\datetime.py:61: in datetime
    return cls(year, month, day, hour, minute, second, microsecond, tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <[AttributeError('_dt') raised in repr()] DateTime object at 0x19d4abe7550>
year = 2020, month = 6, day = 1, hour = 0, minute = 0, second = 0
microsecond = 0, tz = 'UTC'

    def __init__(self, year, month=1, day=1, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is None:
            tz = timezone("UTC")
        elif not isinstance(tz, Timezone):
>           raise TypeError("tz must be a pendulum.timezone.Timezone instance or None")
E           TypeError: tz must be a pendulum.timezone.Timezone instance or None

generation\Pendulum\pendulum\datetime.py:15: TypeError
________________________ test_diff_in_days_is_integer _________________________

    def test_diff_in_days_is_integer() -> None:
        """Compute diff in days between two dates."""
>       a = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:207: AttributeError
____________________ test_add_months_across_year_boundary _____________________

    def test_add_months_across_year_boundary() -> None:
        """Add months and verify year boundary transitions."""
>       dt = pendulum.date(2019, 12, 15)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:217: AttributeError
=========================== short test summary info ===========================
FAILED tests/Pendulum/functional_test.py::test_parse_and_timezone_conversion
FAILED tests/Pendulum/functional_test.py::test_datetime_arithmetic_and_duration
FAILED tests/Pendulum/functional_test.py::test_diff_for_humans_months - TypeE...
FAILED tests/Pendulum/functional_test.py::test_parse_date_only_to_date_string
FAILED tests/Pendulum/functional_test.py::test_datetime_to_iso8601_string_roundtrip
FAILED tests/Pendulum/functional_test.py::test_formatting_with_custom_pattern
FAILED tests/Pendulum/functional_test.py::test_start_of_end_of_day - TypeErro...
FAILED tests/Pendulum/functional_test.py::test_weekday_and_isoweekday_values
FAILED tests/Pendulum/functional_test.py::test_duration_total_seconds_and_components
FAILED tests/Pendulum/functional_test.py::test_in_timezone_preserves_instant
FAILED tests/Pendulum/functional_test.py::test_diff_in_days_is_integer - Attr...
FAILED tests/Pendulum/functional_test.py::test_add_months_across_year_boundary
12 failed, 1 skipped in 0.87s

==========================================================================================
PROJECT: Petl
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Petl\pytest_logs\functional.log
==========================================================================================
.FFss.Fs.sss                                                             [100%]
================================== FAILURES ===================================
_____________________ test_fromdicts_addfield_and_select ______________________

    def test_fromdicts_addfield_and_select() -> None:
        """Validate fromdicts, addfield, and select with a small in-memory table."""
        records = [
            {"id": 1, "value": 10},
            {"id": 2, "value": 20},
            {"id": 3, "value": 30},
            {"id": 4, "value": 40},
        ]
        table = petl.fromdicts(records, header=["id", "value"])
    
        table = petl.addfield(table, "double", lambda rec: int(rec["value"]) * 2)
        table = petl.select(table, lambda rec: int(rec["double"]) >= 60)
    
>       result = _table_to_list_of_dicts(table)

tests\Petl\functional_test.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Petl\functional_test.py:87: in _table_to_list_of_dicts
    for row in iterator:
generation\Petl\petl\transform\selects.py:11: in __iter__
    if self.predicate(row):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

rec = (1, 10, None)

>   table = petl.select(table, lambda rec: int(rec["double"]) >= 60)
E   TypeError: tuple indices must be integers or slices, not str

tests\Petl\functional_test.py:166: TypeError
_______________________ test_join_two_tables_fromdicts ________________________

    def test_join_two_tables_fromdicts() -> None:
        """Check that an inner join between two small tables behaves as expected."""
        customers = [
            {"id": 1, "name": "Alice"},
            {"id": 2, "name": "Bob"},
            {"id": 3, "name": "Carol"},
        ]
        orders = [
            {"id": 1, "amount": 100},
            {"id": 1, "amount": 50},
            {"id": 2, "amount": 200},
        ]
    
        customers_tbl = petl.fromdicts(customers, header=["id", "name"])
        orders_tbl = petl.fromdicts(orders, header=["id", "amount"])
    
        joined = petl.join(customers_tbl, orders_tbl, key="id")
        result = _table_to_list_of_dicts(joined)
    
>       assert len(result) == 3
E       AssertionError: assert 4 == 3
E        +  where 4 = len([{'amount': 100, 'id': 1, 'name': 'Alice'}, {'amount': 50, 'id': 1, 'name': 'Alice'}, {'amount': 200, 'id': 2, 'name': 'Bob'}, {'amount': None, 'id': 3, 'name': 'Carol'}])

tests\Petl\functional_test.py:195: AssertionError
_____________________ test_sort_descending_orders_values ______________________

    def test_sort_descending_orders_values() -> None:
        """Sort descending by a numeric field."""
        _require_attr("sort")
    
        records = [
            {"name": "A", "score": 10},
            {"name": "B", "score": 30},
            {"name": "C", "score": 20},
        ]
        table = petl.fromdicts(records, header=["name", "score"])
    
        # petl.sort supports reverse=True in typical implementations.
>       sorted_tbl = petl.sort(table, "score", reverse=True)
E       TypeError: sort() got an unexpected keyword argument 'reverse'

tests\Petl\functional_test.py:278: TypeError
=========================== short test summary info ===========================
FAILED tests/Petl/functional_test.py::test_fromdicts_addfield_and_select - Ty...
FAILED tests/Petl/functional_test.py::test_join_two_tables_fromdicts - Assert...
FAILED tests/Petl/functional_test.py::test_sort_descending_orders_values - Ty...
3 failed, 3 passed, 6 skipped in 0.68s

==========================================================================================
PROJECT: Pygments
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Pygments\pytest_logs\functional.log
==========================================================================================
Traceback (most recent call last):
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\runpy.py", line 188, in _run_module_as_main
    mod_name, mod_spec, code = _get_module_details(mod_name, _Error)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\runpy.py", line 147, in _get_module_details
    return _get_module_details(pkg_main_name, error)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\runpy.py", line 111, in _get_module_details
    __import__(pkg_name)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\pytest\__init__.py", line 8, in <module>
    from _pytest._code import ExceptionInfo
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_code\__init__.py", line 5, in <module>
    from .code import Code
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_code\code.py", line 44, in <module>
    from _pytest._io import TerminalWriter
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_io\__init__.py", line 3, in <module>
    from .terminalwriter import get_terminal_width
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_io\terminalwriter.py", line 15, in <module>
    from pygments.lexer import Lexer
ModuleNotFoundError: No module named 'pygments.lexer'

==========================================================================================
PROJECT: PyJWT
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\PyJWT\pytest_logs\functional.log
==========================================================================================
.F.FF...F.s                                                              [100%]
================================== FAILURES ===================================
_____________________ test_hs512_encode_decode_roundtrip ______________________

    def test_hs512_encode_decode_roundtrip() -> None:
        payload = {"scope": ["read", "write"], "active": True}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS512")

tests\PyJWT\functional_test.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

payload = {'active': True, 'scope': ['read', 'write']}, key = 'secret'
algorithm = 'HS512', kwargs = {}

    def encode(payload, key, algorithm="HS256", **kwargs):
        if algorithm != "HS256":
>           raise NotImplementedError("Only HS256 algorithm is supported")
E           NotImplementedError: Only HS256 algorithm is supported

generation\PyJWT\jwt\api_jwt.py:34: NotImplementedError
_______________ test_encode_decode_with_datetime_exp_in_future ________________

    def test_encode_decode_with_datetime_exp_in_future() -> None:
        exp_dt = _fixed_dt_utc(2099, 1, 1, 0, 0, 0)
        payload = {"sub": "u-123", "exp": exp_dt}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS256")

tests\PyJWT\functional_test.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
generation\PyJWT\jwt\api_jwt.py:43: in encode
    payload_json = json.dumps(payload, separators=(",", ":"), sort_keys=True).encode("utf-8")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x0000019309FD7940>
o = datetime.datetime(2099, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
________________ test_encode_decode_with_datetime_nbf_in_past _________________

    def test_encode_decode_with_datetime_nbf_in_past() -> None:
        nbf_dt = _fixed_dt_utc(2000, 1, 1, 0, 0, 0)
        payload = {"feature": "enabled", "nbf": nbf_dt}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS256")

tests\PyJWT\functional_test.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
generation\PyJWT\jwt\api_jwt.py:43: in encode
    payload_json = json.dumps(payload, separators=(",", ":"), sort_keys=True).encode("utf-8")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x0000019309FED640>
o = datetime.datetime(2000, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
_____________ test_unverified_header_contains_alg_and_custom_kid ______________

    def test_unverified_header_contains_alg_and_custom_kid() -> None:
        payload = {"foo": "bar"}
        key = "secret"
        token = _normalize_token(jwt.encode(payload, key, algorithm="HS256", headers={"kid": "k1", "typ": "JWT"}))
    
>       header = jwt.get_unverified_header(token)
E       AttributeError: module 'jwt' has no attribute 'get_unverified_header'

tests\PyJWT\functional_test.py:210: AttributeError
=========================== short test summary info ===========================
FAILED tests/PyJWT/functional_test.py::test_hs512_encode_decode_roundtrip - N...
FAILED tests/PyJWT/functional_test.py::test_encode_decode_with_datetime_exp_in_future
FAILED tests/PyJWT/functional_test.py::test_encode_decode_with_datetime_nbf_in_past
FAILED tests/PyJWT/functional_test.py::test_unverified_header_contains_alg_and_custom_kid
4 failed, 6 passed, 1 skipped in 0.62s

==========================================================================================
PROJECT: PyPDF
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\PyPDF\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFsF                                                             [100%]
================================== FAILURES ===================================
_______________________ test_create_and_read_blank_pdf ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_create_and_read_blank_pdf0')

    def test_create_and_read_blank_pdf(tmp_path: Path) -> None:
        pdf_path = tmp_path / "simple.pdf"
        _create_simple_pdf(pdf_path, num_pages=3)
    
>       reader = PdfReader(str(pdf_path))

tests\PyPDF\functional_test.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED2483C10>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
______________________ test_blank_page_has_expected_size ______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_blank_page_has_expected_s0')

    def test_blank_page_has_expected_size(tmp_path: Path) -> None:
        """The first blank page should have the width/height we set."""
        pdf_path = tmp_path / "size.pdf"
        _create_simple_pdf(pdf_path, num_pages=1)
    
>       reader = PdfReader(str(pdf_path))

tests\PyPDF\functional_test.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED2438F40>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
_____________________________ test_merge_two_pdfs _____________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_merge_two_pdfs0')

    def test_merge_two_pdfs(tmp_path: Path) -> None:
        pdf1 = tmp_path / "p1.pdf"
        pdf2 = tmp_path / "p2.pdf"
        merged = tmp_path / "merged.pdf"
    
        _create_simple_pdf(pdf1, num_pages=1)
        _create_simple_pdf(pdf2, num_pages=2)
    
>       _write_pdf_with_pages([pdf1, pdf2], merged)

tests\PyPDF\functional_test.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyPDF\functional_test.py:121: in _write_pdf_with_pages
    reader = PdfReader(str(src))
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED24918E0>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
__________________ test_writer_add_page_preserves_page_count __________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_writer_add_page_preserves0')

    def test_writer_add_page_preserves_page_count(tmp_path: Path) -> None:
        """Add pages from a reader into a writer and verify count is preserved."""
        src = tmp_path / "src.pdf"
        dst = tmp_path / "dst.pdf"
        _create_simple_pdf(src, num_pages=4)
    
>       reader = PdfReader(str(src))

tests\PyPDF\functional_test.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED247F280>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
______________________________ test_rotate_page _______________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_rotate_page0')

    def test_rotate_page(tmp_path: Path) -> None:
        src = tmp_path / "src.pdf"
        rotated = tmp_path / "rotated.pdf"
        _create_simple_pdf(src, num_pages=1)
    
>       reader = PdfReader(str(src))

tests\PyPDF\functional_test.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED248E2B0>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
_______________________ test_rotate_preserves_page_size _______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_rotate_preserves_page_siz0')

    def test_rotate_preserves_page_size(tmp_path: Path) -> None:
        """Rotating a blank page should keep a valid mediabox size."""
        src = tmp_path / "src_size.pdf"
        rotated = tmp_path / "rot_size.pdf"
        _create_simple_pdf(src, num_pages=1)
    
>       reader = PdfReader(str(src))

tests\PyPDF\functional_test.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED248F1F0>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
__________________________ test_encrypt_and_decrypt ___________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_encrypt_and_decrypt0')

    def test_encrypt_and_decrypt(tmp_path: Path) -> None:
        src = tmp_path / "plain.pdf"
        enc = tmp_path / "encrypted.pdf"
        _create_simple_pdf(src, num_pages=2)
    
>       reader = PdfReader(str(src))

tests\PyPDF\functional_test.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED25675E0>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
_____________ test_encrypted_pdf_allows_page_access_after_decrypt _____________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_encrypted_pdf_allows_page0')

    def test_encrypted_pdf_allows_page_access_after_decrypt(tmp_path: Path) -> None:
        """After decrypting, basic page access should succeed and page size is valid."""
        src = tmp_path / "plain2.pdf"
        enc = tmp_path / "encrypted2.pdf"
        _create_simple_pdf(src, num_pages=1)
    
>       reader = PdfReader(str(src))

tests\PyPDF\functional_test.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED256A0D0>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
___________________________ test_metadata_roundtrip ___________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_metadata_roundtrip0')

    def test_metadata_roundtrip(tmp_path: Path) -> None:
        src = tmp_path / "src.pdf"
        dst = tmp_path / "meta.pdf"
        _create_simple_pdf(src, num_pages=1)
    
>       reader = PdfReader(str(src))

tests\PyPDF\functional_test.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED248EE80>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
___________________ test_metadata_multiple_fields_roundtrip ___________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_metadata_multiple_fields_0')

    def test_metadata_multiple_fields_roundtrip(tmp_path: Path) -> None:
        """Add several info dict fields and ensure they can be read back."""
        src = tmp_path / "src_info.pdf"
        dst = tmp_path / "info.pdf"
        _create_simple_pdf(src, num_pages=1)
    
>       reader = PdfReader(str(src))

tests\PyPDF\functional_test.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED2481B20>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
_________________ test_clone_document_by_writing_reader_pages _________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-341/test_clone_document_by_writing0')

    def test_clone_document_by_writing_reader_pages(tmp_path: Path) -> None:
        """Clone a document by copying pages and verify page count matches."""
        src = tmp_path / "orig.pdf"
        dst = tmp_path / "clone.pdf"
        _create_simple_pdf(src, num_pages=3)
    
>       reader = PdfReader(str(src))

tests\PyPDF\functional_test.py:363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyPDF\pypdf\_reader.py:22: in __init__
    self._read_pdf()
generation\PyPDF\pypdf\_reader.py:44: in _read_pdf
    self._build_pages()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <pypdf._reader.PdfReader object at 0x0000018ED2592EB0>

    def _build_pages(self):
        # Recursively build pages list from /Pages tree
        def _recurse_pages(node):
            node = self._get_object(node)
            if node is None:
                return
            t = node.get(b"/Type")
            if t == b"/Pages":
                kids = node.get(b"/Kids", [])
                for kid in kids:
                    _recurse_pages(kid)
            elif t == b"/Page":
                self._pages.append(PageObject(self, node))
>       _recurse_pages(self._root.get(b"/Pages"))
E       AttributeError: 'NoneType' object has no attribute 'get'

generation\PyPDF\pypdf\_reader.py:195: AttributeError
=========================== short test summary info ===========================
FAILED tests/PyPDF/functional_test.py::test_create_and_read_blank_pdf - Attri...
FAILED tests/PyPDF/functional_test.py::test_blank_page_has_expected_size - At...
FAILED tests/PyPDF/functional_test.py::test_merge_two_pdfs - AttributeError: ...
FAILED tests/PyPDF/functional_test.py::test_writer_add_page_preserves_page_count
FAILED tests/PyPDF/functional_test.py::test_rotate_page - AttributeError: 'No...
FAILED tests/PyPDF/functional_test.py::test_rotate_preserves_page_size - Attr...
FAILED tests/PyPDF/functional_test.py::test_encrypt_and_decrypt - AttributeEr...
FAILED tests/PyPDF/functional_test.py::test_encrypted_pdf_allows_page_access_after_decrypt
FAILED tests/PyPDF/functional_test.py::test_metadata_roundtrip - AttributeErr...
FAILED tests/PyPDF/functional_test.py::test_metadata_multiple_fields_roundtrip
FAILED tests/PyPDF/functional_test.py::test_clone_document_by_writing_reader_pages
11 failed, 1 skipped in 24.23s

==========================================================================================
PROJECT: Requests
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Requests\pytest_logs\functional.log
==========================================================================================
..........                                                               [100%]
10 passed in 2.10s

==========================================================================================
PROJECT: Rich
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Rich\pytest_logs\functional.log
==========================================================================================

1 skipped in 0.14s

==========================================================================================
PROJECT: Schedule
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Schedule\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFFF                                                             [100%]
================================== FAILURES ===================================
________________________ test_basic_every_and_run_all _________________________

    def test_basic_every_and_run_all() -> None:
        """every(...).seconds/minutes + run_all execute jobs."""
>       _clear()

tests\Schedule\functional_test.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
_________________________ test_tags_and_clear_by_tag __________________________

    def test_tags_and_clear_by_tag() -> None:
        """Jobs can be tagged, selected by tag, and cleared by tag."""
>       _clear()

tests\Schedule\functional_test.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
_____________________ test_cancel_job_removes_single_job ______________________

    def test_cancel_job_removes_single_job() -> None:
        """cancel_job removes a single job from the scheduler."""
>       _clear()

tests\Schedule\functional_test.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
__________________ test_repeat_decorator_registers_and_runs ___________________

    def test_repeat_decorator_registers_and_runs() -> None:
        """@repeat(every(...)) schedules a function correctly and run_all triggers it."""
>       _clear()

tests\Schedule\functional_test.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
_______________ test_run_pending_executes_due_job_without_sleep _______________

    def test_run_pending_executes_due_job_without_sleep() -> None:
        """run_pending executes jobs that are due, without relying on real time waiting."""
>       _clear()

tests\Schedule\functional_test.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
_______________ test_job_next_run_is_datetime_after_scheduling ________________

    def test_job_next_run_is_datetime_after_scheduling() -> None:
        """A newly scheduled job should have a next_run datetime set."""
>       _clear()

tests\Schedule\functional_test.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
______________ test_every_day_at_sets_time_component_in_next_run ______________

    def test_every_day_at_sets_time_component_in_next_run() -> None:
        """Scheduling with .day.at('HH:MM') should include that time in the next_run."""
>       _clear()

tests\Schedule\functional_test.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
______________ test_weekday_scheduling_creates_job_and_next_run _______________

    def test_weekday_scheduling_creates_job_and_next_run() -> None:
        """Weekday scheduling (e.g., monday) should create a job with next_run."""
>       _clear()

tests\Schedule\functional_test.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
________________ test_every_to_creates_job_with_interval_range ________________

    def test_every_to_creates_job_with_interval_range() -> None:
        """every(A).to(B).seconds should create a job and be runnable via run_all."""
>       _clear()

tests\Schedule\functional_test.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
______________________ test_idle_seconds_returns_number _______________________

    def test_idle_seconds_returns_number() -> None:
        """idle_seconds should return a numeric value when jobs exist."""
>       _clear()

tests\Schedule\functional_test.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
_____________________ test_get_jobs_by_tag_filters_subset _____________________

    def test_get_jobs_by_tag_filters_subset() -> None:
        """get_jobs(tag) should return only jobs with that tag."""
>       _clear()

tests\Schedule\functional_test.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
______________________ test_run_all_sets_last_run_on_job ______________________

    def test_run_all_sets_last_run_on_job() -> None:
        """After running, last_run should be populated on the job in typical implementations."""
>       _clear()

tests\Schedule\functional_test.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _clear() -> None:
>       schedule.clear()
E       AttributeError: module 'schedule' has no attribute 'clear'

tests\Schedule\functional_test.py:64: AttributeError
=========================== short test summary info ===========================
FAILED tests/Schedule/functional_test.py::test_basic_every_and_run_all - Attr...
FAILED tests/Schedule/functional_test.py::test_tags_and_clear_by_tag - Attrib...
FAILED tests/Schedule/functional_test.py::test_cancel_job_removes_single_job
FAILED tests/Schedule/functional_test.py::test_repeat_decorator_registers_and_runs
FAILED tests/Schedule/functional_test.py::test_run_pending_executes_due_job_without_sleep
FAILED tests/Schedule/functional_test.py::test_job_next_run_is_datetime_after_scheduling
FAILED tests/Schedule/functional_test.py::test_every_day_at_sets_time_component_in_next_run
FAILED tests/Schedule/functional_test.py::test_weekday_scheduling_creates_job_and_next_run
FAILED tests/Schedule/functional_test.py::test_every_to_creates_job_with_interval_range
FAILED tests/Schedule/functional_test.py::test_idle_seconds_returns_number - ...
FAILED tests/Schedule/functional_test.py::test_get_jobs_by_tag_filters_subset
FAILED tests/Schedule/functional_test.py::test_run_all_sets_last_run_on_job
12 failed in 0.66s

==========================================================================================
PROJECT: Slugify
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Slugify\pytest_logs\functional.log
==========================================================================================
...F...F..F.                                                             [100%]
================================== FAILURES ===================================
_________________ test_allow_unicode_true_preserves_non_ascii _________________

    def test_allow_unicode_true_preserves_non_ascii() -> None:
        """When allow_unicode is True, unicode characters can be preserved."""
        text = "影師嗎"
>       result = slugify(text, allow_unicode=True)

tests\Slugify\functional_test.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Slugify\slugify\slugify.py:69: in slugify
    pattern = re.compile(r'[^\w\s\p{L}\p{N}\p{M}\p{Pc}\p{Pd}]', re.UNICODE)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\re.py:252: in compile
    return _compile(pattern, flags)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\re.py:304: in _compile
    p = sre_compile.compile(pattern, flags)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_compile.py:764: in compile
    p = sre_parse.parse(p, flags)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:948: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:443: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:554: in _parse
    code1 = _class_escape(source, this)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <sre_parse.Tokenizer object at 0x00000238DC5371C0>, escape = '\\p'

    def _class_escape(source, escape):
        # handle escape code inside character class
        code = ESCAPES.get(escape)
        if code:
            return code
        code = CATEGORIES.get(escape)
        if code and code[0] is IN:
            return code
        try:
            c = escape[1:2]
            if c == "x":
                # hexadecimal escape (exactly two digits)
                escape += source.getwhile(2, HEXDIGITS)
                if len(escape) != 4:
                    raise source.error("incomplete escape %s" % escape, len(escape))
                return LITERAL, int(escape[2:], 16)
            elif c == "u" and source.istext:
                # unicode escape (exactly four digits)
                escape += source.getwhile(4, HEXDIGITS)
                if len(escape) != 6:
                    raise source.error("incomplete escape %s" % escape, len(escape))
                return LITERAL, int(escape[2:], 16)
            elif c == "U" and source.istext:
                # unicode escape (exactly eight digits)
                escape += source.getwhile(8, HEXDIGITS)
                if len(escape) != 10:
                    raise source.error("incomplete escape %s" % escape, len(escape))
                c = int(escape[2:], 16)
                chr(c) # raise ValueError for invalid code
                return LITERAL, c
            elif c == "N" and source.istext:
                import unicodedata
                # named unicode escape e.g. \N{EM DASH}
                if not source.match('{'):
                    raise source.error("missing {")
                charname = source.getuntil('}', 'character name')
                try:
                    c = ord(unicodedata.lookup(charname))
                except KeyError:
                    raise source.error("undefined character name %r" % charname,
                                       len(charname) + len(r'\N{}'))
                return LITERAL, c
            elif c in OCTDIGITS:
                # octal escape (up to three digits)
                escape += source.getwhile(2, OCTDIGITS)
                c = int(escape[1:], 8)
                if c > 0o377:
                    raise source.error('octal escape value %s outside of '
                                       'range 0-0o377' % escape, len(escape))
                return LITERAL, c
            elif c in DIGITS:
                raise ValueError
            if len(escape) == 2:
                if c in ASCIILETTERS:
>                   raise source.error('bad escape %s' % escape, len(escape))
E                   re.error: bad escape \p at position 6

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:349: error
________________ test_regex_pattern_allows_underscore_prefixes ________________

    def test_regex_pattern_allows_underscore_prefixes() -> None:
        """Custom regex_pattern can allow underscores to remain."""
        text = "___This is a test___"
        regex_pattern = r"[^-a-z0-9_]+"
    
        result_default_sep = slugify(text, regex_pattern=regex_pattern)
>       assert result_default_sep.startswith("___")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x00000238D9704670>('___')
E        +    where <built-in method startswith of str object at 0x00000238D9704670> = ''.startswith

tests\Slugify\functional_test.py:173: AssertionError
___________________ test_replacements_apply_before_slugging ___________________

    def test_replacements_apply_before_slugging() -> None:
        """replacements should transform substrings before final slug is produced."""
        text = "C# is not C++"
>       result = slugify(text, replacements=[["C#", "Csharp"], ["C++", "Cpp"]])

tests\Slugify\functional_test.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

text = 'C# is not C++', allow_unicode = False, max_length = None
word_boundary = False, separator = '-', regex_pattern = None, stopwords = None
lowercase = True, replacements = [['C#', 'Csharp'], ['C++', 'Cpp']], kwargs = {}

    def slugify(
        text,
        allow_unicode=False,
        max_length=None,
        word_boundary=False,
        separator='-',
        regex_pattern=None,
        stopwords=None,
        lowercase=True,
        replacements=None,
        **kwargs
    ):
        """
        Generate an ASCII-only slug or a unicode slug from the given text.
    
        Parameters
        ----------
        text : str
            Text to slugify.
        allow_unicode : bool, optional
            Whether to allow unicode characters in the slug. Defaults to False.
        max_length : int or None, optional
            Maximum length of the slug. If set, slug will be truncated.
        word_boundary : bool, optional
            If True and max_length is set, truncate at the last separator before max_length.
        separator : str, optional
            Separator character to use in the slug. Defaults to '-'.
        regex_pattern : str or None, optional
            Custom regex pattern to filter characters. Defaults to None.
        stopwords : iterable or None, optional
            Words to exclude from the slug. Defaults to None.
        lowercase : bool, optional
            Whether to lowercase the slug. Defaults to True.
        replacements : dict or None, optional
            Custom replacements to apply before slugification. Defaults to None.
        **kwargs
            Additional keyword arguments (ignored).
    
        Returns
        -------
        str
            The slugified string.
        """
        if not isinstance(text, str):
            text = str(text)
    
        # Apply custom replacements first
        if replacements:
>           for search, replace in replacements.items():
E           AttributeError: 'list' object has no attribute 'items'

generation\Slugify\slugify\slugify.py:52: AttributeError
=========================== short test summary info ===========================
FAILED tests/Slugify/functional_test.py::test_allow_unicode_true_preserves_non_ascii
FAILED tests/Slugify/functional_test.py::test_regex_pattern_allows_underscore_prefixes
FAILED tests/Slugify/functional_test.py::test_replacements_apply_before_slugging
3 failed, 9 passed in 0.59s

==========================================================================================
PROJECT: Sqlmap
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Sqlmap\pytest_logs\functional.log
==========================================================================================
....F....                                                                [100%]
================================== FAILURES ===================================
_____________ test_005_version_runs_and_prints_version_like_token _____________

    def test_005_version_runs_and_prints_version_like_token():
        """
        sqlmap --version may print a raw version token (e.g. 1.9.12.3#dev) and may also
        print an 'exit' message. Do not require specific words like 'sqlmap'/'version'.
        """
        # --batch helps avoid interactive prompts on some builds, but keep tolerance regardless.
        p = _run_cli(["--batch", "--version"], timeout_s=30)
        out = _out(p)
    
        # Require a version-like token such as "1.9.12.3" optionally with suffix "#dev"
>       assert re.search(r"\b\d+\.\d+(?:\.\d+){0,3}(?:#[a-z0-9]+)?\b", out) is not None
E       AssertionError: assert None is not None
E        +  where None = <function search at 0x000001C3E9FD99D0>('\\b\\d+\\.\\d+(?:\\.\\d+){0,3}(?:#[a-z0-9]+)?\\b', '\nusage: sqlmap.py [-h] [-hh] [--version] [-u url] [-p param]\n                 [--level {1,2,3,4,5}] [--risk {1,2,3}]\nsqlmap.py: error: unrecognized arguments: --batch\n')
E        +    where <function search at 0x000001C3E9FD99D0> = re.search

tests\Sqlmap\functional_test.py:80: AssertionError
=========================== short test summary info ===========================
FAILED tests/Sqlmap/functional_test.py::test_005_version_runs_and_prints_version_like_token
1 failed, 8 passed in 1.89s

==========================================================================================
PROJECT: SQLModel
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\SQLModel\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
_____________ ERROR collecting tests/SQLModel/functional_test.py ______________
tests\SQLModel\functional_test.py:34: in <module>
    SQLModel.metadata.clear()
E   AttributeError: 'function' object has no attribute 'clear'
=========================== short test summary info ===========================
ERROR tests/SQLModel/functional_test.py - AttributeError: 'function' object h...
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.57s

==========================================================================================
PROJECT: Stegano
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Stegano\pytest_logs\functional.log
==========================================================================================
FFFFFFFF...F                                                             [100%]
================================== FAILURES ===================================
________________________ test_lsb_hide_and_reveal_text ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-345/test_lsb_hide_and_reveal_text0')

    def test_lsb_hide_and_reveal_text(tmp_path: Path) -> None:
        """lsb.hide(..., str) then lsb.reveal(...) returns the same string."""
        _ensure_image_samples_exist()
    
        secret = "hello world"
        output = tmp_path / "lsb_lenna.png"
    
>       encoded_img = lsb.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'hello world', generator = None, shift = 0, encoding = 'UTF-8'
auto_convert_rgb = False

    def hide(image: Image.Image, message: str, generator: Optional[Iterator[int]] = None, shift: int = 0,
             encoding: str = "UTF-8", auto_convert_rgb: bool = False) -> Image.Image:
        """
        Hide a message in the least significant bits of an image.
    
        :param image: PIL Image to hide message in
        :param message: message string to hide
        :param generator: optional generator of pixel indices to use for hiding bits
        :param shift: bit shift for LSB (0 means least significant bit)
        :param encoding: encoding for message string
        :param auto_convert_rgb: if True, convert image to RGB if not already
        :return: new PIL Image with message hidden
        """
>       if image.mode not in ("RGB", "RGBA", "L"):
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:20: AttributeError
___________________ test_lsb_hide_and_reveal_with_generator ___________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-345/test_lsb_hide_and_reveal_with_0')

    def test_lsb_hide_and_reveal_with_generator(tmp_path: Path) -> None:
        """lsb hide/reveal with a deterministic generator."""
        _ensure_image_samples_exist()
    
        secret = "generator secret"
        output = tmp_path / "lsb_generator.png"
    
        gen = generators.eratosthenes()
>       encoded_img = lsb.hide(str(LENNA_PNG), secret, generator=gen)

tests\Stegano\functional_test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'generator secret'
generator = <generator object eratosthenes at 0x00000178C4ED4430>, shift = 0
encoding = 'UTF-8', auto_convert_rgb = False

    def hide(image: Image.Image, message: str, generator: Optional[Iterator[int]] = None, shift: int = 0,
             encoding: str = "UTF-8", auto_convert_rgb: bool = False) -> Image.Image:
        """
        Hide a message in the least significant bits of an image.
    
        :param image: PIL Image to hide message in
        :param message: message string to hide
        :param generator: optional generator of pixel indices to use for hiding bits
        :param shift: bit shift for LSB (0 means least significant bit)
        :param encoding: encoding for message string
        :param auto_convert_rgb: if True, convert image to RGB if not already
        :return: new PIL Image with message hidden
        """
>       if image.mode not in ("RGB", "RGBA", "L"):
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:20: AttributeError
__________________ test_lsb_hide_and_reveal_long_ascii_text ___________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-345/test_lsb_hide_and_reveal_long_0')

    def test_lsb_hide_and_reveal_long_ascii_text(tmp_path: Path) -> None:
        """LSB should roundtrip a longer ASCII text message (still < typical capacity)."""
        _ensure_image_samples_exist()
    
        secret = "This is a longer secret message with punctuation: 12345, hello-world!"
        output = tmp_path / "lsb_long.png"
    
>       encoded_img = lsb.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'This is a longer secret message with punctuation: 12345, hello-world!'
generator = None, shift = 0, encoding = 'UTF-8', auto_convert_rgb = False

    def hide(image: Image.Image, message: str, generator: Optional[Iterator[int]] = None, shift: int = 0,
             encoding: str = "UTF-8", auto_convert_rgb: bool = False) -> Image.Image:
        """
        Hide a message in the least significant bits of an image.
    
        :param image: PIL Image to hide message in
        :param message: message string to hide
        :param generator: optional generator of pixel indices to use for hiding bits
        :param shift: bit shift for LSB (0 means least significant bit)
        :param encoding: encoding for message string
        :param auto_convert_rgb: if True, convert image to RGB if not already
        :return: new PIL Image with message hidden
        """
>       if image.mode not in ("RGB", "RGBA", "L"):
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:20: AttributeError
______________________ test_lsb_reveal_from_image_object ______________________

    def test_lsb_reveal_from_image_object() -> None:
        """lsb.reveal should work when passed a PIL.Image object (common API usage)."""
        _ensure_image_samples_exist()
    
        secret = "object input"
>       img_obj = lsb.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'object input', generator = None, shift = 0, encoding = 'UTF-8'
auto_convert_rgb = False

    def hide(image: Image.Image, message: str, generator: Optional[Iterator[int]] = None, shift: int = 0,
             encoding: str = "UTF-8", auto_convert_rgb: bool = False) -> Image.Image:
        """
        Hide a message in the least significant bits of an image.
    
        :param image: PIL Image to hide message in
        :param message: message string to hide
        :param generator: optional generator of pixel indices to use for hiding bits
        :param shift: bit shift for LSB (0 means least significant bit)
        :param encoding: encoding for message string
        :param auto_convert_rgb: if True, convert image to RGB if not already
        :return: new PIL Image with message hidden
        """
>       if image.mode not in ("RGB", "RGBA", "L"):
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:20: AttributeError
________________________ test_red_hide_and_reveal_text ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-345/test_red_hide_and_reveal_text0')

    def test_red_hide_and_reveal_text(tmp_path: Path) -> None:
        """red.hide(..., str) then red.reveal(...) returns the same string."""
        _ensure_image_samples_exist()
    
        secret = "red secret"
        output = tmp_path / "red_lenna.png"
    
>       encoded_img = red.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'red secret'

    def hide(image: Image.Image, message: str) -> Image.Image:
        """
        Hide a message in the red channel of an RGB image using LSB steganography.
    
        :param image: PIL Image (must be RGB)
        :param message: message string to hide
        :return: new PIL Image with message hidden
        """
>       if image.mode != "RGB":
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\red\red.py:12: AttributeError
________________ test_red_hide_and_reveal_extended_latin_text _________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-345/test_red_hide_and_reveal_exten0')

    def test_red_hide_and_reveal_extended_latin_text(tmp_path: Path) -> None:
        """Red backend stores per-char ord() into a byte channel; Latin-1 chars like 'é' are valid."""
        _ensure_image_samples_exist()
    
        secret = "Café au lait"
        output = tmp_path / "red_latin.png"
    
>       encoded_img = red.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'Café au lait'

    def hide(image: Image.Image, message: str) -> Image.Image:
        """
        Hide a message in the red channel of an RGB image using LSB steganography.
    
        :param image: PIL Image (must be RGB)
        :param message: message string to hide
        :return: new PIL Image with message hidden
        """
>       if image.mode != "RGB":
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\red\red.py:12: AttributeError
_______________________ test_exif_hide_and_reveal_bytes _______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-345/test_exif_hide_and_reveal_byte0')

    def test_exif_hide_and_reveal_bytes(tmp_path: Path) -> None:
        """exifHeader.hide writes output file, exifHeader.reveal returns original bytes."""
        _ensure_image_samples_exist()
    
        secret = b"exif secret bytes"
        output = tmp_path / "exif_out.jpg"
    
        exifHeader.hide(str(EXIF_JPEG), str(output), secret_message=secret)
        assert output.exists()
        assert output.stat().st_size > 0
    
>       revealed = exifHeader.reveal(str(output))

tests\Stegano\functional_test.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-345\\test_exif_hide_and_reveal_byte0\\exif_out.jpg'

    def reveal(image: Image.Image) -> bytes:
        """
        Reveal a hidden byte message from the EXIF UserComment tag of a PIL Image.
    
        :param image: PIL Image object
        :return: extracted byte message
        """
>       if "exif" not in image.info:
E       AttributeError: 'str' object has no attribute 'info'

generation\Stegano\stegano\exifHeader\exifHeader.py:48: AttributeError
_____________ test_exif_hide_two_outputs_with_different_payloads ______________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-345/test_exif_hide_two_outputs_wit0')

    def test_exif_hide_two_outputs_with_different_payloads(tmp_path: Path) -> None:
        """Write two different EXIF-hidden files (two independent happy-path scenarios)."""
        _ensure_image_samples_exist()
    
        out1 = tmp_path / "exif_one.jpg"
        out2 = tmp_path / "exif_two.jpg"
    
        secret1 = b"payload-one"
        secret2 = b"payload-two"
    
        exifHeader.hide(str(EXIF_JPEG), str(out1), secret_message=secret1)
        exifHeader.hide(str(EXIF_JPEG), str(out2), secret_message=secret2)
    
        assert out1.exists() and out1.stat().st_size > 0
        assert out2.exists() and out2.stat().st_size > 0
    
>       assert exifHeader.reveal(str(out1)) == secret1

tests\Stegano\functional_test.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-345\\test_exif_hide_two_outputs_wit0\\exif_one.jpg'

    def reveal(image: Image.Image) -> bytes:
        """
        Reveal a hidden byte message from the EXIF UserComment tag of a PIL Image.
    
        :param image: PIL Image object
        :return: extracted byte message
        """
>       if "exif" not in image.info:
E       AttributeError: 'str' object has no attribute 'info'

generation\Stegano\stegano\exifHeader\exifHeader.py:48: AttributeError
_____________________ test_lsb_and_red_outputs_are_files ______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-345/test_lsb_and_red_outputs_are_f0')

    def test_lsb_and_red_outputs_are_files(tmp_path: Path) -> None:
        """Ensure image-encoding backends produce files that can be written to disk."""
        _ensure_image_samples_exist()
    
        out_lsb = tmp_path / "lsb_file.png"
        out_red = tmp_path / "red_file.png"
    
>       lsb.hide(str(LENNA_PNG), "x").save(str(out_lsb))

tests\Stegano\functional_test.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'x', generator = None, shift = 0, encoding = 'UTF-8'
auto_convert_rgb = False

    def hide(image: Image.Image, message: str, generator: Optional[Iterator[int]] = None, shift: int = 0,
             encoding: str = "UTF-8", auto_convert_rgb: bool = False) -> Image.Image:
        """
        Hide a message in the least significant bits of an image.
    
        :param image: PIL Image to hide message in
        :param message: message string to hide
        :param generator: optional generator of pixel indices to use for hiding bits
        :param shift: bit shift for LSB (0 means least significant bit)
        :param encoding: encoding for message string
        :param auto_convert_rgb: if True, convert image to RGB if not already
        :return: new PIL Image with message hidden
        """
>       if image.mode not in ("RGB", "RGBA", "L"):
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\lsb\lsb.py:20: AttributeError
=========================== short test summary info ===========================
FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_text - Attr...
FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_with_generator
FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_long_ascii_text
FAILED tests/Stegano/functional_test.py::test_lsb_reveal_from_image_object - ...
FAILED tests/Stegano/functional_test.py::test_red_hide_and_reveal_text - Attr...
FAILED tests/Stegano/functional_test.py::test_red_hide_and_reveal_extended_latin_text
FAILED tests/Stegano/functional_test.py::test_exif_hide_and_reveal_bytes - At...
FAILED tests/Stegano/functional_test.py::test_exif_hide_two_outputs_with_different_payloads
FAILED tests/Stegano/functional_test.py::test_lsb_and_red_outputs_are_files
9 failed, 3 passed in 2.48s

==========================================================================================
PROJECT: Tablib
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Tablib\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
______________ ERROR collecting tests/Tablib/functional_test.py _______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\Tablib\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\Tablib\functional_test.py:59: in <module>
    import tablib  # type: ignore  # noqa: E402
generation\Tablib\tablib\__init__.py:1: in <module>
    from .core import Dataset, Databook
generation\Tablib\tablib\core.py:4: in <module>
    from .formats import _csv, _json
generation\Tablib\tablib\formats\_csv.py:4: in <module>
    from ..core import Dataset
E   ImportError: cannot import name 'Dataset' from partially initialized module 'tablib.core' (most likely due to a circular import) (D:\桌面\RealAppCodeBench_generic_eval\generation\Tablib\tablib\core.py)
=========================== short test summary info ===========================
ERROR tests/Tablib/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.68s

==========================================================================================
PROJECT: Tabulate
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Tabulate\pytest_logs\functional.log
==========================================================================================
..FFFFFFFFF.                                                             [100%]
================================== FAILURES ===================================
___________________ test_headers_firstrow_and_simple_format ___________________

    def test_headers_firstrow_and_simple_format() -> None:
        table = [
            ["Name", "Age"],
            ["Alice", 24],
            ["Bob", 19],
        ]
    
>       output = tabulate(table, headers="firstrow", tablefmt="simple")

tests\Tabulate\functional_test.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Tabulate\tabulate\core.py:414: in tabulate
    return formatter(tabular_data, headers=headers, colalign=colalign)
generation\Tabulate\tabulate\core.py:252: in _format_plain
    widths, colalign = _column_widths(table, headers, colalign)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

table = [['Name', 'Age'], ['Alice', 24], ['Bob', 19]], headers = 'firstrow'
colalign = None

    def _column_widths(table, headers, colalign):
        """
        Calculate max width of each column considering multiline cells.
        """
        ncols = len(table[0]) if table else (len(headers) if headers else 0)
        widths = [0] * ncols
    
        # Consider headers
        if headers:
            for i, h in enumerate(headers):
                lines = _split_multiline(_stringify(h))
                maxw = max(len(line) for line in lines)
>               if maxw > widths[i]:
E               IndexError: list index out of range

generation\Tabulate\tabulate\core.py:99: IndexError
___________________ test_headers_keys_on_dict_of_iterables ____________________

    def test_headers_keys_on_dict_of_iterables() -> None:
        table = {
            "Name": ["Alice", "Bob"],
            "Age": [24, 19],
        }
    
        output = tabulate(table, headers="keys")
        lines = _lines(output)
    
>       assert "Name" in lines[0]
E       AssertionError: assert 'Name' in 'k e y s'

tests\Tabulate\functional_test.py:137: AssertionError
___________________________ test_showindex_variants ___________________________

    def test_showindex_variants() -> None:
        table = [
            ["F", 24],
            ["M", 19],
        ]
    
>       out_true = tabulate(table, showindex=True)
E       TypeError: tabulate() got an unexpected keyword argument 'showindex'

tests\Tabulate\functional_test.py:151: TypeError
________________________ test_github_and_grid_formats _________________________

    def test_github_and_grid_formats() -> None:
        table = [
            ["item", "qty"],
            ["spam", 42],
            ["eggs", 451],
            ["bacon", 0],
        ]
    
>       out_github = tabulate(table[1:], headers=table[0], tablefmt="github")

tests\Tabulate\functional_test.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tabular_data = [['spam', 42], ['eggs', 451], ['bacon', 0]]
headers = ['item', 'qty'], tablefmt = 'github', colalign = None

    def tabulate(tabular_data, headers=None, tablefmt="simple", colalign=None):
        """
        Format tabular data (list of lists, list of dicts, dict) into a string table.
    
        Parameters:
        - tabular_data: data to format
        - headers: list of headers or None
        - tablefmt: format name or callable
        - colalign: list of alignments per column ("left", "right", "center")
    
        Returns:
        - formatted string
        """
        if callable(tablefmt):
            return tablefmt(tabular_data, headers=headers, colalign=colalign)
        fmt = tablefmt.lower()
        if fmt == "simple":
            fmt = "plain"
        if fmt not in _table_formats:
>           raise ValueError(f"Unknown table format: {tablefmt}")
E           ValueError: Unknown table format: github

generation\Tabulate\tabulate\core.py:412: ValueError
____________________ test_list_of_dicts_headers_keys_plain ____________________

    def test_list_of_dicts_headers_keys_plain() -> None:
        rows = [
            {"name": "Alice", "score": 10},
            {"name": "Bob", "score": 12},
        ]
        output = tabulate(rows, headers="keys", tablefmt="plain")
        lines = _lines(output)
    
        header = lines[0]
>       assert "name" in header
E       AssertionError: assert 'name' in 'k e y s'

tests\Tabulate\functional_test.py:194: AssertionError
_____________________ test_missingval_renders_placeholder _____________________

    def test_missingval_renders_placeholder() -> None:
        rows = [
            ["Alice", None],
            ["Bob", "ok"],
        ]
>       output = tabulate(rows, headers=["name", "status"], tablefmt="plain", missingval="N/A")
E       TypeError: tabulate() got an unexpected keyword argument 'missingval'

tests\Tabulate\functional_test.py:207: TypeError
__________________ test_floatfmt_controls_numeric_rendering ___________________

    def test_floatfmt_controls_numeric_rendering() -> None:
        rows = [
            ["pi", 3.14159],
            ["e", 2.71828],
        ]
>       output = tabulate(rows, headers=["name", "value"], tablefmt="plain", floatfmt=".2f")
E       TypeError: tabulate() got an unexpected keyword argument 'floatfmt'

tests\Tabulate\functional_test.py:222: TypeError
_______________ test_disable_numparse_preserves_numeric_strings _______________

    def test_disable_numparse_preserves_numeric_strings() -> None:
        rows = [
            ["code", "value"],
            ["A", "001"],
            ["B", "010"],
        ]
>       output = tabulate(rows[1:], headers=rows[0], tablefmt="plain", disable_numparse=True)
E       TypeError: tabulate() got an unexpected keyword argument 'disable_numparse'

tests\Tabulate\functional_test.py:236: TypeError
______________________ test_maxcolwidths_wraps_long_text ______________________

    def test_maxcolwidths_wraps_long_text() -> None:
        long_text = "alpha beta gamma delta epsilon zeta"
        rows = [
            ["id", "note"],
            [1, long_text],
            [2, "short"],
        ]
>       output = tabulate(
            rows[1:],
            headers=rows[0],
            tablefmt="simple",
            maxcolwidths=[None, 10],
        )
E       TypeError: tabulate() got an unexpected keyword argument 'maxcolwidths'

tests\Tabulate\functional_test.py:251: TypeError
=========================== short test summary info ===========================
FAILED tests/Tabulate/functional_test.py::test_headers_firstrow_and_simple_format
FAILED tests/Tabulate/functional_test.py::test_headers_keys_on_dict_of_iterables
FAILED tests/Tabulate/functional_test.py::test_showindex_variants - TypeError...
FAILED tests/Tabulate/functional_test.py::test_github_and_grid_formats - Valu...
FAILED tests/Tabulate/functional_test.py::test_list_of_dicts_headers_keys_plain
FAILED tests/Tabulate/functional_test.py::test_missingval_renders_placeholder
FAILED tests/Tabulate/functional_test.py::test_floatfmt_controls_numeric_rendering
FAILED tests/Tabulate/functional_test.py::test_disable_numparse_preserves_numeric_strings
FAILED tests/Tabulate/functional_test.py::test_maxcolwidths_wraps_long_text
9 failed, 3 passed in 0.61s

==========================================================================================
PROJECT: Termgraph
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Termgraph\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFF                                                              [100%]
================================== FAILURES ===================================
______________________ test_simple_horizontal_bar_chart _______________________

capsys = <_pytest.capture.CaptureFixture object at 0x00000202858A4E80>

    def test_simple_horizontal_bar_chart(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["A", "B", "C"]
        values = [[3], [5], [2]]
    
        data = Data(values, labels)
        args = _make_args(title="Test Chart", width=20, format="{:>5.1f}")
    
        chart = BarChart(data, args)
>       chart.draw()

tests\Termgraph\functional_test.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.BarChart object at 0x00000202858A8FA0>

    def draw(self):
        # Only horizontal bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # For bar length scaling
        max_val = 0
        for series in self.data.data:
            for val in series:
>               if val > max_val:
E               TypeError: '>' not supported between instances of 'str' and 'int'

generation\Termgraph\termgraph\charts.py:31: TypeError
_____________________ test_stacked_chart_multiple_series ______________________

capsys = <_pytest.capture.CaptureFixture object at 0x0000020285900B80>

    def test_stacked_chart_multiple_series(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["X", "Y"]
        values = [[1, 2], [3, 4]]
    
        data = Data(values, labels)
        args = _make_args(title="Stacked Chart", width=30, format="{:>4.1f}")
    
        chart = StackedChart(data, args)
>       chart.draw()

tests\Termgraph\functional_test.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.StackedChart object at 0x0000020285900B20>

    def draw(self):
        # Only horizontal stacked bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # sum values per item (stacked)
        sums = []
        n_items = self.data.num_items()
        n_series = self.data.num_series()
        for i in range(n_items):
            s = 0
            for series in self.data.data:
                if i < len(series):
>                   s += series[i]
E                   TypeError: unsupported operand type(s) for +=: 'int' and 'str'

generation\Termgraph\termgraph\charts.py:102: TypeError
_______________________ test_bar_chart_object_interface _______________________

capsys = <_pytest.capture.CaptureFixture object at 0x0000020285898040>

    def test_bar_chart_object_interface(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["D", "E"]
        values = [[4], [1]]
    
        data = Data(values, labels)
        args = _make_args(title="Bars", width=10, format="{:>4.1f}")
    
        chart = BarChart(data, args)
>       chart.draw()

tests\Termgraph\functional_test.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.BarChart object at 0x0000020285898AC0>

    def draw(self):
        # Only horizontal bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # For bar length scaling
        max_val = 0
        for series in self.data.data:
            for val in series:
>               if val > max_val:
E               TypeError: '>' not supported between instances of 'str' and 'int'

generation\Termgraph\termgraph\charts.py:31: TypeError
___________________ test_bar_chart_respects_no_values_flag ____________________

capsys = <_pytest.capture.CaptureFixture object at 0x0000020283E00C10>

    def test_bar_chart_respects_no_values_flag(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["A", "B"]
        values = [[2], [7]]
    
        data = Data(values, labels)
        args = _make_args(title="No Values", width=12, no_values=True, format="{:>5.1f}")
    
>       BarChart(data, args).draw()

tests\Termgraph\functional_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.BarChart object at 0x0000020285871AF0>

    def draw(self):
        # Only horizontal bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # For bar length scaling
        max_val = 0
        for series in self.data.data:
            for val in series:
>               if val > max_val:
E               TypeError: '>' not supported between instances of 'str' and 'int'

generation\Termgraph\termgraph\charts.py:31: TypeError
___________________ test_bar_chart_respects_no_labels_flag ____________________

capsys = <_pytest.capture.CaptureFixture object at 0x0000020285923CA0>

    def test_bar_chart_respects_no_labels_flag(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["L1", "L2", "L3"]
        values = [[1], [2], [3]]
    
        data = Data(values, labels)
        args = _make_args(title="No Labels", width=10, no_labels=True, format="{:>4.1f}")
    
>       BarChart(data, args).draw()

tests\Termgraph\functional_test.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.BarChart object at 0x0000020285923D60>

    def draw(self):
        # Only horizontal bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # For bar length scaling
        max_val = 0
        for series in self.data.data:
            for val in series:
>               if val > max_val:
E               TypeError: '>' not supported between instances of 'str' and 'int'

generation\Termgraph\termgraph\charts.py:31: TypeError
__________________ test_bar_chart_suffix_appended_to_values ___________________

capsys = <_pytest.capture.CaptureFixture object at 0x00000202858A4550>

    def test_bar_chart_suffix_appended_to_values(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["CPU", "RAM"]
        values = [[12.5], [7.0]]
    
        data = Data(values, labels)
        args = _make_args(title="Suffix", width=18, suffix="%", format="{:>4.1f}")
    
>       BarChart(data, args).draw()

tests\Termgraph\functional_test.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.BarChart object at 0x00000202858A4190>

    def draw(self):
        # Only horizontal bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # For bar length scaling
        max_val = 0
        for series in self.data.data:
            for val in series:
>               if val > max_val:
E               TypeError: '>' not supported between instances of 'str' and 'int'

generation\Termgraph\termgraph\charts.py:31: TypeError
___________ test_bar_chart_custom_format_changes_numeric_rendering ____________

capsys = <_pytest.capture.CaptureFixture object at 0x00000202859115E0>

    def test_bar_chart_custom_format_changes_numeric_rendering(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["P", "Q"]
        values = [[3.14159], [2.71828]]
    
        data = Data(values, labels)
        args = _make_args(title="Fmt", width=20, format="{:>6.2f}")
    
>       BarChart(data, args).draw()

tests\Termgraph\functional_test.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.BarChart object at 0x00000202859114C0>

    def draw(self):
        # Only horizontal bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # For bar length scaling
        max_val = 0
        for series in self.data.data:
            for val in series:
>               if val > max_val:
E               TypeError: '>' not supported between instances of 'str' and 'int'

generation\Termgraph\termgraph\charts.py:31: TypeError
____________________ test_stacked_chart_renders_all_labels ____________________

capsys = <_pytest.capture.CaptureFixture object at 0x0000020285859EB0>

    def test_stacked_chart_renders_all_labels(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["S1", "S2", "S3"]
        values = [[1, 1], [2, 1], [1, 3]]
    
        data = Data(values, labels)
        args = _make_args(title="Stack Labels", width=25, format="{:>4.1f}")
    
>       StackedChart(data, args).draw()

tests\Termgraph\functional_test.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.StackedChart object at 0x00000202858597C0>

    def draw(self):
        # Only horizontal stacked bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # sum values per item (stacked)
        sums = []
        n_items = self.data.num_items()
        n_series = self.data.num_series()
        for i in range(n_items):
            s = 0
            for series in self.data.data:
                if i < len(series):
>                   s += series[i]
E                   TypeError: unsupported operand type(s) for +=: 'int' and 'str'

generation\Termgraph\termgraph\charts.py:102: TypeError
____________ test_stacked_chart_no_values_still_renders_structure _____________

capsys = <_pytest.capture.CaptureFixture object at 0x00000202858921F0>

    def test_stacked_chart_no_values_still_renders_structure(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["A", "B"]
        values = [[1, 2, 3], [3, 2, 1]]
    
        data = Data(values, labels)
        args = _make_args(title="Stack No Values", width=30, no_values=True, format="{:>4.1f}")
    
>       StackedChart(data, args).draw()

tests\Termgraph\functional_test.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.StackedChart object at 0x00000202858922E0>

    def draw(self):
        # Only horizontal stacked bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # sum values per item (stacked)
        sums = []
        n_items = self.data.num_items()
        n_series = self.data.num_series()
        for i in range(n_items):
            s = 0
            for series in self.data.data:
                if i < len(series):
>                   s += series[i]
E                   TypeError: unsupported operand type(s) for +=: 'int' and 'str'

generation\Termgraph\termgraph\charts.py:102: TypeError
__________________ test_title_none_does_not_break_rendering ___________________

capsys = <_pytest.capture.CaptureFixture object at 0x00000202858FF2E0>

    def test_title_none_does_not_break_rendering(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["U", "V"]
        values = [[4], [6]]
    
        data = Data(values, labels)
        args = _make_args(title=None, width=15, format="{:>4.1f}")
    
>       BarChart(data, args).draw()

tests\Termgraph\functional_test.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.BarChart object at 0x00000202858FF970>

    def draw(self):
        # Only horizontal bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # For bar length scaling
        max_val = 0
        for series in self.data.data:
            for val in series:
>               if val > max_val:
E               TypeError: '>' not supported between instances of 'str' and 'int'

generation\Termgraph\termgraph\charts.py:31: TypeError
________________ test_width_parameter_affects_output_presence _________________

capsys = <_pytest.capture.CaptureFixture object at 0x0000020285912130>

    def test_width_parameter_affects_output_presence(capsys: pytest.CaptureFixture[str]) -> None:
        labels = ["W"]
        values = [[9]]
    
        data = Data(values, labels)
    
        args_narrow = _make_args(title="Narrow", width=5, format="{:>4.1f}")
>       BarChart(data, args_narrow).draw()

tests\Termgraph\functional_test.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <termgraph.charts.BarChart object at 0x0000020285912F70>

    def draw(self):
        # Only horizontal bar charts supported
        if self.args.vertical:
            print("Vertical charts not supported in this implementation.", file=sys.stderr)
            return
    
        labels = self.args.labels if self.args.labels is not None else self.data.labels
        if labels is None:
            labels = [''] * self.data.num_items()
    
        max_label_len = max((len(str(label)) for label in labels), default=0)
        max_label_len = min(max_label_len, 20)  # limit label width
    
        max_width = self.args.width
        format_str = self.args.format
        suffix = self.args.suffix
        no_labels = self.args.no_labels
        no_values = self.args.no_values
    
        # For bar length scaling
        max_val = 0
        for series in self.data.data:
            for val in series:
>               if val > max_val:
E               TypeError: '>' not supported between instances of 'str' and 'int'

generation\Termgraph\termgraph\charts.py:31: TypeError
=========================== short test summary info ===========================
FAILED tests/Termgraph/functional_test.py::test_simple_horizontal_bar_chart
FAILED tests/Termgraph/functional_test.py::test_stacked_chart_multiple_series
FAILED tests/Termgraph/functional_test.py::test_bar_chart_object_interface - ...
FAILED tests/Termgraph/functional_test.py::test_bar_chart_respects_no_values_flag
FAILED tests/Termgraph/functional_test.py::test_bar_chart_respects_no_labels_flag
FAILED tests/Termgraph/functional_test.py::test_bar_chart_suffix_appended_to_values
FAILED tests/Termgraph/functional_test.py::test_bar_chart_custom_format_changes_numeric_rendering
FAILED tests/Termgraph/functional_test.py::test_stacked_chart_renders_all_labels
FAILED tests/Termgraph/functional_test.py::test_stacked_chart_no_values_still_renders_structure
FAILED tests/Termgraph/functional_test.py::test_title_none_does_not_break_rendering
FAILED tests/Termgraph/functional_test.py::test_width_parameter_affects_output_presence
11 failed in 25.89s

==========================================================================================
PROJECT: TheFuck
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\TheFuck\pytest_logs\functional.log
==========================================================================================
.FFFFFFFFF..                                                             [100%]
================================== FAILURES ===================================
___________________ test_002_import_no_command_rule_module ____________________

    def test_002_import_no_command_rule_module() -> None:
>       importlib.import_module("thefuck.rules.no_command")

tests\TheFuck\functional_test.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'thefuck.rules.no_command'
import_ = <function _gcd_import at 0x000001D3C73E1310>

>   ???
E   ModuleNotFoundError: No module named 'thefuck.rules.no_command'

<frozen importlib._bootstrap>:984: ModuleNotFoundError
_____________ test_003_no_command_match_returns_bool_windows_like _____________

    def test_003_no_command_match_returns_bool_windows_like() -> None:
>       match_fn, _ = _import_no_command_rule()

tests\TheFuck\functional_test.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'thefuck.rules.no_command'
import_ = <function _gcd_import at 0x000001D3C73E1310>

>   ???
E   ModuleNotFoundError: No module named 'thefuck.rules.no_command'

<frozen importlib._bootstrap>:984: ModuleNotFoundError
______________ test_004_no_command_match_returns_bool_bash_like _______________

    def test_004_no_command_match_returns_bool_bash_like() -> None:
>       match_fn, _ = _import_no_command_rule()

tests\TheFuck\functional_test.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'thefuck.rules.no_command'
import_ = <function _gcd_import at 0x000001D3C73E1310>

>   ???
E   ModuleNotFoundError: No module named 'thefuck.rules.no_command'

<frozen importlib._bootstrap>:984: ModuleNotFoundError
______ test_005_no_command_like_rule_matches_at_least_one_typical_output ______

    def test_005_no_command_like_rule_matches_at_least_one_typical_output() -> None:
        """
        Ensure the reference no_command rule actually matches a typical 'command not found' output.
        We check both Windows and bash variants, and require at least one to match.
        """
>       match_fn, _ = _import_no_command_rule()

tests\TheFuck\functional_test.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'thefuck.rules.no_command'
import_ = <function _gcd_import at 0x000001D3C73E1310>

>   ???
E   ModuleNotFoundError: No module named 'thefuck.rules.no_command'

<frozen importlib._bootstrap>:984: ModuleNotFoundError
___________ test_006_no_command_get_new_command_returns_string_like ___________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-346/test_006_no_command_get_new_co0')

    def test_006_no_command_get_new_command_returns_string_like(tmp_path: Path) -> None:
        """
        get_new_command should return something string-like (or iterable of strings).
        Do not require a specific suggestion yet.
        """
>       _, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'thefuck.rules.no_command'
import_ = <function _gcd_import at 0x000001D3C73E1310>

>   ???
E   ModuleNotFoundError: No module named 'thefuck.rules.no_command'

<frozen importlib._bootstrap>:984: ModuleNotFoundError
________ test_007_no_command_suggests_python_when_only_python_in_path _________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-346/test_007_no_command_suggests_p0')

    def test_007_no_command_suggests_python_when_only_python_in_path(tmp_path: Path) -> None:
        """
        With PATH constrained to a directory containing only python.cmd,
        the best correction for 'pythno' should include 'python' in the suggestion.
        """
>       _, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'thefuck.rules.no_command'
import_ = <function _gcd_import at 0x000001D3C73E1310>

>   ???
E   ModuleNotFoundError: No module named 'thefuck.rules.no_command'

<frozen importlib._bootstrap>:984: ModuleNotFoundError
_______________ test_008_no_command_suggestion_is_deterministic _______________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-346/test_008_no_command_suggestion0')

    def test_008_no_command_suggestion_is_deterministic(tmp_path: Path) -> None:
        """
        Same input should yield same first suggestion in a controlled PATH.
        """
>       _, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'thefuck.rules.no_command'
import_ = <function _gcd_import at 0x000001D3C73E1310>

>   ???
E   ModuleNotFoundError: No module named 'thefuck.rules.no_command'

<frozen importlib._bootstrap>:984: ModuleNotFoundError
_____________ test_009_no_command_does_not_crash_on_empty_output ______________

    def test_009_no_command_does_not_crash_on_empty_output() -> None:
>       match_fn, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'thefuck.rules.no_command'
import_ = <function _gcd_import at 0x000001D3C73E1310>

>   ???
E   ModuleNotFoundError: No module named 'thefuck.rules.no_command'

<frozen importlib._bootstrap>:984: ModuleNotFoundError
_________________ test_010_no_command_handles_unicode_output __________________

    def test_010_no_command_handles_unicode_output() -> None:
>       match_fn, get_new_fn = _import_no_command_rule()

tests\TheFuck\functional_test.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\TheFuck\functional_test.py:42: in _import_no_command_rule
    mod = importlib.import_module("thefuck.rules.no_command")
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'thefuck.rules.no_command'
import_ = <function _gcd_import at 0x000001D3C73E1310>

>   ???
E   ModuleNotFoundError: No module named 'thefuck.rules.no_command'

<frozen importlib._bootstrap>:984: ModuleNotFoundError
=========================== short test summary info ===========================
FAILED tests/TheFuck/functional_test.py::test_002_import_no_command_rule_module
FAILED tests/TheFuck/functional_test.py::test_003_no_command_match_returns_bool_windows_like
FAILED tests/TheFuck/functional_test.py::test_004_no_command_match_returns_bool_bash_like
FAILED tests/TheFuck/functional_test.py::test_005_no_command_like_rule_matches_at_least_one_typical_output
FAILED tests/TheFuck/functional_test.py::test_006_no_command_get_new_command_returns_string_like
FAILED tests/TheFuck/functional_test.py::test_007_no_command_suggests_python_when_only_python_in_path
FAILED tests/TheFuck/functional_test.py::test_008_no_command_suggestion_is_deterministic
FAILED tests/TheFuck/functional_test.py::test_009_no_command_does_not_crash_on_empty_output
FAILED tests/TheFuck/functional_test.py::test_010_no_command_handles_unicode_output
9 failed, 3 passed in 0.81s

==========================================================================================
PROJECT: TinyDB
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\TinyDB\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
______________ ERROR collecting tests/TinyDB/functional_test.py _______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\TinyDB\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\TinyDB\functional_test.py:49: in <module>
    from tinydb import TinyDB, Query, where  # type: ignore  # noqa: E402
E   ImportError: cannot import name 'where' from 'tinydb' (D:\桌面\RealAppCodeBench_generic_eval\generation\TinyDB\tinydb\__init__.py)
=========================== short test summary info ===========================
ERROR tests/TinyDB/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.59s

==========================================================================================
PROJECT: Typer
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Typer\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFFF                                                             [100%]
================================== FAILURES ===================================
__________________________ test_simple_hello_command __________________________

    def test_simple_hello_command() -> None:
>       app = _create_greeter_app()

tests\Typer\functional_test.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_greeter_app() -> typer.Typer:
        """
        Single-command style app (callback-only):
          app NAME [--excited]
        """
        app = typer.Typer()
    
>       @app.callback(invoke_without_command=True)
E       AttributeError: 'Typer' object has no attribute 'callback'

tests\Typer\functional_test.py:70: AttributeError
______________________ test_simple_hello_command_excited ______________________

    def test_simple_hello_command_excited() -> None:
>       app = _create_greeter_app()

tests\Typer\functional_test.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_greeter_app() -> typer.Typer:
        """
        Single-command style app (callback-only):
          app NAME [--excited]
        """
        app = typer.Typer()
    
>       @app.callback(invoke_without_command=True)
E       AttributeError: 'Typer' object has no attribute 'callback'

tests\Typer\functional_test.py:70: AttributeError
_______________ test_greeter_help_mentions_option_and_argument ________________

    def test_greeter_help_mentions_option_and_argument() -> None:
>       app = _create_greeter_app()

tests\Typer\functional_test.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_greeter_app() -> typer.Typer:
        """
        Single-command style app (callback-only):
          app NAME [--excited]
        """
        app = typer.Typer()
    
>       @app.callback(invoke_without_command=True)
E       AttributeError: 'Typer' object has no attribute 'callback'

tests\Typer\functional_test.py:70: AttributeError
_____________________ test_todo_list_empty_shows_no_tasks _____________________

    def test_todo_list_empty_shows_no_tasks() -> None:
        app = _create_todo_app()
        r = runner.invoke(app, ["list"])
        assert r.exit_code == 0
>       assert "No tasks." in r.stdout
E       AttributeError: 'Result' object has no attribute 'stdout'

tests\Typer\functional_test.py:224: AttributeError
___________________________ test_todo_add_and_list ____________________________

    def test_todo_add_and_list() -> None:
        app = _create_todo_app()
    
        r1 = runner.invoke(app, ["add", "Write tests"])
        r2 = runner.invoke(app, ["add", "Review PRs"])
    
        assert r1.exit_code == 0
>       assert "Added: Write tests" in r1.stdout
E       AttributeError: 'Result' object has no attribute 'stdout'

tests\Typer\functional_test.py:234: AttributeError
_____________________ test_todo_remove_then_list_updates ______________________

    def test_todo_remove_then_list_updates() -> None:
        app = _create_todo_app()
    
        runner.invoke(app, ["add", "Task 1"])
        runner.invoke(app, ["add", "Task 2"])
    
        r_remove = runner.invoke(app, ["remove", "1"])
>       assert r_remove.exit_code == 0
E       assert 1 == 0
E        +  where 1 = <typer.testing.Result object at 0x0000014EA7172E20>.exit_code

tests\Typer\functional_test.py:252: AssertionError
_____________________ test_help_output_includes_commands ______________________

    def test_help_output_includes_commands() -> None:
        app = _create_todo_app()
        result = runner.invoke(app, ["--help"])
        assert result.exit_code == 0
>       out = result.stdout
E       AttributeError: 'Result' object has no attribute 'stdout'

tests\Typer\functional_test.py:265: AttributeError
_______________ test_subcommand_help_for_add_mentions_argument ________________

    def test_subcommand_help_for_add_mentions_argument() -> None:
        app = _create_todo_app()
        result = runner.invoke(app, ["add", "--help"])
        assert result.exit_code == 0
>       out = result.stdout
E       AttributeError: 'Result' object has no attribute 'stdout'

tests\Typer\functional_test.py:275: AttributeError
________________________ test_prompt_option_happy_path ________________________

    def test_prompt_option_happy_path() -> None:
>       app = _create_prompt_app()

tests\Typer\functional_test.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_prompt_app() -> typer.Typer:
        """
        Multi-command app to avoid Typer's single-command "collapse" behavior in
        some versions. This guarantees that "greet" exists as a subcommand.
        """
        app = typer.Typer()
    
        @app.command()
        def greet(
>           name: str = typer.Option(
                None,
                "--name",
                prompt=True,
                help="Name to greet (prompted when missing).",
            )
        ) -> None:
E       TypeError: __init__() got an unexpected keyword argument 'prompt'

tests\Typer\functional_test.py:121: TypeError
________________________ test_envvar_option_happy_path ________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x0000014EA71D16D0>

    def test_envvar_option_happy_path(monkeypatch: pytest.MonkeyPatch) -> None:
>       app = _create_env_app()

tests\Typer\functional_test.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_env_app() -> typer.Typer:
        """
        Multi-command app to guarantee that "show" exists as a subcommand.
        """
        app = typer.Typer()
    
        @app.command()
>       def show(token: str = typer.Option(..., "--token", envvar="APP_TOKEN")) -> None:
E       TypeError: __init__() got an unexpected keyword argument 'envvar'

tests\Typer\functional_test.py:144: TypeError
_____________ test_callback_global_option_affects_command_output ______________

    def test_callback_global_option_affects_command_output() -> None:
>       app = _create_callback_app()

tests\Typer\functional_test.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_callback_app() -> typer.Typer:
        """App with a callback global option that influences command output."""
        app = typer.Typer()
        state: Dict[str, bool] = {"verbose": False}
    
>       @app.callback()
E       AttributeError: 'Typer' object has no attribute 'callback'

tests\Typer\functional_test.py:159: AttributeError
____________________ test_typed_arguments_and_float_option ____________________

    def test_typed_arguments_and_float_option() -> None:
>       app = _create_types_app()

tests\Typer\functional_test.py:310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _create_types_app() -> typer.Typer:
        """
        Multi-command app to guarantee that "calc" exists as a subcommand.
        Covers typed arguments and a float option.
        """
        app = typer.Typer()
    
        @app.command()
>       def calc(x: int, y: int, scale: float = typer.Option(1.0, "--scale")) -> None:
E       TypeError: __init__() takes from 1 to 2 positional arguments but 3 were given

tests\Typer\functional_test.py:181: TypeError
=========================== short test summary info ===========================
FAILED tests/Typer/functional_test.py::test_simple_hello_command - AttributeE...
FAILED tests/Typer/functional_test.py::test_simple_hello_command_excited - At...
FAILED tests/Typer/functional_test.py::test_greeter_help_mentions_option_and_argument
FAILED tests/Typer/functional_test.py::test_todo_list_empty_shows_no_tasks - ...
FAILED tests/Typer/functional_test.py::test_todo_add_and_list - AttributeErro...
FAILED tests/Typer/functional_test.py::test_todo_remove_then_list_updates - a...
FAILED tests/Typer/functional_test.py::test_help_output_includes_commands - A...
FAILED tests/Typer/functional_test.py::test_subcommand_help_for_add_mentions_argument
FAILED tests/Typer/functional_test.py::test_prompt_option_happy_path - TypeEr...
FAILED tests/Typer/functional_test.py::test_envvar_option_happy_path - TypeEr...
FAILED tests/Typer/functional_test.py::test_callback_global_option_affects_command_output
FAILED tests/Typer/functional_test.py::test_typed_arguments_and_float_option
12 failed in 0.62s

==========================================================================================
PROJECT: Watchdog
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Watchdog\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
_____________ ERROR collecting tests/Watchdog/functional_test.py ______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\Watchdog\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\Watchdog\functional_test.py:54: in <module>
    from watchdog.observers import Observer  # type: ignore  # noqa: E402
E   ImportError: cannot import name 'Observer' from 'watchdog.observers' (D:\桌面\RealAppCodeBench_generic_eval\generation\Watchdog\watchdog\observers\__init__.py)
=========================== short test summary info ===========================
ERROR tests/Watchdog/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.60s

==========================================================================================
PROJECT: Xmltodict
LOG: D:\桌面\Exp1\gpt-3.5-turbo\results\Xmltodict\pytest_logs\functional.log
==========================================================================================
FF..FFF.FFFF                                                             [100%]
================================== FAILURES ===================================
__________________________ test_parse_simple_element __________________________

    def test_parse_simple_element() -> None:
        """Parsing a simple XML element should produce the expected dict."""
        xml = "<root><message>Hello</message></root>"
        data = _parse(xml)
    
        assert "root" in data
>       assert data["root"]["message"] == "Hello"
E       AssertionError: assert {'#text': 'Hello'} == 'Hello'

tests\Xmltodict\functional_test.py:80: AssertionError
____________________ test_parse_repeated_elements_as_list _____________________

    def test_parse_repeated_elements_as_list() -> None:
        """Repeated child elements should be represented as a list."""
        xml = "<root><item>1</item><item>2</item><item>3</item></root>"
        data = _parse(xml)
    
        items = data["root"]["item"]
        assert isinstance(items, list)
>       assert items == ["1", "2", "3"]
E       AssertionError: assert [{'#text': '1...'#text': '3'}] == ['1', '2', '3']
E         
E         At index 0 diff: {'#text': '1'} != '1'
E         Use -v to get more diff

tests\Xmltodict\functional_test.py:90: AssertionError
_____________________ test_namespace_prefix_is_preserved ______________________

    def test_namespace_prefix_is_preserved() -> None:
        """Namespace prefixes in element names should be preserved in dict keys."""
        xml = """
        <root xmlns:x="http://example.com/x">
            <x:item>value</x:item>
        </root>
        """
        data = _parse(xml)
    
        root = data["root"]
        keys = [k for k in root.keys() if isinstance(k, str)]
>       assert any(k.startswith("x:") for k in keys)
E       assert False
E        +  where False = any(<generator object test_namespace_prefix_is_preserved.<locals>.<genexpr> at 0x0000024685E12BA0>)

tests\Xmltodict\functional_test.py:131: AssertionError
_________________________ test_parse_nested_structure _________________________

    def test_parse_nested_structure() -> None:
        """Nested XML elements should map to nested dict structures."""
        xml = """
        <root>
            <user>
                <name>Ada</name>
                <address>
                    <city>London</city>
                    <country>UK</country>
                </address>
            </user>
        </root>
        """
        data = _parse(xml)
>       assert data["root"]["user"]["name"] == "Ada"
E       AssertionError: assert {'#text': 'Ada'} == 'Ada'

tests\Xmltodict\functional_test.py:151: AssertionError
__________________ test_force_list_option_for_single_element __________________

    def test_force_list_option_for_single_element() -> None:
        """force_list should allow representing a single child as a list when supported."""
        xml = "<root><item>1</item></root>"
    
        # Prefer a targeted force_list that is common in xmltodict.
        data = _parse(xml, force_list=("item",))
    
        item = data["root"]["item"]
        if "force_list" in _PARSE_PARAMS:
            assert isinstance(item, list)
            assert item == ["1"]
        else:
            # Fallback: without force_list support, single element is typically a scalar string.
>           assert item == "1"
E           AssertionError: assert {'#text': '1'} == '1'

tests\Xmltodict\functional_test.py:169: AssertionError
____________ test_xml_attribs_false_drops_attributes_if_supported _____________

    def test_xml_attribs_false_drops_attributes_if_supported() -> None:
        """xml_attribs=False should omit attribute keys when supported."""
        xml = '<user id="9"><name>Alice</name></user>'
    
        data = _parse(xml, xml_attribs=False)
        user = data["user"]
    
        if "xml_attribs" in _PARSE_PARAMS:
            # With xml_attribs=False, attribute keys should not be present.
            assert "@id" not in user
            assert user["name"] == "Alice"
        else:
            # Fallback: attribute is included in typical default behavior.
            assert user.get("@id") == "9"
>           assert user["name"] == "Alice"
E           AssertionError: assert {'#text': 'Alice'} == 'Alice'

tests\Xmltodict\functional_test.py:201: AssertionError
______________________ test_dict_constructor_ordereddict ______________________

    def test_dict_constructor_ordereddict() -> None:
        """dict_constructor should allow choosing mapping type (e.g., OrderedDict) when supported."""
        xml = "<root><a>1</a><b>2</b></root>"
        data = _parse(xml, dict_constructor=OrderedDict)
    
        if "dict_constructor" in _PARSE_PARAMS:
            assert isinstance(data, OrderedDict)
            assert isinstance(data["root"], OrderedDict)
        else:
            assert isinstance(data, dict)
    
>       assert data["root"]["a"] == "1"
E       AssertionError: assert {'#text': '1'} == '1'

tests\Xmltodict\functional_test.py:215: AssertionError
_____________________ test_unparse_pretty_and_parse_back ______________________

    def test_unparse_pretty_and_parse_back() -> None:
        """Pretty/full_document knobs should not break roundtrip of basic structure."""
        original: Dict[str, Any] = {"root": {"x": "1", "y": "2"}}
    
        xml = _unparse(original, pretty=True, full_document=True)
        assert "<root>" in xml or "<root" in xml
    
        round_tripped = _parse(xml)
>       assert round_tripped == original
E       AssertionError: assert {'root': {'x'...#text': '2'}}} == {'root': {'x': '1', 'y': '2'}}
E         
E         Differing items:
E         {'root': {'x': {'#text': '1'}, 'y': {'#text': '2'}}} != {'root': {'x': '1', 'y': '2'}}
E         Use -v to get more diff

tests\Xmltodict\functional_test.py:227: AssertionError
______________ test_postprocessor_transforms_value_if_supported _______________

    def test_postprocessor_transforms_value_if_supported() -> None:
        """postprocessor can transform values in a happy-path parse when supported."""
        xml = "<root><message>Hello</message></root>"
    
        def _pp(path: Any, key: str, value: Any) -> Any:
            if key == "message" and isinstance(value, str):
                return key, value.upper()
            return key, value
    
        data = _parse(xml, postprocessor=_pp)
    
        if "postprocessor" in _PARSE_PARAMS:
            assert data["root"]["message"] == "HELLO"
        else:
>           assert data["root"]["message"] == "Hello"
E           AssertionError: assert {'#text': 'Hello'} == 'Hello'

tests\Xmltodict\functional_test.py:244: AssertionError
=========================== short test summary info ===========================
FAILED tests/Xmltodict/functional_test.py::test_parse_simple_element - Assert...
FAILED tests/Xmltodict/functional_test.py::test_parse_repeated_elements_as_list
FAILED tests/Xmltodict/functional_test.py::test_namespace_prefix_is_preserved
FAILED tests/Xmltodict/functional_test.py::test_parse_nested_structure - Asse...
FAILED tests/Xmltodict/functional_test.py::test_force_list_option_for_single_element
FAILED tests/Xmltodict/functional_test.py::test_xml_attribs_false_drops_attributes_if_supported
FAILED tests/Xmltodict/functional_test.py::test_dict_constructor_ordereddict
FAILED tests/Xmltodict/functional_test.py::test_unparse_pretty_and_parse_back
FAILED tests/Xmltodict/functional_test.py::test_postprocessor_transforms_value_if_supported
9 failed, 3 passed in 0.65s

