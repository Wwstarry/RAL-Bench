.......F..F.                                                             [100%]
================================== FAILURES ===================================
________________ test_regex_pattern_allows_underscore_prefixes ________________

    def test_regex_pattern_allows_underscore_prefixes() -> None:
        """Custom regex_pattern can allow underscores to remain."""
        text = "___This is a test___"
        regex_pattern = r"[^-a-z0-9_]+"
    
>       result_default_sep = slugify(text, regex_pattern=regex_pattern)

tests\Slugify\functional_test.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

text = '___this is a test___', allow_unicode = False, max_length = None
word_boundary = False, separator = '-', regex_pattern = '[^-a-z0-9_]+'
stopwords = None, lowercase = True, replacements = None, kwargs = {}

    def slugify(
        text: str,
        allow_unicode: bool = False,
        max_length: Optional[int] = None,
        word_boundary: bool = False,
        separator: str = '-',
        regex_pattern: Optional[Pattern] = None,
        stopwords: Optional[List[str]] = None,
        lowercase: bool = True,
        replacements: Optional[List[List[str]]] = None,
        **kwargs
    ) -> str:
        """
        Convert text to a URL-friendly slug.
    
        Args:
            text: Input text to slugify
            allow_unicode: Allow unicode characters in the slug
            max_length: Maximum length of the slug
            word_boundary: Truncate at word boundary when max_length is reached
            separator: Separator character (default: '-')
            regex_pattern: Custom regex pattern for character filtering
            stopwords: List of words to remove from the slug
            lowercase: Convert to lowercase (default: True)
            replacements: List of [pattern, replacement] pairs for custom replacements
            **kwargs: Additional arguments (ignored for compatibility)
    
        Returns:
            Slugified string
        """
        if text is None:
            return ""
    
        # Apply custom replacements first
        if replacements:
            for pattern, replacement in replacements:
                text = re.sub(pattern, replacement, text)
    
        # Normalize unicode
        text = unicodedata.normalize('NFKC', str(text))
    
        # Handle unicode characters
        if allow_unicode:
            # Keep unicode characters, remove unwanted ones
            text = re.sub(r'[^\w\s\-_]', '', text, flags=re.UNICODE)
        else:
            # Transliterate unicode characters to ASCII
            text = _transliterate_unicode(text)
            # Remove non-ASCII characters
            text = re.sub(r'[^\w\s\-]', '', text)
    
        # Convert to lowercase if requested
        if lowercase:
            text = text.lower()
    
        # Remove stopwords
        if stopwords is not None:
            text = _remove_stopwords(text, stopwords)
    
        # Apply custom regex pattern if provided
        if regex_pattern is not None:
>           text = regex_pattern.sub('', text)
E           AttributeError: 'str' object has no attribute 'sub'

generation\Slugify\slugify\slugify.py:115: AttributeError
___________________ test_replacements_apply_before_slugging ___________________

    def test_replacements_apply_before_slugging() -> None:
        """replacements should transform substrings before final slug is produced."""
        text = "C# is not C++"
>       result = slugify(text, replacements=[["C#", "Csharp"], ["C++", "Cpp"]])

tests\Slugify\functional_test.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Slugify\slugify\slugify.py:90: in slugify
    text = re.sub(pattern, replacement, text)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\re.py:210: in sub
    return _compile(pattern, flags).sub(repl, string, count)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\re.py:304: in _compile
    p = sre_compile.compile(pattern, flags)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_compile.py:764: in compile
    p = sre_parse.parse(p, flags)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:948: in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:443: in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <sre_parse.Tokenizer object at 0x0000028A0F249FD0>
state = <sre_parse.State object at 0x0000028A0F249880>, verbose = 0, nested = 1
first = True

    def _parse(source, state, verbose, nested, first=False):
        # parse a simple pattern
        subpattern = SubPattern(state)
    
        # precompute constants into local variables
        subpatternappend = subpattern.append
        sourceget = source.get
        sourcematch = source.match
        _len = len
        _ord = ord
    
        while True:
    
            this = source.next
            if this is None:
                break # end of pattern
            if this in "|)":
                break # end of subpattern
            sourceget()
    
            if verbose:
                # skip whitespace and comments
                if this in WHITESPACE:
                    continue
                if this == "#":
                    while True:
                        this = sourceget()
                        if this is None or this == "\n":
                            break
                    continue
    
            if this[0] == "\\":
                code = _escape(source, this, state)
                subpatternappend(code)
    
            elif this not in SPECIAL_CHARS:
                subpatternappend((LITERAL, _ord(this)))
    
            elif this == "[":
                here = source.tell() - 1
                # character set
                set = []
                setappend = set.append
    ##          if sourcematch(":"):
    ##              pass # handle character classes
                if source.next == '[':
                    import warnings
                    warnings.warn(
                        'Possible nested set at position %d' % source.tell(),
                        FutureWarning, stacklevel=nested + 6
                    )
                negate = sourcematch("^")
                # check remaining characters
                while True:
                    this = sourceget()
                    if this is None:
                        raise source.error("unterminated character set",
                                           source.tell() - here)
                    if this == "]" and set:
                        break
                    elif this[0] == "\\":
                        code1 = _class_escape(source, this)
                    else:
                        if set and this in '-&~|' and source.next == this:
                            import warnings
                            warnings.warn(
                                'Possible set %s at position %d' % (
                                    'difference' if this == '-' else
                                    'intersection' if this == '&' else
                                    'symmetric difference' if this == '~' else
                                    'union',
                                    source.tell() - 1),
                                FutureWarning, stacklevel=nested + 6
                            )
                        code1 = LITERAL, _ord(this)
                    if sourcematch("-"):
                        # potential range
                        that = sourceget()
                        if that is None:
                            raise source.error("unterminated character set",
                                               source.tell() - here)
                        if that == "]":
                            if code1[0] is IN:
                                code1 = code1[1][0]
                            setappend(code1)
                            setappend((LITERAL, _ord("-")))
                            break
                        if that[0] == "\\":
                            code2 = _class_escape(source, that)
                        else:
                            if that == '-':
                                import warnings
                                warnings.warn(
                                    'Possible set difference at position %d' % (
                                        source.tell() - 2),
                                    FutureWarning, stacklevel=nested + 6
                                )
                            code2 = LITERAL, _ord(that)
                        if code1[0] != LITERAL or code2[0] != LITERAL:
                            msg = "bad character range %s-%s" % (this, that)
                            raise source.error(msg, len(this) + 1 + len(that))
                        lo = code1[1]
                        hi = code2[1]
                        if hi < lo:
                            msg = "bad character range %s-%s" % (this, that)
                            raise source.error(msg, len(this) + 1 + len(that))
                        setappend((RANGE, (lo, hi)))
                    else:
                        if code1[0] is IN:
                            code1 = code1[1][0]
                        setappend(code1)
    
                set = _uniq(set)
                # XXX: <fl> should move set optimization to compiler!
                if _len(set) == 1 and set[0][0] is LITERAL:
                    # optimization
                    if negate:
                        subpatternappend((NOT_LITERAL, set[0][1]))
                    else:
                        subpatternappend(set[0])
                else:
                    if negate:
                        set.insert(0, (NEGATE, None))
                    # charmap optimization can't be added here because
                    # global flags still are not known
                    subpatternappend((IN, set))
    
            elif this in REPEAT_CHARS:
                # repeat previous item
                here = source.tell()
                if this == "?":
                    min, max = 0, 1
                elif this == "*":
                    min, max = 0, MAXREPEAT
    
                elif this == "+":
                    min, max = 1, MAXREPEAT
                elif this == "{":
                    if source.next == "}":
                        subpatternappend((LITERAL, _ord(this)))
                        continue
    
                    min, max = 0, MAXREPEAT
                    lo = hi = ""
                    while source.next in DIGITS:
                        lo += sourceget()
                    if sourcematch(","):
                        while source.next in DIGITS:
                            hi += sourceget()
                    else:
                        hi = lo
                    if not sourcematch("}"):
                        subpatternappend((LITERAL, _ord(this)))
                        source.seek(here)
                        continue
    
                    if lo:
                        min = int(lo)
                        if min >= MAXREPEAT:
                            raise OverflowError("the repetition number is too large")
                    if hi:
                        max = int(hi)
                        if max >= MAXREPEAT:
                            raise OverflowError("the repetition number is too large")
                        if max < min:
                            raise source.error("min repeat greater than max repeat",
                                               source.tell() - here)
                else:
                    raise AssertionError("unsupported quantifier %r" % (char,))
                # figure out which item to repeat
                if subpattern:
                    item = subpattern[-1:]
                else:
                    item = None
                if not item or item[0][0] is AT:
                    raise source.error("nothing to repeat",
                                       source.tell() - here + len(this))
                if item[0][0] in _REPEATCODES:
>                   raise source.error("multiple repeat",
                                       source.tell() - here + len(this))
E                   re.error: multiple repeat at position 2

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\sre_parse.py:671: error
=========================== short test summary info ===========================
FAILED tests/Slugify/functional_test.py::test_regex_pattern_allows_underscore_prefixes
FAILED tests/Slugify/functional_test.py::test_replacements_apply_before_slugging
2 failed, 10 passed in 0.61s
