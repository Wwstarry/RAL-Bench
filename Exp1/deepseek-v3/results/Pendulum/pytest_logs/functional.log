FFFFFFFF.sFFF                                                            [100%]
================================== FAILURES ===================================
_____________________ test_parse_and_timezone_conversion ______________________

cls = <class 'pendulum.datetime.DateTime'>, text = '2020-01-01T12:00:00+00:00'
tz = None

    @classmethod
    def parse(cls, text, tz=None):
        try:
>           dt_naive = dt.datetime.strptime(text, '%Y-%m-%dT%H:%M:%S.%f')

generation\Pendulum\pendulum\datetime.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\_strptime.py:568: in _strptime_datetime
    tt, fraction, gmtoff_fraction = _strptime(data_string, format)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data_string = '2020-01-01T12:00:00+00:00', format = '%Y-%m-%dT%H:%M:%S.%f'

    def _strptime(data_string, format="%a %b %d %H:%M:%S %Y"):
        """Return a 2-tuple consisting of a time struct and an int containing
        the number of microseconds based on the input string and the
        format string."""
    
        for index, arg in enumerate([data_string, format]):
            if not isinstance(arg, str):
                msg = "strptime() argument {} must be str, not {}"
                raise TypeError(msg.format(index, type(arg)))
    
        global _TimeRE_cache, _regex_cache
        with _cache_lock:
            locale_time = _TimeRE_cache.locale_time
            if (_getlang() != locale_time.lang or
                time.tzname != locale_time.tzname or
                time.daylight != locale_time.daylight):
                _TimeRE_cache = TimeRE()
                _regex_cache.clear()
                locale_time = _TimeRE_cache.locale_time
            if len(_regex_cache) > _CACHE_MAX_SIZE:
                _regex_cache.clear()
            format_regex = _regex_cache.get(format)
            if not format_regex:
                try:
                    format_regex = _TimeRE_cache.compile(format)
                # KeyError raised when a bad format is found; can be specified as
                # \\, in which case it was a stray % but with a space after it
                except KeyError as err:
                    bad_directive = err.args[0]
                    if bad_directive == "\\":
                        bad_directive = "%"
                    del err
                    raise ValueError("'%s' is a bad directive in format '%s'" %
                                        (bad_directive, format)) from None
                # IndexError only occurs when the format string is "%"
                except IndexError:
                    raise ValueError("stray %% in format '%s'" % format) from None
                _regex_cache[format] = format_regex
        found = format_regex.match(data_string)
        if not found:
>           raise ValueError("time data %r does not match format %r" %
                             (data_string, format))
E           ValueError: time data '2020-01-01T12:00:00+00:00' does not match format '%Y-%m-%dT%H:%M:%S.%f'

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\_strptime.py:349: ValueError

During handling of the above exception, another exception occurred:

cls = <class 'pendulum.datetime.DateTime'>, text = '2020-01-01T12:00:00+00:00'
tz = None

    @classmethod
    def parse(cls, text, tz=None):
        try:
            dt_naive = dt.datetime.strptime(text, '%Y-%m-%dT%H:%M:%S.%f')
        except ValueError:
            try:
>               dt_naive = dt.datetime.strptime(text, '%Y-%m-%dT%H:%M:%S')

generation\Pendulum\pendulum\datetime.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\_strptime.py:568: in _strptime_datetime
    tt, fraction, gmtoff_fraction = _strptime(data_string, format)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data_string = '2020-01-01T12:00:00+00:00', format = '%Y-%m-%dT%H:%M:%S'

    def _strptime(data_string, format="%a %b %d %H:%M:%S %Y"):
        """Return a 2-tuple consisting of a time struct and an int containing
        the number of microseconds based on the input string and the
        format string."""
    
        for index, arg in enumerate([data_string, format]):
            if not isinstance(arg, str):
                msg = "strptime() argument {} must be str, not {}"
                raise TypeError(msg.format(index, type(arg)))
    
        global _TimeRE_cache, _regex_cache
        with _cache_lock:
            locale_time = _TimeRE_cache.locale_time
            if (_getlang() != locale_time.lang or
                time.tzname != locale_time.tzname or
                time.daylight != locale_time.daylight):
                _TimeRE_cache = TimeRE()
                _regex_cache.clear()
                locale_time = _TimeRE_cache.locale_time
            if len(_regex_cache) > _CACHE_MAX_SIZE:
                _regex_cache.clear()
            format_regex = _regex_cache.get(format)
            if not format_regex:
                try:
                    format_regex = _TimeRE_cache.compile(format)
                # KeyError raised when a bad format is found; can be specified as
                # \\, in which case it was a stray % but with a space after it
                except KeyError as err:
                    bad_directive = err.args[0]
                    if bad_directive == "\\":
                        bad_directive = "%"
                    del err
                    raise ValueError("'%s' is a bad directive in format '%s'" %
                                        (bad_directive, format)) from None
                # IndexError only occurs when the format string is "%"
                except IndexError:
                    raise ValueError("stray %% in format '%s'" % format) from None
                _regex_cache[format] = format_regex
        found = format_regex.match(data_string)
        if not found:
            raise ValueError("time data %r does not match format %r" %
                             (data_string, format))
        if len(data_string) != found.end():
>           raise ValueError("unconverted data remains: %s" %
                              data_string[found.end():])
E           ValueError: unconverted data remains: +00:00

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\_strptime.py:352: ValueError

During handling of the above exception, another exception occurred:

    def test_parse_and_timezone_conversion() -> None:
        """Parse an ISO string and convert between timezones."""
>       dt_utc = pendulum.parse("2020-01-01T12:00:00+00:00")

tests\Pendulum\functional_test.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\__init__.py:11: in parse
    return DateTime.parse(text, tz=tz)
generation\Pendulum\pendulum\datetime.py:36: in parse
    dt_naive = dt.datetime.strptime(text, '%Y-%m-%d')
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\_strptime.py:568: in _strptime_datetime
    tt, fraction, gmtoff_fraction = _strptime(data_string, format)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

data_string = '2020-01-01T12:00:00+00:00', format = '%Y-%m-%d'

    def _strptime(data_string, format="%a %b %d %H:%M:%S %Y"):
        """Return a 2-tuple consisting of a time struct and an int containing
        the number of microseconds based on the input string and the
        format string."""
    
        for index, arg in enumerate([data_string, format]):
            if not isinstance(arg, str):
                msg = "strptime() argument {} must be str, not {}"
                raise TypeError(msg.format(index, type(arg)))
    
        global _TimeRE_cache, _regex_cache
        with _cache_lock:
            locale_time = _TimeRE_cache.locale_time
            if (_getlang() != locale_time.lang or
                time.tzname != locale_time.tzname or
                time.daylight != locale_time.daylight):
                _TimeRE_cache = TimeRE()
                _regex_cache.clear()
                locale_time = _TimeRE_cache.locale_time
            if len(_regex_cache) > _CACHE_MAX_SIZE:
                _regex_cache.clear()
            format_regex = _regex_cache.get(format)
            if not format_regex:
                try:
                    format_regex = _TimeRE_cache.compile(format)
                # KeyError raised when a bad format is found; can be specified as
                # \\, in which case it was a stray % but with a space after it
                except KeyError as err:
                    bad_directive = err.args[0]
                    if bad_directive == "\\":
                        bad_directive = "%"
                    del err
                    raise ValueError("'%s' is a bad directive in format '%s'" %
                                        (bad_directive, format)) from None
                # IndexError only occurs when the format string is "%"
                except IndexError:
                    raise ValueError("stray %% in format '%s'" % format) from None
                _regex_cache[format] = format_regex
        found = format_regex.match(data_string)
        if not found:
            raise ValueError("time data %r does not match format %r" %
                             (data_string, format))
        if len(data_string) != found.end():
>           raise ValueError("unconverted data remains: %s" %
                              data_string[found.end():])
E           ValueError: unconverted data remains: T12:00:00+00:00

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\_strptime.py:352: ValueError
____________________ test_datetime_arithmetic_and_duration ____________________

    def test_datetime_arithmetic_and_duration() -> None:
        """Basic arithmetic with pendulum.datetime and pendulum.duration."""
>       base = pendulum.datetime(2021, 3, 15, 10, 30, 0, tz="UTC")

tests\Pendulum\functional_test.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\__init__.py:8: in datetime
    return DateTime(year, month, day, hour, minute, second, microsecond, tz=tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'pendulum.datetime.DateTime'>, year = 2021, month = 3, day = 15
hour = 10, minute = 30, second = 0, microsecond = 0, tz = Timezone('UTC')

    def __new__(cls, year, month, day, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is not None:
            if isinstance(tz, str):
                tz = Timezone(tz)
            elif not isinstance(tz, (Timezone, FixedTimezone)):
                raise ValueError('tz argument must be a timezone instance or string')
    
>       self = super().__new__(
            cls, year, month, day, hour, minute, second, microsecond, tz
        )
E       TypeError: tzinfo argument must be None or of a tzinfo subclass, not type 'Timezone'

generation\Pendulum\pendulum\datetime.py:53: TypeError
_________________________ test_diff_for_humans_months _________________________

    def test_diff_for_humans_months() -> None:
        """Human-readable differences between two datetimes."""
>       start = pendulum.datetime(2011, 8, 1, tz="UTC")

tests\Pendulum\functional_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\__init__.py:8: in datetime
    return DateTime(year, month, day, hour, minute, second, microsecond, tz=tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'pendulum.datetime.DateTime'>, year = 2011, month = 8, day = 1
hour = 0, minute = 0, second = 0, microsecond = 0, tz = Timezone('UTC')

    def __new__(cls, year, month, day, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is not None:
            if isinstance(tz, str):
                tz = Timezone(tz)
            elif not isinstance(tz, (Timezone, FixedTimezone)):
                raise ValueError('tz argument must be a timezone instance or string')
    
>       self = super().__new__(
            cls, year, month, day, hour, minute, second, microsecond, tz
        )
E       TypeError: tzinfo argument must be None or of a tzinfo subclass, not type 'Timezone'

generation\Pendulum\pendulum\datetime.py:53: TypeError
_____________________ test_parse_date_only_to_date_string _____________________

    def test_parse_date_only_to_date_string() -> None:
        """Parse a date-only string and verify normalized date output."""
        d = pendulum.parse("2020-02-29")
        assert d.year == 2020
        assert d.month == 2
        assert d.day == 29
>       assert d.to_date_string() == "2020-02-29"
E       AttributeError: 'DateTime' object has no attribute 'to_date_string'

tests\Pendulum\functional_test.py:121: AttributeError
__________________ test_datetime_to_iso8601_string_roundtrip __________________

    def test_datetime_to_iso8601_string_roundtrip() -> None:
        """Create a datetime and verify ISO8601 string contains expected offset."""
>       dt = pendulum.datetime(2020, 1, 1, 12, 0, 0, tz="UTC")

tests\Pendulum\functional_test.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\__init__.py:8: in datetime
    return DateTime(year, month, day, hour, minute, second, microsecond, tz=tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'pendulum.datetime.DateTime'>, year = 2020, month = 1, day = 1
hour = 12, minute = 0, second = 0, microsecond = 0, tz = Timezone('UTC')

    def __new__(cls, year, month, day, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is not None:
            if isinstance(tz, str):
                tz = Timezone(tz)
            elif not isinstance(tz, (Timezone, FixedTimezone)):
                raise ValueError('tz argument must be a timezone instance or string')
    
>       self = super().__new__(
            cls, year, month, day, hour, minute, second, microsecond, tz
        )
E       TypeError: tzinfo argument must be None or of a tzinfo subclass, not type 'Timezone'

generation\Pendulum\pendulum\datetime.py:53: TypeError
_____________________ test_formatting_with_custom_pattern _____________________

    def test_formatting_with_custom_pattern() -> None:
        """Verify formatting with a custom pattern is stable for a fixed datetime."""
>       dt = pendulum.datetime(2021, 12, 31, 23, 59, 58, tz="UTC")

tests\Pendulum\functional_test.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\__init__.py:8: in datetime
    return DateTime(year, month, day, hour, minute, second, microsecond, tz=tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'pendulum.datetime.DateTime'>, year = 2021, month = 12, day = 31
hour = 23, minute = 59, second = 58, microsecond = 0, tz = Timezone('UTC')

    def __new__(cls, year, month, day, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is not None:
            if isinstance(tz, str):
                tz = Timezone(tz)
            elif not isinstance(tz, (Timezone, FixedTimezone)):
                raise ValueError('tz argument must be a timezone instance or string')
    
>       self = super().__new__(
            cls, year, month, day, hour, minute, second, microsecond, tz
        )
E       TypeError: tzinfo argument must be None or of a tzinfo subclass, not type 'Timezone'

generation\Pendulum\pendulum\datetime.py:53: TypeError
__________________________ test_start_of_end_of_day ___________________________

    def test_start_of_end_of_day() -> None:
        """Check start_of and end_of for a day boundary."""
>       dt = pendulum.datetime(2020, 5, 20, 13, 14, 15, tz="UTC")

tests\Pendulum\functional_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\__init__.py:8: in datetime
    return DateTime(year, month, day, hour, minute, second, microsecond, tz=tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'pendulum.datetime.DateTime'>, year = 2020, month = 5, day = 20
hour = 13, minute = 14, second = 15, microsecond = 0, tz = Timezone('UTC')

    def __new__(cls, year, month, day, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is not None:
            if isinstance(tz, str):
                tz = Timezone(tz)
            elif not isinstance(tz, (Timezone, FixedTimezone)):
                raise ValueError('tz argument must be a timezone instance or string')
    
>       self = super().__new__(
            cls, year, month, day, hour, minute, second, microsecond, tz
        )
E       TypeError: tzinfo argument must be None or of a tzinfo subclass, not type 'Timezone'

generation\Pendulum\pendulum\datetime.py:53: TypeError
_____________________ test_weekday_and_isoweekday_values ______________________

    def test_weekday_and_isoweekday_values() -> None:
        """Validate weekday values for a known date (2020-01-01 is Wednesday)."""
>       dt = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:155: AttributeError
_____________________ test_in_timezone_preserves_instant ______________________

    def test_in_timezone_preserves_instant() -> None:
        """Converting timezones should preserve the instant (timestamp)."""
>       dt_utc = pendulum.datetime(2020, 6, 1, 0, 0, 0, tz="UTC")

tests\Pendulum\functional_test.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\__init__.py:8: in datetime
    return DateTime(year, month, day, hour, minute, second, microsecond, tz=tz)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'pendulum.datetime.DateTime'>, year = 2020, month = 6, day = 1
hour = 0, minute = 0, second = 0, microsecond = 0, tz = Timezone('UTC')

    def __new__(cls, year, month, day, hour=0, minute=0, second=0, microsecond=0, tz=None):
        if tz is not None:
            if isinstance(tz, str):
                tz = Timezone(tz)
            elif not isinstance(tz, (Timezone, FixedTimezone)):
                raise ValueError('tz argument must be a timezone instance or string')
    
>       self = super().__new__(
            cls, year, month, day, hour, minute, second, microsecond, tz
        )
E       TypeError: tzinfo argument must be None or of a tzinfo subclass, not type 'Timezone'

generation\Pendulum\pendulum\datetime.py:53: TypeError
________________________ test_diff_in_days_is_integer _________________________

    def test_diff_in_days_is_integer() -> None:
        """Compute diff in days between two dates."""
>       a = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:207: AttributeError
____________________ test_add_months_across_year_boundary _____________________

    def test_add_months_across_year_boundary() -> None:
        """Add months and verify year boundary transitions."""
>       dt = pendulum.date(2019, 12, 15)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:217: AttributeError
=========================== short test summary info ===========================
FAILED tests/Pendulum/functional_test.py::test_parse_and_timezone_conversion
FAILED tests/Pendulum/functional_test.py::test_datetime_arithmetic_and_duration
FAILED tests/Pendulum/functional_test.py::test_diff_for_humans_months - TypeE...
FAILED tests/Pendulum/functional_test.py::test_parse_date_only_to_date_string
FAILED tests/Pendulum/functional_test.py::test_datetime_to_iso8601_string_roundtrip
FAILED tests/Pendulum/functional_test.py::test_formatting_with_custom_pattern
FAILED tests/Pendulum/functional_test.py::test_start_of_end_of_day - TypeErro...
FAILED tests/Pendulum/functional_test.py::test_weekday_and_isoweekday_values
FAILED tests/Pendulum/functional_test.py::test_in_timezone_preserves_instant
FAILED tests/Pendulum/functional_test.py::test_diff_in_days_is_integer - Attr...
FAILED tests/Pendulum/functional_test.py::test_add_months_across_year_boundary
11 failed, 1 passed, 1 skipped in 20.68s
