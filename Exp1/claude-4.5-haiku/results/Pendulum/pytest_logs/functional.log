F.FFFFFF.sFFF                                                            [100%]
================================== FAILURES ===================================
_____________________ test_parse_and_timezone_conversion ______________________

    def test_parse_and_timezone_conversion() -> None:
        """Parse an ISO string and convert between timezones."""
        dt_utc = pendulum.parse("2020-01-01T12:00:00+00:00")
    
        assert dt_utc.year == 2020
        assert dt_utc.month == 1
        assert dt_utc.day == 1
    
        offset_utc = dt_utc.utcoffset()
        assert offset_utc is not None
        assert offset_utc.total_seconds() == 0
    
>       dt_tokyo = dt_utc.in_timezone("Asia/Tokyo")

tests\Pendulum\functional_test.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:28: in in_timezone
    converted = self.astimezone(tz)
generation\Pendulum\pendulum\timezone.py:24: in utcoffset
    return self._tz.utcoffset(dt)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\pytz\tzinfo.py:425: in utcoffset
    dt = self.localize(dt, is_dst)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DstTzInfo 'Asia/Tokyo' LMT+9:19:00 STD>
dt = DateTime(2020, 1, 1, 12, 0, 0, 0, tz='Asia/Tokyo'), is_dst = None

    def localize(self, dt, is_dst=False):
        '''Convert naive time to local time.
    
        This method should be used to construct localtimes, rather
        than passing a tzinfo argument to a datetime constructor.
    
        is_dst is used to determine the correct timezone in the ambigous
        period at the end of daylight saving time.
    
        >>> from pytz import timezone
        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'
        >>> amdam = timezone('Europe/Amsterdam')
        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)
        >>> loc_dt1 = amdam.localize(dt, is_dst=True)
        >>> loc_dt2 = amdam.localize(dt, is_dst=False)
        >>> loc_dt1.strftime(fmt)
        '2004-10-31 02:00:00 CEST (+0200)'
        >>> loc_dt2.strftime(fmt)
        '2004-10-31 02:00:00 CET (+0100)'
        >>> str(loc_dt2 - loc_dt1)
        '1:00:00'
    
        Use is_dst=None to raise an AmbiguousTimeError for ambiguous
        times at the end of daylight saving time
    
        >>> try:
        ...     loc_dt1 = amdam.localize(dt, is_dst=None)
        ... except AmbiguousTimeError:
        ...     print('Ambiguous')
        Ambiguous
    
        is_dst defaults to False
    
        >>> amdam.localize(dt) == amdam.localize(dt, False)
        True
    
        is_dst is also used to determine the correct timezone in the
        wallclock times jumped over at the start of daylight saving time.
    
        >>> pacific = timezone('US/Pacific')
        >>> dt = datetime(2008, 3, 9, 2, 0, 0)
        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)
        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)
        >>> ploc_dt1.strftime(fmt)
        '2008-03-09 02:00:00 PDT (-0700)'
        >>> ploc_dt2.strftime(fmt)
        '2008-03-09 02:00:00 PST (-0800)'
        >>> str(ploc_dt2 - ploc_dt1)
        '1:00:00'
    
        Use is_dst=None to raise a NonExistentTimeError for these skipped
        times.
    
        >>> try:
        ...     loc_dt1 = pacific.localize(dt, is_dst=None)
        ... except NonExistentTimeError:
        ...     print('Non-existent')
        Non-existent
        '''
        if dt.tzinfo is not None:
>           raise ValueError('Not naive datetime (tzinfo is already set)')
E           ValueError: Not naive datetime (tzinfo is already set)

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\pytz\tzinfo.py:321: ValueError
_________________________ test_diff_for_humans_months _________________________

    def test_diff_for_humans_months() -> None:
        """Human-readable differences between two datetimes."""
        start = pendulum.datetime(2011, 8, 1, tz="UTC")
>       end = start.add(months=1)

tests\Pendulum\functional_test.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = DateTime(2011, 8, 1, 0, 0, 0, 0, tz='UTC'), kwargs = {'months': 1}

    def add(self, **kwargs):
        """Add a duration to this datetime."""
>       duration = Duration(**kwargs)
E       TypeError: __new__() got an unexpected keyword argument 'months'

generation\Pendulum\pendulum\datetime.py:41: TypeError
_____________________ test_parse_date_only_to_date_string _____________________

    def test_parse_date_only_to_date_string() -> None:
        """Parse a date-only string and verify normalized date output."""
        d = pendulum.parse("2020-02-29")
        assert d.year == 2020
        assert d.month == 2
        assert d.day == 29
>       assert d.to_date_string() == "2020-02-29"
E       AttributeError: 'DateTime' object has no attribute 'to_date_string'

tests\Pendulum\functional_test.py:121: AttributeError
__________________ test_datetime_to_iso8601_string_roundtrip __________________

    def test_datetime_to_iso8601_string_roundtrip() -> None:
        """Create a datetime and verify ISO8601 string contains expected offset."""
        dt = pendulum.datetime(2020, 1, 1, 12, 0, 0, tz="UTC")
>       iso = dt.to_iso8601_string()
E       AttributeError: 'DateTime' object has no attribute 'to_iso8601_string'

tests\Pendulum\functional_test.py:127: AttributeError
_____________________ test_formatting_with_custom_pattern _____________________

    def test_formatting_with_custom_pattern() -> None:
        """Verify formatting with a custom pattern is stable for a fixed datetime."""
        dt = pendulum.datetime(2021, 12, 31, 23, 59, 58, tz="UTC")
        s = dt.format("YYYY/MM/DD HH:mm:ss")
>       assert s == "2021/12/31 23:59:58"
E       AssertionError: assert 'YYYY/MM/DD HH:mm:ss' == '2021/12/31 23:59:58'
E         
E         - 2021/12/31 23:59:58
E         + YYYY/MM/DD HH:mm:ss

tests\Pendulum\functional_test.py:137: AssertionError
__________________________ test_start_of_end_of_day ___________________________

    def test_start_of_end_of_day() -> None:
        """Check start_of and end_of for a day boundary."""
        dt = pendulum.datetime(2020, 5, 20, 13, 14, 15, tz="UTC")
    
>       sod = dt.start_of("day")
E       AttributeError: 'DateTime' object has no attribute 'start_of'

tests\Pendulum\functional_test.py:144: AttributeError
_____________________ test_weekday_and_isoweekday_values ______________________

    def test_weekday_and_isoweekday_values() -> None:
        """Validate weekday values for a known date (2020-01-01 is Wednesday)."""
>       dt = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:155: AttributeError
_____________________ test_in_timezone_preserves_instant ______________________

    def test_in_timezone_preserves_instant() -> None:
        """Converting timezones should preserve the instant (timestamp)."""
        dt_utc = pendulum.datetime(2020, 6, 1, 0, 0, 0, tz="UTC")
>       dt_ny = dt_utc.in_timezone("America/New_York")

tests\Pendulum\functional_test.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Pendulum\pendulum\datetime.py:28: in in_timezone
    converted = self.astimezone(tz)
generation\Pendulum\pendulum\timezone.py:24: in utcoffset
    return self._tz.utcoffset(dt)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\pytz\tzinfo.py:425: in utcoffset
    dt = self.localize(dt, is_dst)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DstTzInfo 'America/New_York' LMT-1 day, 19:04:00 STD>
dt = DateTime(2020, 6, 1, 0, 0, 0, 0, tz='America/New_York'), is_dst = None

    def localize(self, dt, is_dst=False):
        '''Convert naive time to local time.
    
        This method should be used to construct localtimes, rather
        than passing a tzinfo argument to a datetime constructor.
    
        is_dst is used to determine the correct timezone in the ambigous
        period at the end of daylight saving time.
    
        >>> from pytz import timezone
        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'
        >>> amdam = timezone('Europe/Amsterdam')
        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)
        >>> loc_dt1 = amdam.localize(dt, is_dst=True)
        >>> loc_dt2 = amdam.localize(dt, is_dst=False)
        >>> loc_dt1.strftime(fmt)
        '2004-10-31 02:00:00 CEST (+0200)'
        >>> loc_dt2.strftime(fmt)
        '2004-10-31 02:00:00 CET (+0100)'
        >>> str(loc_dt2 - loc_dt1)
        '1:00:00'
    
        Use is_dst=None to raise an AmbiguousTimeError for ambiguous
        times at the end of daylight saving time
    
        >>> try:
        ...     loc_dt1 = amdam.localize(dt, is_dst=None)
        ... except AmbiguousTimeError:
        ...     print('Ambiguous')
        Ambiguous
    
        is_dst defaults to False
    
        >>> amdam.localize(dt) == amdam.localize(dt, False)
        True
    
        is_dst is also used to determine the correct timezone in the
        wallclock times jumped over at the start of daylight saving time.
    
        >>> pacific = timezone('US/Pacific')
        >>> dt = datetime(2008, 3, 9, 2, 0, 0)
        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)
        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)
        >>> ploc_dt1.strftime(fmt)
        '2008-03-09 02:00:00 PDT (-0700)'
        >>> ploc_dt2.strftime(fmt)
        '2008-03-09 02:00:00 PST (-0800)'
        >>> str(ploc_dt2 - ploc_dt1)
        '1:00:00'
    
        Use is_dst=None to raise a NonExistentTimeError for these skipped
        times.
    
        >>> try:
        ...     loc_dt1 = pacific.localize(dt, is_dst=None)
        ... except NonExistentTimeError:
        ...     print('Non-existent')
        Non-existent
        '''
        if dt.tzinfo is not None:
>           raise ValueError('Not naive datetime (tzinfo is already set)')
E           ValueError: Not naive datetime (tzinfo is already set)

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\pytz\tzinfo.py:321: ValueError
________________________ test_diff_in_days_is_integer _________________________

    def test_diff_in_days_is_integer() -> None:
        """Compute diff in days between two dates."""
>       a = pendulum.date(2020, 1, 1)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:207: AttributeError
____________________ test_add_months_across_year_boundary _____________________

    def test_add_months_across_year_boundary() -> None:
        """Add months and verify year boundary transitions."""
>       dt = pendulum.date(2019, 12, 15)
E       AttributeError: module 'pendulum' has no attribute 'date'

tests\Pendulum\functional_test.py:217: AttributeError
=========================== short test summary info ===========================
FAILED tests/Pendulum/functional_test.py::test_parse_and_timezone_conversion
FAILED tests/Pendulum/functional_test.py::test_diff_for_humans_months - TypeE...
FAILED tests/Pendulum/functional_test.py::test_parse_date_only_to_date_string
FAILED tests/Pendulum/functional_test.py::test_datetime_to_iso8601_string_roundtrip
FAILED tests/Pendulum/functional_test.py::test_formatting_with_custom_pattern
FAILED tests/Pendulum/functional_test.py::test_start_of_end_of_day - Attribut...
FAILED tests/Pendulum/functional_test.py::test_weekday_and_isoweekday_values
FAILED tests/Pendulum/functional_test.py::test_in_timezone_preserves_instant
FAILED tests/Pendulum/functional_test.py::test_diff_in_days_is_integer - Attr...
FAILED tests/Pendulum/functional_test.py::test_add_months_across_year_boundary
10 failed, 2 passed, 1 skipped in 1.20s
