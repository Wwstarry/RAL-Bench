F                                                                        [100%]
================================== FAILURES ===================================
______________ test_generate_recurring_schedule_and_group_by_day ______________

    def test_generate_recurring_schedule_and_group_by_day() -> None:
        """
        Integration-style test: build a recurring schedule, convert to another
        timezone, and group events by local calendar day.
        """
        # Start from a fixed UTC anchor.
        start = pendulum.datetime(2022, 1, 1, 8, 0, 0, tz="UTC")
    
        # Create a small weekly schedule with three "meetings" per day.
        meetings_utc = []
        for day in range(7):
            for hour in (9, 13, 17):
                meetings_utc.append(start.add(days=day, hours=hour))
    
        tz_tokyo = pendulum.timezone("Asia/Tokyo")
>       meetings_local = [m.in_timezone(tz_tokyo) for m in meetings_utc]

tests\Pendulum\resource_test.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Pendulum\resource_test.py:47: in <listcomp>
    meetings_local = [m.in_timezone(tz_tokyo) for m in meetings_utc]
generation\Pendulum\pendulum\datetime.py:28: in in_timezone
    converted = self.astimezone(tz)
generation\Pendulum\pendulum\timezone.py:24: in utcoffset
    return self._tz.utcoffset(dt)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\pytz\tzinfo.py:425: in utcoffset
    dt = self.localize(dt, is_dst)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <DstTzInfo 'Asia/Tokyo' LMT+9:19:00 STD>
dt = DateTime(2022, 1, 1, 17, 0, 0, 0, tz='Asia/Tokyo'), is_dst = None

    def localize(self, dt, is_dst=False):
        '''Convert naive time to local time.
    
        This method should be used to construct localtimes, rather
        than passing a tzinfo argument to a datetime constructor.
    
        is_dst is used to determine the correct timezone in the ambigous
        period at the end of daylight saving time.
    
        >>> from pytz import timezone
        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'
        >>> amdam = timezone('Europe/Amsterdam')
        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)
        >>> loc_dt1 = amdam.localize(dt, is_dst=True)
        >>> loc_dt2 = amdam.localize(dt, is_dst=False)
        >>> loc_dt1.strftime(fmt)
        '2004-10-31 02:00:00 CEST (+0200)'
        >>> loc_dt2.strftime(fmt)
        '2004-10-31 02:00:00 CET (+0100)'
        >>> str(loc_dt2 - loc_dt1)
        '1:00:00'
    
        Use is_dst=None to raise an AmbiguousTimeError for ambiguous
        times at the end of daylight saving time
    
        >>> try:
        ...     loc_dt1 = amdam.localize(dt, is_dst=None)
        ... except AmbiguousTimeError:
        ...     print('Ambiguous')
        Ambiguous
    
        is_dst defaults to False
    
        >>> amdam.localize(dt) == amdam.localize(dt, False)
        True
    
        is_dst is also used to determine the correct timezone in the
        wallclock times jumped over at the start of daylight saving time.
    
        >>> pacific = timezone('US/Pacific')
        >>> dt = datetime(2008, 3, 9, 2, 0, 0)
        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)
        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)
        >>> ploc_dt1.strftime(fmt)
        '2008-03-09 02:00:00 PDT (-0700)'
        >>> ploc_dt2.strftime(fmt)
        '2008-03-09 02:00:00 PST (-0800)'
        >>> str(ploc_dt2 - ploc_dt1)
        '1:00:00'
    
        Use is_dst=None to raise a NonExistentTimeError for these skipped
        times.
    
        >>> try:
        ...     loc_dt1 = pacific.localize(dt, is_dst=None)
        ... except NonExistentTimeError:
        ...     print('Non-existent')
        Non-existent
        '''
        if dt.tzinfo is not None:
>           raise ValueError('Not naive datetime (tzinfo is already set)')
E           ValueError: Not naive datetime (tzinfo is already set)

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\pytz\tzinfo.py:321: ValueError
=========================== short test summary info ===========================
FAILED tests/Pendulum/resource_test.py::test_generate_recurring_schedule_and_group_by_day
1 failed in 0.79s
