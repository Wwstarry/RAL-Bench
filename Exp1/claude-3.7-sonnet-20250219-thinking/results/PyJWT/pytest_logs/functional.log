.F.FF...FFs                                                              [100%]
================================== FAILURES ===================================
_____________________ test_hs512_encode_decode_roundtrip ______________________

    def test_hs512_encode_decode_roundtrip() -> None:
        payload = {"scope": ["read", "write"], "active": True}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS512")

tests\PyJWT\functional_test.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

payload = {'active': True, 'scope': ['read', 'write']}, key = 'secret'
algorithm = 'HS512', kwargs = {}

    def encode(
        payload: Dict[str, Any],
        key: str,
        algorithm: str = "HS256",
        **kwargs
    ) -> str:
        """
        Encode a JWT with the given payload, key and algorithm.
    
        Args:
            payload: The JWT payload to encode.
            key: The secret key used for signing.
            algorithm: The algorithm to use for signing. Currently only HS256 is supported.
            **kwargs: Additional options (not used in this implementation).
    
        Returns:
            A string representing the encoded JWT.
        """
        if algorithm != "HS256":
>           raise NotImplementedError(f"Algorithm {algorithm} not supported")
E           NotImplementedError: Algorithm HS512 not supported

generation\PyJWT\jwt\api_jwt.py:41: NotImplementedError
_______________ test_encode_decode_with_datetime_exp_in_future ________________

    def test_encode_decode_with_datetime_exp_in_future() -> None:
        exp_dt = _fixed_dt_utc(2099, 1, 1, 0, 0, 0)
        payload = {"sub": "u-123", "exp": exp_dt}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS256")

tests\PyJWT\functional_test.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
generation\PyJWT\jwt\api_jwt.py:48: in encode
    payload_part = base64url_encode(json.dumps(payload, separators=(',', ':')).encode('utf-8'))
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x00000222DC077CD0>
o = datetime.datetime(2099, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
________________ test_encode_decode_with_datetime_nbf_in_past _________________

    def test_encode_decode_with_datetime_nbf_in_past() -> None:
        nbf_dt = _fixed_dt_utc(2000, 1, 1, 0, 0, 0)
        payload = {"feature": "enabled", "nbf": nbf_dt}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS256")

tests\PyJWT\functional_test.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
generation\PyJWT\jwt\api_jwt.py:48: in encode
    payload_part = base64url_encode(json.dumps(payload, separators=(',', ':')).encode('utf-8'))
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x00000222DC0918B0>
o = datetime.datetime(2000, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
_____________ test_unverified_header_contains_alg_and_custom_kid ______________

    def test_unverified_header_contains_alg_and_custom_kid() -> None:
        payload = {"foo": "bar"}
        key = "secret"
        token = _normalize_token(jwt.encode(payload, key, algorithm="HS256", headers={"kid": "k1", "typ": "JWT"}))
    
>       header = jwt.get_unverified_header(token)
E       AttributeError: module 'jwt' has no attribute 'get_unverified_header'

tests\PyJWT\functional_test.py:210: AttributeError
_________________________ test_decode_with_bytes_key __________________________

    def test_decode_with_bytes_key() -> None:
        payload = {"user": "bob", "plan": "pro"}
        key = b"secret-bytes"
>       decoded = _encode_decode(payload, key=key, algorithm="HS256")

tests\PyJWT\functional_test.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

payload = {'plan': 'pro', 'user': 'bob'}, key = b'secret-bytes'
algorithm = 'HS256', kwargs = {}, header = {'alg': 'HS256', 'typ': 'JWT'}
header_part = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9'
payload_part = 'eyJ1c2VyIjoiYm9iIiwicGxhbiI6InBybyJ9'
message = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYm9iIiwicGxhbiI6InBybyJ9'

    def encode(
        payload: Dict[str, Any],
        key: str,
        algorithm: str = "HS256",
        **kwargs
    ) -> str:
        """
        Encode a JWT with the given payload, key and algorithm.
    
        Args:
            payload: The JWT payload to encode.
            key: The secret key used for signing.
            algorithm: The algorithm to use for signing. Currently only HS256 is supported.
            **kwargs: Additional options (not used in this implementation).
    
        Returns:
            A string representing the encoded JWT.
        """
        if algorithm != "HS256":
            raise NotImplementedError(f"Algorithm {algorithm} not supported")
    
        # Create the header
        header = {"typ": "JWT", "alg": algorithm}
    
        # Encode header and payload
        header_part = base64url_encode(json.dumps(header, separators=(',', ':')).encode('utf-8'))
        payload_part = base64url_encode(json.dumps(payload, separators=(',', ':')).encode('utf-8'))
    
        # Create the message to sign
        message = f"{header_part}.{payload_part}"
    
        # Sign the message with HMAC-SHA256
        signature = hmac.new(
>           key.encode('utf-8'),
            message.encode('utf-8'),
            hashlib.sha256
        ).digest()
E       AttributeError: 'bytes' object has no attribute 'encode'

generation\PyJWT\jwt\api_jwt.py:55: AttributeError
=========================== short test summary info ===========================
FAILED tests/PyJWT/functional_test.py::test_hs512_encode_decode_roundtrip - N...
FAILED tests/PyJWT/functional_test.py::test_encode_decode_with_datetime_exp_in_future
FAILED tests/PyJWT/functional_test.py::test_encode_decode_with_datetime_nbf_in_past
FAILED tests/PyJWT/functional_test.py::test_unverified_header_contains_alg_and_custom_kid
FAILED tests/PyJWT/functional_test.py::test_decode_with_bytes_key - Attribute...
5 failed, 5 passed, 1 skipped in 0.58s
