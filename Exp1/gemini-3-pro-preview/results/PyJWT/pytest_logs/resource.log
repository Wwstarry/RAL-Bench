FF.                                                                      [100%]
================================== FAILURES ===================================
_____________________________ test_verify_options _____________________________

    def test_verify_options() -> None:
        """Decoding with verify_exp=True should accept non-expired tokens."""
        key = "secret"
        payload = {
            "foo": "bar",
            "exp": datetime.now(tz=timezone.utc) + timedelta(seconds=10),
        }
    
>       token = jwt.encode(payload, key, algorithm="HS256")

tests\PyJWT\resource_test.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyJWT\jwt\__init__.py:10: in encode
    return _jwt_global.encode(payload, key, algorithm, **kwargs)
generation\PyJWT\jwt\api_jwt.py:32: in encode
    payload_json = json.dumps(payload, separators=(',', ':')).encode('utf-8')
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000001F7A9B673A0>
o = datetime.datetime(2025, 12, 31, 8, 58, 33, 113730, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
_________________________________ test_leeway _________________________________

    def test_leeway() -> None:
        """Leeway should allow slightly expired tokens to still be accepted."""
        key = "secret"
        expired = datetime.now(tz=timezone.utc) - timedelta(seconds=2)
    
>       token = jwt.encode({"exp": expired}, key, algorithm="HS256")

tests\PyJWT\resource_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\PyJWT\jwt\__init__.py:10: in encode
    return _jwt_global.encode(payload, key, algorithm, **kwargs)
generation\PyJWT\jwt\api_jwt.py:32: in encode
    payload_json = json.dumps(payload, separators=(',', ':')).encode('utf-8')
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000001F7A9B410A0>
o = datetime.datetime(2025, 12, 31, 8, 58, 21, 437004, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
=========================== short test summary info ===========================
FAILED tests/PyJWT/resource_test.py::test_verify_options - TypeError: Object ...
FAILED tests/PyJWT/resource_test.py::test_leeway - TypeError: Object of type ...
2 failed, 1 passed in 0.55s
