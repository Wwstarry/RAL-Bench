project_name: Astral
task_file: D:\桌面\RealAppCodeBench_generic_eval\tasks\Astral\astral.yaml
generated_repo: D:\桌面\RealAppCodeBench_generic_eval\generation\Astral
timestamp: '2026-01-01 18:29:34'
functional_score: 0.5455
non_functional_score: 0.7322
non_functional_subscores:
  maintainability: 0.9227
  security: 1.0
  robustness: 1.0
  performance: 0.0
  resource: 0.0
non_functional_weights:
  maintainability: 0.36
  security: 0.24
  robustness: 0.16
  performance: 0.12
  resource: 0.12
results:
  functional:
    returncode: 1
    stdout: "FF...FFF...                                                         \
      \     [100%]\n================================== FAILURES ===================================\n\
      _________________________ test_sun_times_basic_sanity _________________________\n\
      \n    def test_sun_times_basic_sanity() -> None:\n        \"\"\"sun() returns\
      \ expected keys and times are in a plausible order.\"\"\"\n        loc = _london_location()\n\
      \        d = dt.date(2020, 6, 1)\n    \n>       s = sun(_observer_from_location(loc),\
      \ date=d, tzinfo=_safe_tzinfo())\n\ntests\\Astral\\functional_test.py:116: \n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\n\nobserver = <astral.locationinfo.Observer object at 0x0000024DA5B84F70>\n\
      date = datetime.date(2020, 6, 1), tzinfo = datetime.timezone.utc\n\n    def\
      \ sun(observer, date=None, tzinfo=None):\n        \"\"\"Calculate all sun-related\
      \ values for a date.\n    \n        Args:\n            observer: LocationInfo\
      \ observer attribute or similar\n            date: The date for which to calculate\
      \ the times. Default is today.\n            tzinfo: The timezone to use for\
      \ the returned times.\n    \n        Returns:\n            A dictionary with\
      \ keys 'dawn', 'sunrise', 'noon', 'sunset', 'dusk'\n            containing the\
      \ respective times as datetime objects.\n        \"\"\"\n        if date is\
      \ None:\n            date = datetime.date.today()\n    \n        if tzinfo is\
      \ None:\n            tzinfo = datetime.timezone.utc\n    \n        # Sunrise/sunset\
      \ zenith adjusted for elevation\n        sunrise_sunset_zenith = 90 + _adjust_to_horizon(observer.elevation)\n\
      \    \n        # Civil dawn/dusk zenith angle (6 degrees below horizon)\n  \
      \      dawn_dusk_zenith = 96  # 90 + 6\n    \n        # Calculate times\n> \
      \      sunrise, sunset, noon = _calculate_sunrise_sunset(observer, date, tzinfo,\
      \ sunrise_sunset_zenith)\nE       ValueError: not enough values to unpack (expected\
      \ 3, got 2)\n\ngeneration\\Astral\\astral\\sun.py:181: ValueError\n______________________\
      \ test_sun_time_changes_across_days ______________________\n\n    def test_sun_time_changes_across_days()\
      \ -> None:\n        \"\"\"Sunrise and sunset should change slightly between\
      \ consecutive days.\"\"\"\n        loc = _london_location()\n        d1 = dt.date(2020,\
      \ 1, 1)\n        d2 = d1 + dt.timedelta(days=1)\n    \n>       s1 = sun(_observer_from_location(loc),\
      \ date=d1, tzinfo=_safe_tzinfo())\n\ntests\\Astral\\functional_test.py:131:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nobserver = <astral.locationinfo.Observer object at 0x0000024DA457ADC0>\n\
      date = datetime.date(2020, 1, 1), tzinfo = datetime.timezone.utc\n\n    def\
      \ sun(observer, date=None, tzinfo=None):\n        \"\"\"Calculate all sun-related\
      \ values for a date.\n    \n        Args:\n            observer: LocationInfo\
      \ observer attribute or similar\n            date: The date for which to calculate\
      \ the times. Default is today.\n            tzinfo: The timezone to use for\
      \ the returned times.\n    \n        Returns:\n            A dictionary with\
      \ keys 'dawn', 'sunrise', 'noon', 'sunset', 'dusk'\n            containing the\
      \ respective times as datetime objects.\n        \"\"\"\n        if date is\
      \ None:\n            date = datetime.date.today()\n    \n        if tzinfo is\
      \ None:\n            tzinfo = datetime.timezone.utc\n    \n        # Sunrise/sunset\
      \ zenith adjusted for elevation\n        sunrise_sunset_zenith = 90 + _adjust_to_horizon(observer.elevation)\n\
      \    \n        # Civil dawn/dusk zenith angle (6 degrees below horizon)\n  \
      \      dawn_dusk_zenith = 96  # 90 + 6\n    \n        # Calculate times\n> \
      \      sunrise, sunset, noon = _calculate_sunrise_sunset(observer, date, tzinfo,\
      \ sunrise_sunset_zenith)\nE       ValueError: not enough values to unpack (expected\
      \ 3, got 2)\n\ngeneration\\Astral\\astral\\sun.py:181: ValueError\n_________________________\
      \ test_sun_returns_datetimes __________________________\n\n    def test_sun_returns_datetimes()\
      \ -> None:\n        loc = _london_location()\n        d = dt.date(2020, 6, 1)\n\
      >       s = sun(_observer_from_location(loc), date=d, tzinfo=_safe_tzinfo())\n\
      \ntests\\Astral\\functional_test.py:185: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nobserver = <astral.locationinfo.Observer\
      \ object at 0x0000024DA5B92310>\ndate = datetime.date(2020, 6, 1), tzinfo =\
      \ datetime.timezone.utc\n\n    def sun(observer, date=None, tzinfo=None):\n\
      \        \"\"\"Calculate all sun-related values for a date.\n    \n        Args:\n\
      \            observer: LocationInfo observer attribute or similar\n        \
      \    date: The date for which to calculate the times. Default is today.\n  \
      \          tzinfo: The timezone to use for the returned times.\n    \n     \
      \   Returns:\n            A dictionary with keys 'dawn', 'sunrise', 'noon',\
      \ 'sunset', 'dusk'\n            containing the respective times as datetime\
      \ objects.\n        \"\"\"\n        if date is None:\n            date = datetime.date.today()\n\
      \    \n        if tzinfo is None:\n            tzinfo = datetime.timezone.utc\n\
      \    \n        # Sunrise/sunset zenith adjusted for elevation\n        sunrise_sunset_zenith\
      \ = 90 + _adjust_to_horizon(observer.elevation)\n    \n        # Civil dawn/dusk\
      \ zenith angle (6 degrees below horizon)\n        dawn_dusk_zenith = 96  # 90\
      \ + 6\n    \n        # Calculate times\n>       sunrise, sunset, noon = _calculate_sunrise_sunset(observer,\
      \ date, tzinfo, sunrise_sunset_zenith)\nE       ValueError: not enough values\
      \ to unpack (expected 3, got 2)\n\ngeneration\\Astral\\astral\\sun.py:181: ValueError\n\
      _________________ test_sun_noon_is_between_sunrise_and_sunset _________________\n\
      \n    def test_sun_noon_is_between_sunrise_and_sunset() -> None:\n        loc\
      \ = _london_location()\n        d = dt.date(2020, 3, 1)\n>       s = sun(_observer_from_location(loc),\
      \ date=d, tzinfo=_safe_tzinfo())\n\ntests\\Astral\\functional_test.py:196: \n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\n\nobserver = <astral.locationinfo.Observer object at 0x0000024DA5B74880>\n\
      date = datetime.date(2020, 3, 1), tzinfo = datetime.timezone.utc\n\n    def\
      \ sun(observer, date=None, tzinfo=None):\n        \"\"\"Calculate all sun-related\
      \ values for a date.\n    \n        Args:\n            observer: LocationInfo\
      \ observer attribute or similar\n            date: The date for which to calculate\
      \ the times. Default is today.\n            tzinfo: The timezone to use for\
      \ the returned times.\n    \n        Returns:\n            A dictionary with\
      \ keys 'dawn', 'sunrise', 'noon', 'sunset', 'dusk'\n            containing the\
      \ respective times as datetime objects.\n        \"\"\"\n        if date is\
      \ None:\n            date = datetime.date.today()\n    \n        if tzinfo is\
      \ None:\n            tzinfo = datetime.timezone.utc\n    \n        # Sunrise/sunset\
      \ zenith adjusted for elevation\n        sunrise_sunset_zenith = 90 + _adjust_to_horizon(observer.elevation)\n\
      \    \n        # Civil dawn/dusk zenith angle (6 degrees below horizon)\n  \
      \      dawn_dusk_zenith = 96  # 90 + 6\n    \n        # Calculate times\n> \
      \      sunrise, sunset, noon = _calculate_sunrise_sunset(observer, date, tzinfo,\
      \ sunrise_sunset_zenith)\nE       ValueError: not enough values to unpack (expected\
      \ 3, got 2)\n\ngeneration\\Astral\\astral\\sun.py:181: ValueError\n_______ test_sun_times_differ_between_locations_same_date_or_one_raises\
      \ _______\n\n    def test_sun_times_differ_between_locations_same_date_or_one_raises()\
      \ -> None:\n        \"\"\"\n        Some generated implementations have edge-case\
      \ bugs for certain longitudes that can\n        yield out-of-range hours (e.g.,\
      \ hour < 0 or > 23) and raise ValueError.\n        This test remains targeted\
      \ (different locations) while being compatible across\n        implementations\
      \ by accepting either:\n          - both computations succeed and differ, OR\n\
      \          - one implementation raises a clear exception for the second location.\n\
      \        \"\"\"\n        london = _london_location()\n        nyc = _new_york_location()\n\
      \        d = dt.date(2020, 6, 1)\n    \n>       s_l = sun(_observer_from_location(london),\
      \ date=d, tzinfo=_safe_tzinfo())\n\ntests\\Astral\\functional_test.py:213: \n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\n\nobserver = <astral.locationinfo.Observer object at 0x0000024DA5B6C880>\n\
      date = datetime.date(2020, 6, 1), tzinfo = datetime.timezone.utc\n\n    def\
      \ sun(observer, date=None, tzinfo=None):\n        \"\"\"Calculate all sun-related\
      \ values for a date.\n    \n        Args:\n            observer: LocationInfo\
      \ observer attribute or similar\n            date: The date for which to calculate\
      \ the times. Default is today.\n            tzinfo: The timezone to use for\
      \ the returned times.\n    \n        Returns:\n            A dictionary with\
      \ keys 'dawn', 'sunrise', 'noon', 'sunset', 'dusk'\n            containing the\
      \ respective times as datetime objects.\n        \"\"\"\n        if date is\
      \ None:\n            date = datetime.date.today()\n    \n        if tzinfo is\
      \ None:\n            tzinfo = datetime.timezone.utc\n    \n        # Sunrise/sunset\
      \ zenith adjusted for elevation\n        sunrise_sunset_zenith = 90 + _adjust_to_horizon(observer.elevation)\n\
      \    \n        # Civil dawn/dusk zenith angle (6 degrees below horizon)\n  \
      \      dawn_dusk_zenith = 96  # 90 + 6\n    \n        # Calculate times\n> \
      \      sunrise, sunset, noon = _calculate_sunrise_sunset(observer, date, tzinfo,\
      \ sunrise_sunset_zenith)\nE       ValueError: not enough values to unpack (expected\
      \ 3, got 2)\n\ngeneration\\Astral\\astral\\sun.py:181: ValueError\n===========================\
      \ short test summary info ===========================\nFAILED tests/Astral/functional_test.py::test_sun_times_basic_sanity\
      \ - ValueEr...\nFAILED tests/Astral/functional_test.py::test_sun_time_changes_across_days\
      \ - V...\nFAILED tests/Astral/functional_test.py::test_sun_returns_datetimes\
      \ - ValueErr...\nFAILED tests/Astral/functional_test.py::test_sun_noon_is_between_sunrise_and_sunset\n\
      FAILED tests/Astral/functional_test.py::test_sun_times_differ_between_locations_same_date_or_one_raises\n\
      5 failed, 6 passed in 0.48s\n"
    elapsed_time_s: 1.650895
    avg_memory_mb: 32.9
    avg_cpu_percent: 90.9
    passed: 6
    failed: 5
    skipped: 0
    total: 11
    score_inputs_passed: 6
    score_inputs_failed: 5
    score_inputs_total: 11
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - functional_suite_time_s
    - functional_tests_total
  performance:
    returncode: 1
    stdout: "F                                                                   \
      \     [100%]\n================================== FAILURES ===================================\n\
      ________________________ test_astral_performance_smoke ________________________\n\
      \n    def test_astral_performance_smoke() -> None:\n        \"\"\"Smoke test\
      \ to ensure the performance benchmark runs successfully.\"\"\"\n>       metrics\
      \ = run_astral_performance_benchmark(iterations=5, days=10)\n\ntests\\Astral\\\
      performance_test.py:75: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\Astral\\performance_test.py:60: in run_astral_performance_benchmark\n\
      \    _ = sun(loc.observer, date=d, tzinfo=loc.timezone)\n_ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nobserver =\
      \ <astral.locationinfo.Observer object at 0x000001A3F94D12E0>\ndate = datetime.date(2020,\
      \ 1, 1), tzinfo = 'Europe/London'\n\n    def sun(observer, date=None, tzinfo=None):\n\
      \        \"\"\"Calculate all sun-related values for a date.\n    \n        Args:\n\
      \            observer: LocationInfo observer attribute or similar\n        \
      \    date: The date for which to calculate the times. Default is today.\n  \
      \          tzinfo: The timezone to use for the returned times.\n    \n     \
      \   Returns:\n            A dictionary with keys 'dawn', 'sunrise', 'noon',\
      \ 'sunset', 'dusk'\n            containing the respective times as datetime\
      \ objects.\n        \"\"\"\n        if date is None:\n            date = datetime.date.today()\n\
      \    \n        if tzinfo is None:\n            tzinfo = datetime.timezone.utc\n\
      \    \n        # Sunrise/sunset zenith adjusted for elevation\n        sunrise_sunset_zenith\
      \ = 90 + _adjust_to_horizon(observer.elevation)\n    \n        # Civil dawn/dusk\
      \ zenith angle (6 degrees below horizon)\n        dawn_dusk_zenith = 96  # 90\
      \ + 6\n    \n        # Calculate times\n>       sunrise, sunset, noon = _calculate_sunrise_sunset(observer,\
      \ date, tzinfo, sunrise_sunset_zenith)\nE       ValueError: not enough values\
      \ to unpack (expected 3, got 2)\n\ngeneration\\Astral\\astral\\sun.py:181: ValueError\n\
      =========================== short test summary info ===========================\n\
      FAILED tests/Astral/performance_test.py::test_astral_performance_smoke - Valu...\n\
      1 failed in 0.31s\n"
    elapsed_time_s: 1.456599
    avg_memory_mb: 31.39
    avg_cpu_percent: 100.0
    passed: 0
    failed: 1
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 1
    score_inputs_total: 1
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - performance_suite_time_s
    - performance_tests_total
    score_inputs_baseline_time_s: 1.209133
    score_inputs_actual_time_s: 1.456599
  resource:
    returncode: 1
    stdout: "F                                                                   \
      \     [100%]\n================================== FAILURES ===================================\n\
      __________________________ test_resource_usage_smoke __________________________\n\
      \n    def test_resource_usage_smoke() -> None:\n        \"\"\"\n        Smoke\
      \ test: run a representative batch workload and verify\n        we can observe\
      \ process resource info without crashing.\n    \n        Note: The benchmark\
      \ runner measures subprocess resources.\n        This test is correctness-oriented\
      \ only.\n        \"\"\"\n        proc = psutil.Process()\n        rss_before\
      \ = proc.memory_info().rss\n    \n        loc = _london_location()\n       \
      \ base_date = dt.date(2020, 1, 1)\n    \n        for offset in range(60):\n\
      \            d = base_date + dt.timedelta(days=offset)\n>           _ = sun(loc.observer,\
      \ date=d, tzinfo=loc.timezone)\n\ntests\\Astral\\resource_test.py:65: \n_ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _\n\nobserver = <astral.locationinfo.Observer object at 0x0000020515F7EFA0>\n\
      date = datetime.date(2020, 1, 1), tzinfo = 'Europe/London'\n\n    def sun(observer,\
      \ date=None, tzinfo=None):\n        \"\"\"Calculate all sun-related values for\
      \ a date.\n    \n        Args:\n            observer: LocationInfo observer\
      \ attribute or similar\n            date: The date for which to calculate the\
      \ times. Default is today.\n            tzinfo: The timezone to use for the\
      \ returned times.\n    \n        Returns:\n            A dictionary with keys\
      \ 'dawn', 'sunrise', 'noon', 'sunset', 'dusk'\n            containing the respective\
      \ times as datetime objects.\n        \"\"\"\n        if date is None:\n   \
      \         date = datetime.date.today()\n    \n        if tzinfo is None:\n \
      \           tzinfo = datetime.timezone.utc\n    \n        # Sunrise/sunset zenith\
      \ adjusted for elevation\n        sunrise_sunset_zenith = 90 + _adjust_to_horizon(observer.elevation)\n\
      \    \n        # Civil dawn/dusk zenith angle (6 degrees below horizon)\n  \
      \      dawn_dusk_zenith = 96  # 90 + 6\n    \n        # Calculate times\n> \
      \      sunrise, sunset, noon = _calculate_sunrise_sunset(observer, date, tzinfo,\
      \ sunrise_sunset_zenith)\nE       ValueError: not enough values to unpack (expected\
      \ 3, got 2)\n\ngeneration\\Astral\\astral\\sun.py:181: ValueError\n===========================\
      \ short test summary info ===========================\nFAILED tests/Astral/resource_test.py::test_resource_usage_smoke\
      \ - ValueError:...\n1 failed in 0.35s\n"
    elapsed_time_s: 1.527043
    avg_memory_mb: 34.09
    avg_cpu_percent: 98.9
    passed: 0
    failed: 1
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 1
    score_inputs_total: 1
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - avg_cpu_percent
    - avg_memory_mb
    - resource_suite_time_s
    - resource_tests_total
    score_inputs_baseline_mem_mb: 33.35
    score_inputs_baseline_cpu_pct: 104.2
    score_inputs_actual_mem_mb: 34.09
    score_inputs_actual_cpu_pct: 98.9
  robustness:
    returncode: 0
    stdout: '...                                                                      [100%]

      3 passed in 0.10s

      '
    elapsed_time_s: 1.237329
    avg_memory_mb: 30.59
    avg_cpu_percent: 100.0
    passed: 3
    failed: 0
    skipped: 0
    total: 3
    score_inputs_passed: 3
    score_inputs_failed: 0
    score_inputs_total: 3
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - robustness_suite_time_s
    - robustness_tests_total
  security:
    returncode: 0
    stdout: 'SECURITY_METRICS high_risk_count=0.0 files_scanned=4.0 total_loc=190.0

      .

      1 passed in 0.09s

      '
    elapsed_time_s: 1.180917
    avg_memory_mb: 31.45
    avg_cpu_percent: 101.5
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 4.0
      total_loc: 190.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - metrics
    - security_suite_time_s
    - security_tests_total
    score_inputs_baseline_high_risk_count: 0.0
    score_inputs_generated_high_risk_count: 0.0
  maintainability:
    returncode: 0
    stdout: 'MAINT_METRICS mi_min=25.8607 files_scanned=4.0 total_loc=190.0 max_cc=9.0

      .

      1 passed in 0.12s

      '
    elapsed_time_s: 1.211119
    avg_memory_mb: 31.45
    avg_cpu_percent: 105.7
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      mi_min: 25.8607
      files_scanned: 4.0
      total_loc: 190.0
      max_cc: 9.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - maintainability_suite_time_s
    - maintainability_tests_total
    - metrics
    score_inputs_baseline_mi_min: 2.1658
    score_inputs_generated_mi_min: 25.8607
    score_inputs_ratio_g_over_b: 11.940483885862038
baseline_metrics:
  functional:
    functional_suite_time_s: 1.258826
    functional_tests_total: 11
  performance:
    performance_suite_time_s: 1.209133
    performance_tests_total: 1
  resource:
    resource_suite_time_s: 1.220496
    resource_tests_total: 1
    avg_memory_mb: 33.35
    avg_cpu_percent: 104.2
  robustness:
    robustness_suite_time_s: 1.213882
    robustness_tests_total: 3
  security:
    security_suite_time_s: 1.42552
    security_tests_total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 36.0
      total_loc: 4949.0
  maintainability:
    maintainability_suite_time_s: 1.668661
    maintainability_tests_total: 1
    metrics:
      mi_min: 2.1658
      files_scanned: 36.0
      total_loc: 4949.0
      max_cc: 20.0
pytest_logs_dir: D:\桌面\RealAppCodeBench_generic_eval\results\Astral\pytest_logs
