project_name: Lifelines
task_file: D:\桌面\RealAppCodeBench_generic_eval\tasks\Lifelines\lifelines.yaml
generated_repo: D:\桌面\RealAppCodeBench_generic_eval\generation\Lifelines
timestamp: '2026-01-01 13:20:28'
functional_score: 0.2667
non_functional_score: 0.52
non_functional_subscores:
  maintainability: 0.0
  security: 1.0
  robustness: 1.0
  performance: 1.0
  resource: 0.0
non_functional_weights:
  maintainability: 0.36
  security: 0.24
  robustness: 0.16
  performance: 0.12
  resource: 0.12
results:
  functional:
    returncode: 1
    stdout: "..F..FFFFFFFFFF                                                     \
      \     [100%]\n================================== FAILURES ===================================\n\
      ____________________________ test_coxph_basic_fit _____________________________\n\
      \n    def test_coxph_basic_fit() -> None:\n        \"\"\"Fit a simple Cox proportional\
      \ hazards model on a toy dataset.\"\"\"\n        df = _toy_cox_df()\n    \n\
      \        cph = CoxPHFitter()\n>       cph.fit(df, duration_col=\"duration\"\
      , event_col=\"event\")\n\ntests\\Lifelines\\functional_test.py:122: \n_ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\
      \nself = <lifelines.fitters.CoxPHFitter object at 0x0000018B20D98AF0>\ndf =\
      \    duration  event  age  treatment\n0         5      1   30          0\n1\
      \         6      0   40          0\n2         6  ... 60          1\n5      \
      \   3      0   35          0\n6         8      1   45          1\n7        \
      \ 7      1   55          0\nduration_col = 'duration', event_col = 'event',\
      \ show_progress = False\n\n    def fit(self, df, duration_col, event_col, show_progress=False):\n\
      \        # Only numeric covariates supported\n        X = df.drop([duration_col,\
      \ event_col], axis=1)\n        X = X.astype(float)\n        T = df[duration_col].values\n\
      \        E = df[event_col].values.astype(int)\n        n, p = X.shape\n    \
      \    self._X_cols = list(X.columns)\n        # Sort by time ascending\n    \
      \    order = np.argsort(T)\n        T = T[order]\n        E = E[order]\n   \
      \     X = X.values[order, :]\n    \n        # Newton-Raphson for partial likelihood\n\
      \        beta = np.zeros(p)\n        max_iter = 50\n        tol = 1e-7\n   \
      \     for it in range(max_iter):\n            risk_scores = np.exp(np.dot(X,\
      \ beta))\n            # For each subject, compute risk set sum\n           \
      \ # Breslow: for each event time, sum over those at risk\n            # Compute\
      \ log-likelihood, gradient, Hessian\n            loglik = 0.0\n            grad\
      \ = np.zeros(p)\n            hess = np.zeros((p, p))\n            for i in range(n):\n\
      \                if E[i] == 1:\n                    xi = X[i]\n            \
      \        ti = T[i]\n                    at_risk = (T >= ti)\n              \
      \      rs_sum = np.sum(risk_scores[at_risk])\n                    loglik +=\
      \ np.dot(beta, xi) - np.log(rs_sum)\n                    grad += xi - np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    xbar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    x2bar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]**2) / rs_sum\n                    hess -= np.outer(xbar, xbar)\n\
      >                   hess += np.dot(risk_scores[at_risk], X[at_risk][:, :, None]\
      \ * X[at_risk][:, None, :]) / rs_sum\nE                   ValueError: shapes\
      \ (8,) and (8,2,2) not aligned: 8 (dim 0) != 2 (dim 1)\n\ngeneration\\Lifelines\\\
      lifelines\\fitters.py:142: ValueError\n________________ test_kmf_cumulative_density_is_non_decreasing\
      \ ________________\n\n    def test_kmf_cumulative_density_is_non_decreasing()\
      \ -> None:\n        \"\"\"Cumulative density should be non-decreasing and within\
      \ [0, 1].\"\"\"\n        durations, events = _toy_kmf_data()\n        kmf =\
      \ KaplanMeierFitter().fit(durations=durations, event_observed=events, label=\"\
      km\")\n>       cd = kmf.cumulative_density_\nE       AttributeError: 'KaplanMeierFitter'\
      \ object has no attribute 'cumulative_density_'\n\ntests\\Lifelines\\functional_test.py:170:\
      \ AttributeError\n__________________ test_kmf_event_table_has_standard_columns\
      \ __________________\n\n    def test_kmf_event_table_has_standard_columns()\
      \ -> None:\n        \"\"\"KM event table should include standard bookkeeping\
      \ columns.\"\"\"\n        durations, events = _toy_kmf_data()\n        kmf =\
      \ KaplanMeierFitter().fit(durations=durations, event_observed=events, label=\"\
      km\")\n>       et = kmf.event_table\nE       AttributeError: 'KaplanMeierFitter'\
      \ object has no attribute 'event_table'\n\ntests\\Lifelines\\functional_test.py:183:\
      \ AttributeError\n_____________ test_kmf_confidence_interval_matches_survival_index\
      \ _____________\n\n    def test_kmf_confidence_interval_matches_survival_index()\
      \ -> None:\n        \"\"\"Confidence intervals should align with survival function\
      \ index.\"\"\"\n        durations, events = _toy_kmf_data()\n        kmf = KaplanMeierFitter().fit(durations=durations,\
      \ event_observed=events, label=\"km\")\n>       ci = kmf.confidence_interval_\n\
      E       AttributeError: 'KaplanMeierFitter' object has no attribute 'confidence_interval_'\n\
      \ntests\\Lifelines\\functional_test.py:192: AttributeError\n___________ test_kmf_median_survival_time_is_within_duration_range\
      \ ____________\n\n    def test_kmf_median_survival_time_is_within_duration_range()\
      \ -> None:\n        \"\"\"Median survival time should be within the observed\
      \ duration range.\"\"\"\n        durations, events = _toy_kmf_data()\n     \
      \   kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events,\
      \ label=\"km\")\n    \n>       m = float(kmf.median_survival_time_)\nE     \
      \  AttributeError: 'KaplanMeierFitter' object has no attribute 'median_survival_time_'\n\
      \ntests\\Lifelines\\functional_test.py:206: AttributeError\n_________________\
      \ test_coxph_params_index_matches_covariates __________________\n\n    def test_coxph_params_index_matches_covariates()\
      \ -> None:\n        \"\"\"Cox model params_ should be indexed by covariate names.\"\
      \"\"\n        df = _toy_cox_df()\n>       cph = CoxPHFitter().fit(df, duration_col=\"\
      duration\", event_col=\"event\")\n\ntests\\Lifelines\\functional_test.py:213:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nself = <lifelines.fitters.CoxPHFitter object at 0x0000018B20DCC8B0>\n\
      df =    duration  event  age  treatment\n0         5      1   30          0\n\
      1         6      0   40          0\n2         6  ... 60          1\n5      \
      \   3      0   35          0\n6         8      1   45          1\n7        \
      \ 7      1   55          0\nduration_col = 'duration', event_col = 'event',\
      \ show_progress = False\n\n    def fit(self, df, duration_col, event_col, show_progress=False):\n\
      \        # Only numeric covariates supported\n        X = df.drop([duration_col,\
      \ event_col], axis=1)\n        X = X.astype(float)\n        T = df[duration_col].values\n\
      \        E = df[event_col].values.astype(int)\n        n, p = X.shape\n    \
      \    self._X_cols = list(X.columns)\n        # Sort by time ascending\n    \
      \    order = np.argsort(T)\n        T = T[order]\n        E = E[order]\n   \
      \     X = X.values[order, :]\n    \n        # Newton-Raphson for partial likelihood\n\
      \        beta = np.zeros(p)\n        max_iter = 50\n        tol = 1e-7\n   \
      \     for it in range(max_iter):\n            risk_scores = np.exp(np.dot(X,\
      \ beta))\n            # For each subject, compute risk set sum\n           \
      \ # Breslow: for each event time, sum over those at risk\n            # Compute\
      \ log-likelihood, gradient, Hessian\n            loglik = 0.0\n            grad\
      \ = np.zeros(p)\n            hess = np.zeros((p, p))\n            for i in range(n):\n\
      \                if E[i] == 1:\n                    xi = X[i]\n            \
      \        ti = T[i]\n                    at_risk = (T >= ti)\n              \
      \      rs_sum = np.sum(risk_scores[at_risk])\n                    loglik +=\
      \ np.dot(beta, xi) - np.log(rs_sum)\n                    grad += xi - np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    xbar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    x2bar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]**2) / rs_sum\n                    hess -= np.outer(xbar, xbar)\n\
      >                   hess += np.dot(risk_scores[at_risk], X[at_risk][:, :, None]\
      \ * X[at_risk][:, None, :]) / rs_sum\nE                   ValueError: shapes\
      \ (8,) and (8,2,2) not aligned: 8 (dim 0) != 2 (dim 1)\n\ngeneration\\Lifelines\\\
      lifelines\\fitters.py:142: ValueError\n___________ test_coxph_baseline_cumulative_hazard_is_non_decreasing\
      \ ___________\n\n    def test_coxph_baseline_cumulative_hazard_is_non_decreasing()\
      \ -> None:\n        \"\"\"Baseline cumulative hazard should be non-decreasing\
      \ over time.\"\"\"\n        df = _toy_cox_df()\n>       cph = CoxPHFitter().fit(df,\
      \ duration_col=\"duration\", event_col=\"event\")\n\ntests\\Lifelines\\functional_test.py:223:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nself = <lifelines.fitters.CoxPHFitter object at 0x0000018B20E53820>\n\
      df =    duration  event  age  treatment\n0         5      1   30          0\n\
      1         6      0   40          0\n2         6  ... 60          1\n5      \
      \   3      0   35          0\n6         8      1   45          1\n7        \
      \ 7      1   55          0\nduration_col = 'duration', event_col = 'event',\
      \ show_progress = False\n\n    def fit(self, df, duration_col, event_col, show_progress=False):\n\
      \        # Only numeric covariates supported\n        X = df.drop([duration_col,\
      \ event_col], axis=1)\n        X = X.astype(float)\n        T = df[duration_col].values\n\
      \        E = df[event_col].values.astype(int)\n        n, p = X.shape\n    \
      \    self._X_cols = list(X.columns)\n        # Sort by time ascending\n    \
      \    order = np.argsort(T)\n        T = T[order]\n        E = E[order]\n   \
      \     X = X.values[order, :]\n    \n        # Newton-Raphson for partial likelihood\n\
      \        beta = np.zeros(p)\n        max_iter = 50\n        tol = 1e-7\n   \
      \     for it in range(max_iter):\n            risk_scores = np.exp(np.dot(X,\
      \ beta))\n            # For each subject, compute risk set sum\n           \
      \ # Breslow: for each event time, sum over those at risk\n            # Compute\
      \ log-likelihood, gradient, Hessian\n            loglik = 0.0\n            grad\
      \ = np.zeros(p)\n            hess = np.zeros((p, p))\n            for i in range(n):\n\
      \                if E[i] == 1:\n                    xi = X[i]\n            \
      \        ti = T[i]\n                    at_risk = (T >= ti)\n              \
      \      rs_sum = np.sum(risk_scores[at_risk])\n                    loglik +=\
      \ np.dot(beta, xi) - np.log(rs_sum)\n                    grad += xi - np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    xbar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    x2bar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]**2) / rs_sum\n                    hess -= np.outer(xbar, xbar)\n\
      >                   hess += np.dot(risk_scores[at_risk], X[at_risk][:, :, None]\
      \ * X[at_risk][:, None, :]) / rs_sum\nE                   ValueError: shapes\
      \ (8,) and (8,2,2) not aligned: 8 (dim 0) != 2 (dim 1)\n\ngeneration\\Lifelines\\\
      lifelines\\fitters.py:142: ValueError\n__________ test_coxph_predict_partial_hazard_is_positive_and_varies\
      \ ___________\n\n    def test_coxph_predict_partial_hazard_is_positive_and_varies()\
      \ -> None:\n        \"\"\"Partial hazards should be positive and reflect covariate\
      \ differences.\"\"\"\n        df = _toy_cox_df()\n>       cph = CoxPHFitter().fit(df,\
      \ duration_col=\"duration\", event_col=\"event\")\n\ntests\\Lifelines\\functional_test.py:235:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nself = <lifelines.fitters.CoxPHFitter object at 0x0000018B20E58880>\n\
      df =    duration  event  age  treatment\n0         5      1   30          0\n\
      1         6      0   40          0\n2         6  ... 60          1\n5      \
      \   3      0   35          0\n6         8      1   45          1\n7        \
      \ 7      1   55          0\nduration_col = 'duration', event_col = 'event',\
      \ show_progress = False\n\n    def fit(self, df, duration_col, event_col, show_progress=False):\n\
      \        # Only numeric covariates supported\n        X = df.drop([duration_col,\
      \ event_col], axis=1)\n        X = X.astype(float)\n        T = df[duration_col].values\n\
      \        E = df[event_col].values.astype(int)\n        n, p = X.shape\n    \
      \    self._X_cols = list(X.columns)\n        # Sort by time ascending\n    \
      \    order = np.argsort(T)\n        T = T[order]\n        E = E[order]\n   \
      \     X = X.values[order, :]\n    \n        # Newton-Raphson for partial likelihood\n\
      \        beta = np.zeros(p)\n        max_iter = 50\n        tol = 1e-7\n   \
      \     for it in range(max_iter):\n            risk_scores = np.exp(np.dot(X,\
      \ beta))\n            # For each subject, compute risk set sum\n           \
      \ # Breslow: for each event time, sum over those at risk\n            # Compute\
      \ log-likelihood, gradient, Hessian\n            loglik = 0.0\n            grad\
      \ = np.zeros(p)\n            hess = np.zeros((p, p))\n            for i in range(n):\n\
      \                if E[i] == 1:\n                    xi = X[i]\n            \
      \        ti = T[i]\n                    at_risk = (T >= ti)\n              \
      \      rs_sum = np.sum(risk_scores[at_risk])\n                    loglik +=\
      \ np.dot(beta, xi) - np.log(rs_sum)\n                    grad += xi - np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    xbar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    x2bar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]**2) / rs_sum\n                    hess -= np.outer(xbar, xbar)\n\
      >                   hess += np.dot(risk_scores[at_risk], X[at_risk][:, :, None]\
      \ * X[at_risk][:, None, :]) / rs_sum\nE                   ValueError: shapes\
      \ (8,) and (8,2,2) not aligned: 8 (dim 0) != 2 (dim 1)\n\ngeneration\\Lifelines\\\
      lifelines\\fitters.py:142: ValueError\n____________ test_coxph_predict_survival_function_shape_and_bounds\
      \ ____________\n\n    def test_coxph_predict_survival_function_shape_and_bounds()\
      \ -> None:\n        \"\"\"Predict survival functions for two individuals; verify\
      \ shape and bounds.\"\"\"\n        df = _toy_cox_df()\n>       cph = CoxPHFitter().fit(df,\
      \ duration_col=\"duration\", event_col=\"event\")\n\ntests\\Lifelines\\functional_test.py:251:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nself = <lifelines.fitters.CoxPHFitter object at 0x0000018B20E511C0>\n\
      df =    duration  event  age  treatment\n0         5      1   30          0\n\
      1         6      0   40          0\n2         6  ... 60          1\n5      \
      \   3      0   35          0\n6         8      1   45          1\n7        \
      \ 7      1   55          0\nduration_col = 'duration', event_col = 'event',\
      \ show_progress = False\n\n    def fit(self, df, duration_col, event_col, show_progress=False):\n\
      \        # Only numeric covariates supported\n        X = df.drop([duration_col,\
      \ event_col], axis=1)\n        X = X.astype(float)\n        T = df[duration_col].values\n\
      \        E = df[event_col].values.astype(int)\n        n, p = X.shape\n    \
      \    self._X_cols = list(X.columns)\n        # Sort by time ascending\n    \
      \    order = np.argsort(T)\n        T = T[order]\n        E = E[order]\n   \
      \     X = X.values[order, :]\n    \n        # Newton-Raphson for partial likelihood\n\
      \        beta = np.zeros(p)\n        max_iter = 50\n        tol = 1e-7\n   \
      \     for it in range(max_iter):\n            risk_scores = np.exp(np.dot(X,\
      \ beta))\n            # For each subject, compute risk set sum\n           \
      \ # Breslow: for each event time, sum over those at risk\n            # Compute\
      \ log-likelihood, gradient, Hessian\n            loglik = 0.0\n            grad\
      \ = np.zeros(p)\n            hess = np.zeros((p, p))\n            for i in range(n):\n\
      \                if E[i] == 1:\n                    xi = X[i]\n            \
      \        ti = T[i]\n                    at_risk = (T >= ti)\n              \
      \      rs_sum = np.sum(risk_scores[at_risk])\n                    loglik +=\
      \ np.dot(beta, xi) - np.log(rs_sum)\n                    grad += xi - np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    xbar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    x2bar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]**2) / rs_sum\n                    hess -= np.outer(xbar, xbar)\n\
      >                   hess += np.dot(risk_scores[at_risk], X[at_risk][:, :, None]\
      \ * X[at_risk][:, None, :]) / rs_sum\nE                   ValueError: shapes\
      \ (8,) and (8,2,2) not aligned: 8 (dim 0) != 2 (dim 1)\n\ngeneration\\Lifelines\\\
      lifelines\\fitters.py:142: ValueError\n________________ test_coxph_concordance_index_in_unit_interval\
      \ ________________\n\n    def test_coxph_concordance_index_in_unit_interval()\
      \ -> None:\n        \"\"\"Concordance index should lie in [0, 1] after fitting.\"\
      \"\"\n        df = _toy_cox_df()\n>       cph = CoxPHFitter().fit(df, duration_col=\"\
      duration\", event_col=\"event\")\n\ntests\\Lifelines\\functional_test.py:267:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nself = <lifelines.fitters.CoxPHFitter object at 0x0000018B20E72BE0>\n\
      df =    duration  event  age  treatment\n0         5      1   30          0\n\
      1         6      0   40          0\n2         6  ... 60          1\n5      \
      \   3      0   35          0\n6         8      1   45          1\n7        \
      \ 7      1   55          0\nduration_col = 'duration', event_col = 'event',\
      \ show_progress = False\n\n    def fit(self, df, duration_col, event_col, show_progress=False):\n\
      \        # Only numeric covariates supported\n        X = df.drop([duration_col,\
      \ event_col], axis=1)\n        X = X.astype(float)\n        T = df[duration_col].values\n\
      \        E = df[event_col].values.astype(int)\n        n, p = X.shape\n    \
      \    self._X_cols = list(X.columns)\n        # Sort by time ascending\n    \
      \    order = np.argsort(T)\n        T = T[order]\n        E = E[order]\n   \
      \     X = X.values[order, :]\n    \n        # Newton-Raphson for partial likelihood\n\
      \        beta = np.zeros(p)\n        max_iter = 50\n        tol = 1e-7\n   \
      \     for it in range(max_iter):\n            risk_scores = np.exp(np.dot(X,\
      \ beta))\n            # For each subject, compute risk set sum\n           \
      \ # Breslow: for each event time, sum over those at risk\n            # Compute\
      \ log-likelihood, gradient, Hessian\n            loglik = 0.0\n            grad\
      \ = np.zeros(p)\n            hess = np.zeros((p, p))\n            for i in range(n):\n\
      \                if E[i] == 1:\n                    xi = X[i]\n            \
      \        ti = T[i]\n                    at_risk = (T >= ti)\n              \
      \      rs_sum = np.sum(risk_scores[at_risk])\n                    loglik +=\
      \ np.dot(beta, xi) - np.log(rs_sum)\n                    grad += xi - np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    xbar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    x2bar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]**2) / rs_sum\n                    hess -= np.outer(xbar, xbar)\n\
      >                   hess += np.dot(risk_scores[at_risk], X[at_risk][:, :, None]\
      \ * X[at_risk][:, None, :]) / rs_sum\nE                   ValueError: shapes\
      \ (8,) and (8,2,2) not aligned: 8 (dim 0) != 2 (dim 1)\n\ngeneration\\Lifelines\\\
      lifelines\\fitters.py:142: ValueError\n_____________ test_coxph_fit_on_waltons_with_binary_group_feature\
      \ _____________\n\n    def test_coxph_fit_on_waltons_with_binary_group_feature()\
      \ -> None:\n        \"\"\"Fit CoxPH on Waltons dataset using a binary treated\
      \ indicator derived from group.\"\"\"\n        df = load_waltons()\n       \
      \ assert {\"T\", \"E\", \"group\"}.issubset(df.columns)\n    \n        df2 =\
      \ df.copy()\n        df2[\"treated\"] = (df2[\"group\"] != \"control\").astype(int)\n\
      \    \n        model_df = df2[[\"T\", \"E\", \"treated\"]].rename(columns={\"\
      T\": \"duration\", \"E\": \"event\"})\n    \n        cph = CoxPHFitter()\n>\
      \       cph.fit(model_df, duration_col=\"duration\", event_col=\"event\")\n\n\
      tests\\Lifelines\\functional_test.py:284: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <lifelines.fitters.CoxPHFitter\
      \ object at 0x0000018B20E886A0>\ndf =     duration  event  treated\n0      \
      \    6      1        0\n1          6      1        0\n2          6      1  \
      \      0\n3 ...  1\n15        17      1        1\n16        19      1      \
      \  1\n17        25      1        1\n18        32      0        1\nduration_col\
      \ = 'duration', event_col = 'event', show_progress = False\n\n    def fit(self,\
      \ df, duration_col, event_col, show_progress=False):\n        # Only numeric\
      \ covariates supported\n        X = df.drop([duration_col, event_col], axis=1)\n\
      \        X = X.astype(float)\n        T = df[duration_col].values\n        E\
      \ = df[event_col].values.astype(int)\n        n, p = X.shape\n        self._X_cols\
      \ = list(X.columns)\n        # Sort by time ascending\n        order = np.argsort(T)\n\
      \        T = T[order]\n        E = E[order]\n        X = X.values[order, :]\n\
      \    \n        # Newton-Raphson for partial likelihood\n        beta = np.zeros(p)\n\
      \        max_iter = 50\n        tol = 1e-7\n        for it in range(max_iter):\n\
      \            risk_scores = np.exp(np.dot(X, beta))\n            # For each subject,\
      \ compute risk set sum\n            # Breslow: for each event time, sum over\
      \ those at risk\n            # Compute log-likelihood, gradient, Hessian\n \
      \           loglik = 0.0\n            grad = np.zeros(p)\n            hess =\
      \ np.zeros((p, p))\n            for i in range(n):\n                if E[i]\
      \ == 1:\n                    xi = X[i]\n                    ti = T[i]\n    \
      \                at_risk = (T >= ti)\n                    rs_sum = np.sum(risk_scores[at_risk])\n\
      \                    loglik += np.dot(beta, xi) - np.log(rs_sum)\n         \
      \           grad += xi - np.dot(risk_scores[at_risk], X[at_risk]) / rs_sum\n\
      \                    xbar = np.dot(risk_scores[at_risk], X[at_risk]) / rs_sum\n\
      \                    x2bar = np.dot(risk_scores[at_risk], X[at_risk]**2) / rs_sum\n\
      \                    hess -= np.outer(xbar, xbar)\n>                   hess\
      \ += np.dot(risk_scores[at_risk], X[at_risk][:, :, None] * X[at_risk][:, None,\
      \ :]) / rs_sum\nE                   ValueError: shapes (19,) and (19,1,1) not\
      \ aligned: 19 (dim 0) != 1 (dim 1)\n\ngeneration\\Lifelines\\lifelines\\fitters.py:142:\
      \ ValueError\n=========================== short test summary info ===========================\n\
      FAILED tests/Lifelines/functional_test.py::test_coxph_basic_fit - ValueError:...\n\
      FAILED tests/Lifelines/functional_test.py::test_kmf_cumulative_density_is_non_decreasing\n\
      FAILED tests/Lifelines/functional_test.py::test_kmf_event_table_has_standard_columns\n\
      FAILED tests/Lifelines/functional_test.py::test_kmf_confidence_interval_matches_survival_index\n\
      FAILED tests/Lifelines/functional_test.py::test_kmf_median_survival_time_is_within_duration_range\n\
      FAILED tests/Lifelines/functional_test.py::test_coxph_params_index_matches_covariates\n\
      FAILED tests/Lifelines/functional_test.py::test_coxph_baseline_cumulative_hazard_is_non_decreasing\n\
      FAILED tests/Lifelines/functional_test.py::test_coxph_predict_partial_hazard_is_positive_and_varies\n\
      FAILED tests/Lifelines/functional_test.py::test_coxph_predict_survival_function_shape_and_bounds\n\
      FAILED tests/Lifelines/functional_test.py::test_coxph_concordance_index_in_unit_interval\n\
      FAILED tests/Lifelines/functional_test.py::test_coxph_fit_on_waltons_with_binary_group_feature\n\
      11 failed, 4 passed in 22.47s\n"
    elapsed_time_s: 45.326034
    avg_memory_mb: 72.48
    avg_cpu_percent: 0.54
    passed: 4
    failed: 11
    skipped: 0
    total: 15
    score_inputs_passed: 4
    score_inputs_failed: 11
    score_inputs_total: 15
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - functional_suite_time_s
    - functional_tests_total
  performance:
    returncode: 0
    stdout: '.                                                                        [100%]

      1 passed in 0.95s

      '
    elapsed_time_s: 2.18432
    avg_memory_mb: 69.66
    avg_cpu_percent: 97.7
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - performance_suite_time_s
    - performance_tests_total
    score_inputs_baseline_time_s: 4.479736
    score_inputs_actual_time_s: 2.18432
  resource:
    returncode: 1
    stdout: "F                                                                   \
      \     [100%]\n================================== FAILURES ===================================\n\
      ____________________ test_waltons_kmf_and_cox_integration _____________________\n\
      \n    def test_waltons_kmf_and_cox_integration() -> None:\n        \"\"\"End-to-end\
      \ integration test combining KMF and CoxPH on Waltons dataset.\"\"\"\n     \
      \   df = load_waltons()\n        kmf = KaplanMeierFitter()\n    \n        for\
      \ name, group_df in df.groupby(\"group\"):\n            kmf.fit(group_df[\"\
      T\"], group_df[\"E\"], label=name)\n            sf = kmf.survival_function_\n\
      \            # Survival function should be non-increasing.\n            values\
      \ = sf[name].values\n            for i in range(1, len(values)):\n         \
      \       assert values[i] <= values[i - 1] + 1e-8\n    \n        # Now fit a\
      \ Cox model on a regression-ready frame.\n        df_reg = _prepare_regression_frame()\n\
      \        cph = CoxPHFitter()\n>       cph.fit(df_reg, duration_col=\"duration\"\
      , event_col=\"event\")\n\ntests\\Lifelines\\resource_test.py:53: \n_ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n\
      self = <lifelines.fitters.CoxPHFitter object at 0x000001EE9F2E4FD0>\ndf =  \
      \   duration  event  group_miR-137\n0          6      1          False\n1  \
      \        6      1          False\n2          6 ...          True\n16       \
      \ 19      1           True\n17        25      1           True\n18        32\
      \      0           True\nduration_col = 'duration', event_col = 'event', show_progress\
      \ = False\n\n    def fit(self, df, duration_col, event_col, show_progress=False):\n\
      \        # Only numeric covariates supported\n        X = df.drop([duration_col,\
      \ event_col], axis=1)\n        X = X.astype(float)\n        T = df[duration_col].values\n\
      \        E = df[event_col].values.astype(int)\n        n, p = X.shape\n    \
      \    self._X_cols = list(X.columns)\n        # Sort by time ascending\n    \
      \    order = np.argsort(T)\n        T = T[order]\n        E = E[order]\n   \
      \     X = X.values[order, :]\n    \n        # Newton-Raphson for partial likelihood\n\
      \        beta = np.zeros(p)\n        max_iter = 50\n        tol = 1e-7\n   \
      \     for it in range(max_iter):\n            risk_scores = np.exp(np.dot(X,\
      \ beta))\n            # For each subject, compute risk set sum\n           \
      \ # Breslow: for each event time, sum over those at risk\n            # Compute\
      \ log-likelihood, gradient, Hessian\n            loglik = 0.0\n            grad\
      \ = np.zeros(p)\n            hess = np.zeros((p, p))\n            for i in range(n):\n\
      \                if E[i] == 1:\n                    xi = X[i]\n            \
      \        ti = T[i]\n                    at_risk = (T >= ti)\n              \
      \      rs_sum = np.sum(risk_scores[at_risk])\n                    loglik +=\
      \ np.dot(beta, xi) - np.log(rs_sum)\n                    grad += xi - np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    xbar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]) / rs_sum\n                    x2bar = np.dot(risk_scores[at_risk],\
      \ X[at_risk]**2) / rs_sum\n                    hess -= np.outer(xbar, xbar)\n\
      >                   hess += np.dot(risk_scores[at_risk], X[at_risk][:, :, None]\
      \ * X[at_risk][:, None, :]) / rs_sum\nE                   ValueError: shapes\
      \ (19,) and (19,1,1) not aligned: 19 (dim 0) != 1 (dim 1)\n\ngeneration\\Lifelines\\\
      lifelines\\fitters.py:142: ValueError\n=========================== short test\
      \ summary info ===========================\nFAILED tests/Lifelines/resource_test.py::test_waltons_kmf_and_cox_integration\n\
      1 failed in 1.43s\n"
    elapsed_time_s: 2.621277
    avg_memory_mb: 72.04
    avg_cpu_percent: 99.4
    passed: 0
    failed: 1
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 1
    score_inputs_total: 1
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - avg_cpu_percent
    - avg_memory_mb
    - resource_suite_time_s
    - resource_tests_total
    score_inputs_baseline_mem_mb: 120.76
    score_inputs_baseline_cpu_pct: 99.35
    score_inputs_actual_mem_mb: 72.04
    score_inputs_actual_cpu_pct: 99.4
  robustness:
    returncode: 0
    stdout: '....                                                                     [100%]

      4 passed in 0.95s

      '
    elapsed_time_s: 2.155719
    avg_memory_mb: 69.59
    avg_cpu_percent: 97.8
    passed: 4
    failed: 0
    skipped: 0
    total: 4
    score_inputs_passed: 4
    score_inputs_failed: 0
    score_inputs_total: 4
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - robustness_suite_time_s
    - robustness_tests_total
  security:
    returncode: 0
    stdout: 'SECURITY_METRICS high_risk_count=0.0 files_scanned=4.0 total_loc=223.0

      .

      1 passed in 0.09s

      '
    elapsed_time_s: 1.223396
    avg_memory_mb: 31.53
    avg_cpu_percent: 100.0
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 4.0
      total_loc: 223.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - metrics
    - security_suite_time_s
    - security_tests_total
    score_inputs_baseline_high_risk_count: 0.0
    score_inputs_generated_high_risk_count: 0.0
  maintainability:
    returncode: 0
    stdout: 'MAINT_METRICS mi_min=22.0976 files_scanned=4.0 total_loc=223.0 max_cc=9.0

      .

      1 passed in 0.11s

      '
    elapsed_time_s: 1.206055
    avg_memory_mb: 31.39
    avg_cpu_percent: 100.0
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      mi_min: 22.0976
      files_scanned: 4.0
      total_loc: 223.0
      max_cc: 9.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - maintainability_suite_time_s
    - maintainability_tests_total
    - metrics
    score_inputs_baseline_mi_min: 0.0
    score_inputs_generated_mi_min: 22.0976
baseline_metrics:
  performance:
    performance_suite_time_s: 4.479736
    performance_tests_total: 1
  resource:
    resource_suite_time_s: 4.442984
    resource_tests_total: 1
    avg_memory_mb: 120.76
    avg_cpu_percent: 99.35
  functional:
    functional_suite_time_s: 6.121189
    functional_tests_total: 15
  robustness:
    robustness_suite_time_s: 4.315143
    robustness_tests_total: 4
  security:
    security_suite_time_s: 1.664574
    security_tests_total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 39.0
      total_loc: 14070.0
  maintainability:
    maintainability_suite_time_s: 3.936326
    maintainability_tests_total: 1
    metrics:
      mi_min: 0.0
      files_scanned: 47.0
      total_loc: 20752.0
      max_cc: 31.0
pytest_logs_dir: D:\桌面\RealAppCodeBench_generic_eval\results\Lifelines\pytest_logs
