.F.F..FFF.                                                               [100%]
================================== FAILURES ===================================
__________________ test_gif_multiframe_roundtrip_with_imiter __________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-359/test_gif_multiframe_roundtrip_0')

    def test_gif_multiframe_roundtrip_with_imiter(tmp_path: Path) -> None:
        """Write a small animated GIF and iterate frames using imiter."""
        frames = _make_grayscale_frames(num_frames=6, height=24, width=24)
        path = tmp_path / "anim.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       loaded_frames = list(iio.imiter(path))

tests\Imageio\functional_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = 'C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-359\\test_gif_multiframe_roundtrip_0\\anim.gif'

    def _gif_iterate_frames(path: str) -> Generator[np.ndarray, None, None]:
        with open(path, "rb") as fp:
            header = fp.read(6)
            if header not in (b"GIF87a", b"GIF89a"):
                raise ValueError("Not a GIF file.")
            # Logical Screen Descriptor
            ls = fp.read(7)
            W, H, packed, bg, aspect = struct.unpack("<HHBBB", ls)
            gct_flag = (packed & 0x80) >> 7
            gct_size_value = packed & 0x07
            gct_size = 2 ** (gct_size_value + 1)
            if gct_flag:
                fp.read(3 * gct_size)
            # Iterate blocks
            while True:
                introducer = fp.read(1)
                if not introducer:
                    break
                b = introducer[0]
                if b == 0x3B:
                    # Trailer
                    break
                elif b == 0x21:
                    # Extension
                    label = fp.read(1)
                    if not label:
                        break
                    if label[0] == 0xF9:
                        # Graphics Control Extension
                        block_size_b = fp.read(1)
                        if not block_size_b:
                            break
                        block_size = block_size_b[0]
                        data = fp.read(block_size)
                        fp.read(1)  # block terminator
                    else:
                        # Application or other extension: read data sub-blocks
                        # First block may be application ID length (usually 11)
                        # Read until terminator
                        # Read a block size; if zero then done
                        # We already read label; now read subblocks generically
                        # Possibly there is a fixed-length initial block for APP
                        # We'll consume in generic fashion
                        # Read sub-blocks (size, data) until sz==0
                        # First we may have an initial block size preceding sub-blocks
                        # We'll handle generically:
                        # Read blocks until terminator
                        _ = _read_subblocks(fp)
                elif b == 0x2C:
                    # Image Descriptor
                    idesc = fp.read(9)
                    left, top, width, height, ipacked = struct.unpack("<HHHHB", idesc)
                    lct_flag = (ipacked & 0x80) >> 7
                    interlace_flag = (ipacked & 0x40) >> 6
                    lct_size_value = ipacked & 0x07
                    if lct_flag:
                        lct_size = 2 ** (lct_size_value + 1)
                        fp.read(3 * lct_size)
                    # LZW minimum code size
                    lzw_min_b = fp.read(1)
                    if not lzw_min_b:
                        break
                    lzw_min_code_size = lzw_min_b[0]
                    # Image data
                    data_stream = _read_subblocks(fp)
                    # Decode
                    pixels = _lzw_decode(data_stream, lzw_min_code_size)
                    # Expect width*height bytes
                    if len(pixels) < width * height:
                        # Some encoders might store interlaced data; we don't support.
>                       raise ValueError("Unsupported GIF interlace or truncated data.")
E                       ValueError: Unsupported GIF interlace or truncated data.

generation\Imageio\imageio\v3.py:537: ValueError
_____________________ test_png_roundtrip_via_bytes_buffer _____________________

    def test_png_roundtrip_via_bytes_buffer() -> None:
        """Write PNG to in-memory bytes, then read back using extension."""
        img = _make_color_image(height=20, width=31)
    
>       blob = iio.imwrite("<bytes>", img, extension=".png")
E       TypeError: imwrite() got an unexpected keyword argument 'extension'

tests\Imageio\functional_test.py:139: TypeError
___________ test_gif_imread_returns_stack_with_expected_frame_count ___________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-359/test_gif_imread_returns_stack_0')

    def test_gif_imread_returns_stack_with_expected_frame_count(tmp_path: Path) -> None:
        """Reading a GIF via imread should produce a stack/sequence with the right number of frames."""
        frames = _make_grayscale_frames(num_frames=5, height=20, width=21)
        path = tmp_path / "stack.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       loaded = iio.imread(path)

tests\Imageio\functional_test.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Imageio\imageio\v3.py:104: in imread
    for frame in _gif_iterate_frames(path):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = 'C:\\Users\\86152\\AppData\\Local\\Temp\\pytest-of-86152\\pytest-359\\test_gif_imread_returns_stack_0\\stack.gif'

    def _gif_iterate_frames(path: str) -> Generator[np.ndarray, None, None]:
        with open(path, "rb") as fp:
            header = fp.read(6)
            if header not in (b"GIF87a", b"GIF89a"):
                raise ValueError("Not a GIF file.")
            # Logical Screen Descriptor
            ls = fp.read(7)
            W, H, packed, bg, aspect = struct.unpack("<HHBBB", ls)
            gct_flag = (packed & 0x80) >> 7
            gct_size_value = packed & 0x07
            gct_size = 2 ** (gct_size_value + 1)
            if gct_flag:
                fp.read(3 * gct_size)
            # Iterate blocks
            while True:
                introducer = fp.read(1)
                if not introducer:
                    break
                b = introducer[0]
                if b == 0x3B:
                    # Trailer
                    break
                elif b == 0x21:
                    # Extension
                    label = fp.read(1)
                    if not label:
                        break
                    if label[0] == 0xF9:
                        # Graphics Control Extension
                        block_size_b = fp.read(1)
                        if not block_size_b:
                            break
                        block_size = block_size_b[0]
                        data = fp.read(block_size)
                        fp.read(1)  # block terminator
                    else:
                        # Application or other extension: read data sub-blocks
                        # First block may be application ID length (usually 11)
                        # Read until terminator
                        # Read a block size; if zero then done
                        # We already read label; now read subblocks generically
                        # Possibly there is a fixed-length initial block for APP
                        # We'll consume in generic fashion
                        # Read sub-blocks (size, data) until sz==0
                        # First we may have an initial block size preceding sub-blocks
                        # We'll handle generically:
                        # Read blocks until terminator
                        _ = _read_subblocks(fp)
                elif b == 0x2C:
                    # Image Descriptor
                    idesc = fp.read(9)
                    left, top, width, height, ipacked = struct.unpack("<HHHHB", idesc)
                    lct_flag = (ipacked & 0x80) >> 7
                    interlace_flag = (ipacked & 0x40) >> 6
                    lct_size_value = ipacked & 0x07
                    if lct_flag:
                        lct_size = 2 ** (lct_size_value + 1)
                        fp.read(3 * lct_size)
                    # LZW minimum code size
                    lzw_min_b = fp.read(1)
                    if not lzw_min_b:
                        break
                    lzw_min_code_size = lzw_min_b[0]
                    # Image data
                    data_stream = _read_subblocks(fp)
                    # Decode
                    pixels = _lzw_decode(data_stream, lzw_min_code_size)
                    # Expect width*height bytes
                    if len(pixels) < width * height:
                        # Some encoders might store interlaced data; we don't support.
>                       raise ValueError("Unsupported GIF interlace or truncated data.")
E                       ValueError: Unsupported GIF interlace or truncated data.

generation\Imageio\imageio\v3.py:537: ValueError
___________ test_gif_imread_index0_matches_first_imiter_frame_shape ___________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-359/test_gif_imread_index0_matches0')

    def test_gif_imread_index0_matches_first_imiter_frame_shape(tmp_path: Path) -> None:
        """Read first GIF frame using both index=0 and imiter; verify consistent spatial shape."""
        frames = _make_grayscale_frames(num_frames=4, height=19, width=23)
        path = tmp_path / "index0.gif"
    
        iio.imwrite(path, frames)
        assert path.exists()
    
>       first_by_index = iio.imread(path, index=0)
E       TypeError: imread() got an unexpected keyword argument 'index'

tests\Imageio\functional_test.py:206: TypeError
_______________________ test_imopen_write_then_read_png _______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-359/test_imopen_write_then_read_pn0')

    def test_imopen_write_then_read_png(tmp_path: Path) -> None:
        """Use the v3 imopen context manager to write then read a PNG."""
        img = _make_color_image(height=16, width=20)
        path = tmp_path / "imopen.png"
    
>       with iio.imopen(path, "w") as f:
E       AttributeError: module 'imageio.v3' has no attribute 'imopen'

tests\Imageio\functional_test.py:221: AttributeError
=========================== short test summary info ===========================
FAILED tests/Imageio/functional_test.py::test_gif_multiframe_roundtrip_with_imiter
FAILED tests/Imageio/functional_test.py::test_png_roundtrip_via_bytes_buffer
FAILED tests/Imageio/functional_test.py::test_gif_imread_returns_stack_with_expected_frame_count
FAILED tests/Imageio/functional_test.py::test_gif_imread_index0_matches_first_imiter_frame_shape
FAILED tests/Imageio/functional_test.py::test_imopen_write_then_read_png - At...
5 failed, 5 passed in 0.93s
