..FF....FF..                                                             [100%]
================================== FAILURES ===================================
_____________________ test_cancel_job_removes_single_job ______________________

    def test_cancel_job_removes_single_job() -> None:
        """cancel_job removes a single job from the scheduler."""
        _clear()
        calls: List[str] = []
    
        def job1() -> None:
            calls.append("job1")
    
        def job2() -> None:
            calls.append("job2")
    
>       j1 = schedule.every().day.do(job1)

tests\Schedule\functional_test.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Schedule\schedule\__init__.py:200: in do
    self._schedule_next_run()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Job(interval=1, unit=days, do=job1, args=(), kwargs={}, last_run=[never], next_run=[never])

    def _schedule_next_run(self):
        """
        Compute the instant when this job should run next.
        """
        if self.unit is None:
            raise ScheduleValueError("Job is not scheduled. Add a unit "
                                     "(.seconds, .minutes, etc.)")
    
        self.period = datetime.timedelta(**{self.unit: self.interval})
        now = datetime.datetime.now()
    
        if self.unit in ('seconds', 'minutes', 'hours'):
            self.next_run = now + self.period
            return
    
        if self.unit == 'days':
            if self.at_time is None:
>               raise ScheduleValueError('.at() must be used with .day(s)')
E               schedule.ScheduleValueError: .at() must be used with .day(s)

generation\Schedule\schedule\__init__.py:249: ScheduleValueError
__________________ test_repeat_decorator_registers_and_runs ___________________

    def test_repeat_decorator_registers_and_runs() -> None:
        """@repeat(every(...)) schedules a function correctly and run_all triggers it."""
        _clear()
        call_count = 0
    
>       @schedule.repeat(schedule.every().seconds)
E       AttributeError: module 'schedule' has no attribute 'repeat'

tests\Schedule\functional_test.py:164: AttributeError
________________ test_every_to_creates_job_with_interval_range ________________

    def test_every_to_creates_job_with_interval_range() -> None:
        """every(A).to(B).seconds should create a job and be runnable via run_all."""
        _clear()
        calls: List[str] = []
    
        def job() -> None:
            calls.append("x")
    
>       j = schedule.every(2).to(5).seconds.do(job)
E       AttributeError: 'Job' object has no attribute 'to'

tests\Schedule\functional_test.py:239: AttributeError
______________________ test_idle_seconds_returns_number _______________________

    def test_idle_seconds_returns_number() -> None:
        """idle_seconds should return a numeric value when jobs exist."""
        _clear()
    
        def job() -> None:
            return None
    
        schedule.every().hour.do(job)
>       idle = schedule.idle_seconds()
E       TypeError: 'property' object is not callable

tests\Schedule\functional_test.py:254: TypeError
=========================== short test summary info ===========================
FAILED tests/Schedule/functional_test.py::test_cancel_job_removes_single_job
FAILED tests/Schedule/functional_test.py::test_repeat_decorator_registers_and_runs
FAILED tests/Schedule/functional_test.py::test_every_to_creates_job_with_interval_range
FAILED tests/Schedule/functional_test.py::test_idle_seconds_returns_number - ...
4 failed, 8 passed in 0.50s
