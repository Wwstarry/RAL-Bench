FF                                                                       [100%]
================================== FAILURES ===================================
_______ test_resource_001_tracemalloc_growth_is_bounded_for_many_tasks ________

    @pytest.mark.resource
    def test_resource_001_tracemalloc_growth_is_bounded_for_many_tasks() -> None:
        """
        Use tracemalloc (stdlib) so the test stays portable.
        We only check that memory growth is not pathological.
        """
>       app = _make_app()

tests\Celery\resource_test.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Celery\resource_test.py:32: in _make_app
    app = Celery(name, broker="memory://", backend="cache+memory://")
generation\Celery\celery\app.py:27: in __init__
    self._backend = self._get_backend(result_backend)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <celery.app.Celery object at 0x000001C0D12192B0>
backend_url = 'cache+memory://'

    def _get_backend(self, backend_url: str) -> BaseBackend:
        if backend_url.startswith("memory://"):
            return MemoryBackend()
>       raise ValueError(f"Unsupported backend: {backend_url}")
E       ValueError: Unsupported backend: cache+memory://

generation\Celery\celery\app.py:37: ValueError
______ test_resource_002_repeated_app_creation_does_not_leak_excessively ______

    @pytest.mark.resource
    def test_resource_002_repeated_app_creation_does_not_leak_excessively() -> None:
        gc.collect()
        tracemalloc.start()
        snap0 = tracemalloc.take_snapshot()
    
        apps = []
        for i in range(30):
>           apps.append(_make_app(f"celery_resource_app_{i}"))

tests\Celery\resource_test.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Celery\resource_test.py:32: in _make_app
    app = Celery(name, broker="memory://", backend="cache+memory://")
generation\Celery\celery\app.py:27: in __init__
    self._backend = self._get_backend(result_backend)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <celery.app.Celery object at 0x000001C0D12195E0>
backend_url = 'cache+memory://'

    def _get_backend(self, backend_url: str) -> BaseBackend:
        if backend_url.startswith("memory://"):
            return MemoryBackend()
>       raise ValueError(f"Unsupported backend: {backend_url}")
E       ValueError: Unsupported backend: cache+memory://

generation\Celery\celery\app.py:37: ValueError
============================== warnings summary ===============================
tests\Celery\resource_test.py:48
  D:\桌面\RealAppCodeBench_generic_eval\tests\Celery\resource_test.py:48: PytestUnknownMarkWarning: Unknown pytest.mark.resource - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.resource

tests\Celery\resource_test.py:85
  D:\桌面\RealAppCodeBench_generic_eval\tests\Celery\resource_test.py:85: PytestUnknownMarkWarning: Unknown pytest.mark.resource - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.resource

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/Celery/resource_test.py::test_resource_001_tracemalloc_growth_is_bounded_for_many_tasks
FAILED tests/Celery/resource_test.py::test_resource_002_repeated_app_creation_does_not_leak_excessively
2 failed, 2 warnings in 0.58s
