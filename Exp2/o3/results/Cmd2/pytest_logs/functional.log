EEEEEEEEEEE                                                              [100%]
=================================== ERRORS ====================================
_______________ ERROR at setup of test_simple_command_execution _______________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A0241220>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A0241220>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
______________ ERROR at setup of test_default_argument_behavior _______________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029D790>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029D790>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
______________ ERROR at setup of test_echo_arguments_and_parsing ______________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A024C250>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A024C250>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
______________ ERROR at setup of test_echo_arguments_with_quotes ______________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A0303B20>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A0303B20>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
_______________ ERROR at setup of test_help_for_custom_command ________________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029C430>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029C430>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
_____________ ERROR at setup of test_help_top_level_contains_help _____________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02419D0>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02419D0>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
____________ ERROR at setup of test_unknown_command_reports_error _____________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02823A0>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02823A0>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
________________ ERROR at setup of test_empty_command_is_noop _________________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02FA6A0>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A02FA6A0>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
____________ ERROR at setup of test_multiple_commands_and_history _____________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029DD30>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A029DD30>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
___________ ERROR at setup of test_history_object_records_commands ____________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A025CBB0>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A025CBB0>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
_______ ERROR at setup of test_quit_command_sets_stop_flag_and_outputs ________

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A01E6820>

    def __init__(self) -> None:
        try:
>           super().__init__(allow_cli_args=False)  # type: ignore[call-arg]
E           TypeError: __init__() got an unexpected keyword argument 'allow_cli_args'

tests\Cmd2\functional_test.py:164: TypeError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def app() -> Optional[Any]:
        Cmd, Statement = _try_import_cmd2()
        if Cmd is None or Statement is None:
            return None
        AppCls = _make_app_class(Cmd, Statement)
>       return AppCls()

tests\Cmd2\functional_test.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Cmd2\functional_test.py:166: in __init__
    super().__init__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <functional_test._make_app_class.<locals>.SimpleApp object at 0x00000199A01E6820>

    def __init__(
        self,
        *,
        use_readline: bool = True,
        completekey: str = "tab",
        stdin=None,
        stdout=None,
    ):
        # The base ``cmd.Cmd`` accepts (completekey, stdin, stdout)
        super().__init__(completekey=completekey, stdin=stdin, stdout=stdout)
        self.use_rawinput: bool = stdin is None  # `cmd`'s own default
        self.use_readline: bool = use_readline
        self.prompt: str = "cmd2> "
        self.intro: Optional[str] = None
    
        # Expose the capture-output context manager on the instance so
        # that existing patterns such as `self.capture_output()` work.
        # (We just curry the generic utility so that `self` is bound.)
>       self.capture_output = contextlib.partial(capture_output, self)
E       AttributeError: module 'contextlib' has no attribute 'partial'

generation\cmd2\cmd2\cmd2.py:75: AttributeError
=========================== short test summary info ===========================
ERROR tests/Cmd2/functional_test.py::test_simple_command_execution - Attribut...
ERROR tests/Cmd2/functional_test.py::test_default_argument_behavior - Attribu...
ERROR tests/Cmd2/functional_test.py::test_echo_arguments_and_parsing - Attrib...
ERROR tests/Cmd2/functional_test.py::test_echo_arguments_with_quotes - Attrib...
ERROR tests/Cmd2/functional_test.py::test_help_for_custom_command - Attribute...
ERROR tests/Cmd2/functional_test.py::test_help_top_level_contains_help - Attr...
ERROR tests/Cmd2/functional_test.py::test_unknown_command_reports_error - Att...
ERROR tests/Cmd2/functional_test.py::test_empty_command_is_noop - AttributeEr...
ERROR tests/Cmd2/functional_test.py::test_multiple_commands_and_history - Att...
ERROR tests/Cmd2/functional_test.py::test_history_object_records_commands - A...
ERROR tests/Cmd2/functional_test.py::test_quit_command_sets_stop_flag_and_outputs
11 errors in 27.89s
