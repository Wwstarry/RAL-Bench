project_name: Dateutil
task_file: D:\桌面\RealAppCodeBench_generic_eval\tasks\Dateutil\dateutil.yaml
generated_repo: D:\桌面\RealAppCodeBench_generic_eval\generation\Dateutil
timestamp: '2026-01-01 21:31:29'
functional_score: 0.0
non_functional_score: 0.24
non_functional_subscores:
  maintainability: 0.0
  security: 1.0
  robustness: 0.0
  performance: 0.0
  resource: 0.0
non_functional_weights:
  maintainability: 0.36
  security: 0.24
  robustness: 0.16
  performance: 0.12
  resource: 0.12
results:
  functional:
    error: 'Test file not found: D:\桌面\RealAppCodeBench_generic_eval\tests\Dateutil\functional_test.py'']'
    passed: 0
    failed: 1
    skipped: 0
    total: 1
    elapsed_time_s: 0.0
    avg_memory_mb: 0.0
    avg_cpu_percent: 0.0
  performance:
    returncode: 2
    stdout: "\n=================================== ERRORS ====================================\n\
      _____________ ERROR collecting tests/Dateutil/performance_test.py _____________\n\
      tests\\Dateutil\\performance_test.py:24: in <module>\n    from dateutil import\
      \ parser, tz  # type: ignore  # noqa: E402\ngeneration\\Dateutil\\dateutil\\\
      __init__.py:22: in <module>\n    _module = import_module(f\"{__name__}.{_name}\"\
      )\nC:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\importlib\\\
      __init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:],\
      \ package, level)\ngeneration\\Dateutil\\dateutil\\parser\\__init__.py:31: in\
      \ <module>\n    _ISO_RE = _re.compile(\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\re.py:252: in compile\n    return _compile(pattern, flags)\n\
      C:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\re.py:304:\
      \ in _compile\n    p = sre_compile.compile(pattern, flags)\nC:\\Users\\86152\\\
      AppData\\Local\\Programs\\Python\\Python39\\lib\\sre_compile.py:764: in compile\n\
      \    p = sre_parse.parse(p, flags)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:948: in parse\n    p = _parse_sub(source,\
      \ state, flags & SRE_FLAG_VERBOSE, 0)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:668: in _parse\n    raise source.error(\"\
      nothing to repeat\",\nE   re.error: nothing to repeat at position 159 (line\
      \ 9, column 17)\n=========================== short test summary info ===========================\n\
      ERROR tests/Dateutil/performance_test.py - re.error: nothing to repeat at pos...\n\
      !!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!\n\
      1 error in 0.91s\n"
    elapsed_time_s: 2.321516
    avg_memory_mb: 36.67
    avg_cpu_percent: 99.3
    passed: 0
    failed: 0
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 2
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - performance_suite_time_s
    - performance_tests_total
    score_inputs_baseline_time_s: 1.285375
    score_inputs_actual_time_s: 2.321516
  resource:
    returncode: 2
    stdout: "\n=================================== ERRORS ====================================\n\
      ______________ ERROR collecting tests/Dateutil/resource_test.py _______________\n\
      tests\\Dateutil\\resource_test.py:23: in <module>\n    from dateutil import\
      \ tz  # type: ignore  # noqa: E402\ngeneration\\Dateutil\\dateutil\\__init__.py:22:\
      \ in <module>\n    _module = import_module(f\"{__name__}.{_name}\")\nC:\\Users\\\
      86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\importlib\\__init__.py:127:\
      \ in import_module\n    return _bootstrap._gcd_import(name[level:], package,\
      \ level)\ngeneration\\Dateutil\\dateutil\\parser\\__init__.py:31: in <module>\n\
      \    _ISO_RE = _re.compile(\nC:\\Users\\86152\\AppData\\Local\\Programs\\Python\\\
      Python39\\lib\\re.py:252: in compile\n    return _compile(pattern, flags)\n\
      C:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\re.py:304:\
      \ in _compile\n    p = sre_compile.compile(pattern, flags)\nC:\\Users\\86152\\\
      AppData\\Local\\Programs\\Python\\Python39\\lib\\sre_compile.py:764: in compile\n\
      \    p = sre_parse.parse(p, flags)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:948: in parse\n    p = _parse_sub(source,\
      \ state, flags & SRE_FLAG_VERBOSE, 0)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:668: in _parse\n    raise source.error(\"\
      nothing to repeat\",\nE   re.error: nothing to repeat at position 159 (line\
      \ 9, column 17)\n=========================== short test summary info ===========================\n\
      ERROR tests/Dateutil/resource_test.py - re.error: nothing to repeat at positi...\n\
      !!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!\n\
      1 error in 0.81s\n"
    elapsed_time_s: 2.167534
    avg_memory_mb: 37.0
    avg_cpu_percent: 99.2
    passed: 0
    failed: 0
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 2
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - avg_cpu_percent
    - avg_memory_mb
    - resource_suite_time_s
    - resource_tests_total
    score_inputs_baseline_mem_mb: 31.66
    score_inputs_baseline_cpu_pct: 100.0
    score_inputs_actual_mem_mb: 37.0
    score_inputs_actual_cpu_pct: 99.2
  robustness:
    returncode: 124
    stdout: "FFFFFF                                                              \
      \     [100%]\n================================== FAILURES ===================================\n\
      ________________ test_dateutil_importable_and_parser_available ________________\n\
      \n    @pytest.mark.timeout(10)\n    def test_dateutil_importable_and_parser_available():\n\
      \        \"\"\"\n        Robustness 1: module should be importable and expose\
      \ parser.parse.\n        \"\"\"\n>       dateutil = _import_dateutil()\n\ntests\\\
      Dateutil\\robustness_test.py:97: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\Dateutil\\robustness_test.py:74:\
      \ in _import_dateutil\n    import dateutil  # type: ignore\ngeneration\\Dateutil\\\
      dateutil\\__init__.py:22: in <module>\n    _module = import_module(f\"{__name__}.{_name}\"\
      )\nC:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\importlib\\\
      __init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:],\
      \ package, level)\ngeneration\\Dateutil\\dateutil\\parser\\__init__.py:31: in\
      \ <module>\n    _ISO_RE = _re.compile(\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\re.py:252: in compile\n    return _compile(pattern, flags)\n\
      C:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\re.py:304:\
      \ in _compile\n    p = sre_compile.compile(pattern, flags)\nC:\\Users\\86152\\\
      AppData\\Local\\Programs\\Python\\Python39\\lib\\sre_compile.py:764: in compile\n\
      \    p = sre_parse.parse(p, flags)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:948: in parse\n    p = _parse_sub(source,\
      \ state, flags & SRE_FLAG_VERBOSE, 0)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nsource = <sre_parse.Tokenizer object\
      \ at 0x000001F40A7C0430>\nstate = <sre_parse.State object at 0x000001F40A7C04C0>,\
      \ verbose = True\nnested = 7, first = False\n\n    def _parse(source, state,\
      \ verbose, nested, first=False):\n        # parse a simple pattern\n       \
      \ subpattern = SubPattern(state)\n    \n        # precompute constants into\
      \ local variables\n        subpatternappend = subpattern.append\n        sourceget\
      \ = source.get\n        sourcematch = source.match\n        _len = len\n   \
      \     _ord = ord\n    \n        while True:\n    \n            this = source.next\n\
      \            if this is None:\n                break # end of pattern\n    \
      \        if this in \"|)\":\n                break # end of subpattern\n   \
      \         sourceget()\n    \n            if verbose:\n                # skip\
      \ whitespace and comments\n                if this in WHITESPACE:\n        \
      \            continue\n                if this == \"#\":\n                 \
      \   while True:\n                        this = sourceget()\n              \
      \          if this is None or this == \"\\n\":\n                           \
      \ break\n                    continue\n    \n            if this[0] == \"\\\\\
      \":\n                code = _escape(source, this, state)\n                subpatternappend(code)\n\
      \    \n            elif this not in SPECIAL_CHARS:\n                subpatternappend((LITERAL,\
      \ _ord(this)))\n    \n            elif this == \"[\":\n                here\
      \ = source.tell() - 1\n                # character set\n                set\
      \ = []\n                setappend = set.append\n    ##          if sourcematch(\"\
      :\"):\n    ##              pass # handle character classes\n               \
      \ if source.next == '[':\n                    import warnings\n            \
      \        warnings.warn(\n                        'Possible nested set at position\
      \ %d' % source.tell(),\n                        FutureWarning, stacklevel=nested\
      \ + 6\n                    )\n                negate = sourcematch(\"^\")\n\
      \                # check remaining characters\n                while True:\n\
      \                    this = sourceget()\n                    if this is None:\n\
      \                        raise source.error(\"unterminated character set\",\n\
      \                                           source.tell() - here)\n        \
      \            if this == \"]\" and set:\n                        break\n    \
      \                elif this[0] == \"\\\\\":\n                        code1 =\
      \ _class_escape(source, this)\n                    else:\n                 \
      \       if set and this in '-&~|' and source.next == this:\n               \
      \             import warnings\n                            warnings.warn(\n\
      \                                'Possible set %s at position %d' % (\n    \
      \                                'difference' if this == '-' else\n        \
      \                            'intersection' if this == '&' else\n          \
      \                          'symmetric difference' if this == '~' else\n    \
      \                                'union',\n                                \
      \    source.tell() - 1),\n                                FutureWarning, stacklevel=nested\
      \ + 6\n                            )\n                        code1 = LITERAL,\
      \ _ord(this)\n                    if sourcematch(\"-\"):\n                 \
      \       # potential range\n                        that = sourceget()\n    \
      \                    if that is None:\n                            raise source.error(\"\
      unterminated character set\",\n                                            \
      \   source.tell() - here)\n                        if that == \"]\":\n     \
      \                       if code1[0] is IN:\n                               \
      \ code1 = code1[1][0]\n                            setappend(code1)\n      \
      \                      setappend((LITERAL, _ord(\"-\")))\n                 \
      \           break\n                        if that[0] == \"\\\\\":\n       \
      \                     code2 = _class_escape(source, that)\n                \
      \        else:\n                            if that == '-':\n              \
      \                  import warnings\n                                warnings.warn(\n\
      \                                    'Possible set difference at position %d'\
      \ % (\n                                        source.tell() - 2),\n       \
      \                             FutureWarning, stacklevel=nested + 6\n       \
      \                         )\n                            code2 = LITERAL, _ord(that)\n\
      \                        if code1[0] != LITERAL or code2[0] != LITERAL:\n  \
      \                          msg = \"bad character range %s-%s\" % (this, that)\n\
      \                            raise source.error(msg, len(this) + 1 + len(that))\n\
      \                        lo = code1[1]\n                        hi = code2[1]\n\
      \                        if hi < lo:\n                            msg = \"bad\
      \ character range %s-%s\" % (this, that)\n                            raise\
      \ source.error(msg, len(this) + 1 + len(that))\n                        setappend((RANGE,\
      \ (lo, hi)))\n                    else:\n                        if code1[0]\
      \ is IN:\n                            code1 = code1[1][0]\n                \
      \        setappend(code1)\n    \n                set = _uniq(set)\n        \
      \        # XXX: <fl> should move set optimization to compiler!\n           \
      \     if _len(set) == 1 and set[0][0] is LITERAL:\n                    # optimization\n\
      \                    if negate:\n                        subpatternappend((NOT_LITERAL,\
      \ set[0][1]))\n                    else:\n                        subpatternappend(set[0])\n\
      \                else:\n                    if negate:\n                   \
      \     set.insert(0, (NEGATE, None))\n                    # charmap optimization\
      \ can't be added here because\n                    # global flags still are\
      \ not known\n                    subpatternappend((IN, set))\n    \n       \
      \     elif this in REPEAT_CHARS:\n                # repeat previous item\n \
      \               here = source.tell()\n                if this == \"?\":\n  \
      \                  min, max = 0, 1\n                elif this == \"*\":\n  \
      \                  min, max = 0, MAXREPEAT\n    \n                elif this\
      \ == \"+\":\n                    min, max = 1, MAXREPEAT\n                elif\
      \ this == \"{\":\n                    if source.next == \"}\":\n           \
      \             subpatternappend((LITERAL, _ord(this)))\n                    \
      \    continue\n    \n                    min, max = 0, MAXREPEAT\n         \
      \           lo = hi = \"\"\n                    while source.next in DIGITS:\n\
      \                        lo += sourceget()\n                    if sourcematch(\"\
      ,\"):\n                        while source.next in DIGITS:\n              \
      \              hi += sourceget()\n                    else:\n              \
      \          hi = lo\n                    if not sourcematch(\"}\"):\n       \
      \                 subpatternappend((LITERAL, _ord(this)))\n                \
      \        source.seek(here)\n                        continue\n    \n       \
      \             if lo:\n                        min = int(lo)\n              \
      \          if min >= MAXREPEAT:\n                            raise OverflowError(\"\
      the repetition number is too large\")\n                    if hi:\n        \
      \                max = int(hi)\n                        if max >= MAXREPEAT:\n\
      \                            raise OverflowError(\"the repetition number is\
      \ too large\")\n                        if max < min:\n                    \
      \        raise source.error(\"min repeat greater than max repeat\",\n      \
      \                                         source.tell() - here)\n          \
      \      else:\n                    raise AssertionError(\"unsupported quantifier\
      \ %r\" % (char,))\n                # figure out which item to repeat\n     \
      \           if subpattern:\n                    item = subpattern[-1:]\n   \
      \             else:\n                    item = None\n                if not\
      \ item or item[0][0] is AT:\n>                   raise source.error(\"nothing\
      \ to repeat\",\n                                       source.tell() - here\
      \ + len(this))\nE                   re.error: nothing to repeat at position\
      \ 159 (line 9, column 17)\n\nC:\\Users\\86152\\AppData\\Local\\Programs\\Python\\\
      Python39\\lib\\sre_parse.py:668: error\n__________________ test_dateutil_basic_parse_common_formats\
      \ ___________________\n\n    @pytest.mark.timeout(10)\n    def test_dateutil_basic_parse_common_formats():\n\
      \        \"\"\"\n        Robustness 2: parse a few common formats. Should return\
      \ datetime without crashing.\n        \"\"\"\n>       dateutil = _import_dateutil()\n\
      \ntests\\Dateutil\\robustness_test.py:108: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\Dateutil\\robustness_test.py:74:\
      \ in _import_dateutil\n    import dateutil  # type: ignore\ngeneration\\Dateutil\\\
      dateutil\\__init__.py:22: in <module>\n    _module = import_module(f\"{__name__}.{_name}\"\
      )\nC:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\importlib\\\
      __init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:],\
      \ package, level)\ngeneration\\Dateutil\\dateutil\\parser\\__init__.py:31: in\
      \ <module>\n    _ISO_RE = _re.compile(\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\re.py:252: in compile\n    return _compile(pattern, flags)\n\
      C:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\re.py:304:\
      \ in _compile\n    p = sre_compile.compile(pattern, flags)\nC:\\Users\\86152\\\
      AppData\\Local\\Programs\\Python\\Python39\\lib\\sre_compile.py:764: in compile\n\
      \    p = sre_parse.parse(p, flags)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:948: in parse\n    p = _parse_sub(source,\
      \ state, flags & SRE_FLAG_VERBOSE, 0)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:834: in _parse\n    p = _parse_sub(source,\
      \ state, sub_verbose, nested + 1)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:443: in _parse_sub\n    itemsappend(_parse(source,\
      \ state, verbose, nested + 1,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nsource = <sre_parse.Tokenizer object\
      \ at 0x000001F40A96CF40>\nstate = <sre_parse.State object at 0x000001F40A96CE20>,\
      \ verbose = True\nnested = 7, first = False\n\n    def _parse(source, state,\
      \ verbose, nested, first=False):\n        # parse a simple pattern\n       \
      \ subpattern = SubPattern(state)\n    \n        # precompute constants into\
      \ local variables\n        subpatternappend = subpattern.append\n        sourceget\
      \ = source.get\n        sourcematch = source.match\n        _len = len\n   \
      \     _ord = ord\n    \n        while True:\n    \n            this = source.next\n\
      \            if this is None:\n                break # end of pattern\n    \
      \        if this in \"|)\":\n                break # end of subpattern\n   \
      \         sourceget()\n    \n            if verbose:\n                # skip\
      \ whitespace and comments\n                if this in WHITESPACE:\n        \
      \            continue\n                if this == \"#\":\n                 \
      \   while True:\n                        this = sourceget()\n              \
      \          if this is None or this == \"\\n\":\n                           \
      \ break\n                    continue\n    \n            if this[0] == \"\\\\\
      \":\n                code = _escape(source, this, state)\n                subpatternappend(code)\n\
      \    \n            elif this not in SPECIAL_CHARS:\n                subpatternappend((LITERAL,\
      \ _ord(this)))\n    \n            elif this == \"[\":\n                here\
      \ = source.tell() - 1\n                # character set\n                set\
      \ = []\n                setappend = set.append\n    ##          if sourcematch(\"\
      :\"):\n    ##              pass # handle character classes\n               \
      \ if source.next == '[':\n                    import warnings\n            \
      \        warnings.warn(\n                        'Possible nested set at position\
      \ %d' % source.tell(),\n                        FutureWarning, stacklevel=nested\
      \ + 6\n                    )\n                negate = sourcematch(\"^\")\n\
      \                # check remaining characters\n                while True:\n\
      \                    this = sourceget()\n                    if this is None:\n\
      \                        raise source.error(\"unterminated character set\",\n\
      \                                           source.tell() - here)\n        \
      \            if this == \"]\" and set:\n                        break\n    \
      \                elif this[0] == \"\\\\\":\n                        code1 =\
      \ _class_escape(source, this)\n                    else:\n                 \
      \       if set and this in '-&~|' and source.next == this:\n               \
      \             import warnings\n                            warnings.warn(\n\
      \                                'Possible set %s at position %d' % (\n    \
      \                                'difference' if this == '-' else\n        \
      \                            'intersection' if this == '&' else\n          \
      \                          'symmetric difference' if this == '~' else\n    \
      \                                'union',\n                                \
      \    source.tell() - 1),\n                                FutureWarning, stacklevel=nested\
      \ + 6\n                            )\n                        code1 = LITERAL,\
      \ _ord(this)\n                    if sourcematch(\"-\"):\n                 \
      \       # potential range\n                        that = sourceget()\n    \
      \                    if that is None:\n                            raise source.error(\"\
      unterminated character set\",\n                                            \
      \   source.tell() - here)\n                        if that == \"]\":\n     \
      \                       if code1[0] is IN:\n                               \
      \ code1 = code1[1][0]\n                            setappend(code1)\n      \
      \                      setappend((LITERAL, _ord(\"-\")))\n                 \
      \           break\n                        if that[0] == \"\\\\\":\n       \
      \                     code2 = _class_escape(source, that)\n                \
      \        else:\n                            if that == '-':\n              \
      \                  import warnings\n                                warnings.warn(\n\
      \                                    'Possible set difference at position %d'\
      \ % (\n                                        source.tell() - 2),\n       \
      \                             FutureWarning, stacklevel=nested + 6\n       \
      \                         )\n                            code2 = LITERAL, _ord(that)\n\
      \                        if code1[0] != LITERAL or code2[0] != LITERAL:\n  \
      \                          msg = \"bad character range %s-%s\" % (this, that)\n\
      \                            raise source.error(msg, len(this) + 1 + len(that))\n\
      \                        lo = code1[1]\n                        hi = code2[1]\n\
      \                        if hi < lo:\n                            msg = \"bad\
      \ character range %s-%s\" % (this, that)\n                            raise\
      \ source.error(msg, len(this) + 1 + len(that))\n                        setappend((RANGE,\
      \ (lo, hi)))\n                    else:\n                        if code1[0]\
      \ is IN:\n                            code1 = code1[1][0]\n                \
      \        setappend(code1)\n    \n                set = _uniq(set)\n        \
      \        # XXX: <fl> should move set optimization to compiler!\n           \
      \     if _len(set) == 1 and set[0][0] is LITERAL:\n                    # optimization\n\
      \                    if negate:\n                        subpatternappend((NOT_LITERAL,\
      \ set[0][1]))\n                    else:\n                        subpatternappend(set[0])\n\
      \                else:\n                    if negate:\n                   \
      \     set.insert(0, (NEGATE, None))\n                    # charmap optimization\
      \ can't be added here because\n                    # global flags still are\
      \ not known\n                    subpatternappend((IN, set))\n    \n       \
      \     elif this in REPEAT_CHARS:\n                # repeat previous item\n \
      \               here = source.tell()\n                if this == \"?\":\n  \
      \                  min, max = 0, 1\n                elif this == \"*\":\n  \
      \                  min, max = 0, MAXREPEAT\n    \n                elif this\
      \ == \"+\":\n                    min, max = 1, MAXREPEAT\n                elif\
      \ this == \"{\":\n                    if source.next == \"}\":\n           \
      \             subpatternappend((LITERAL, _ord(this)))\n                    \
      \    continue\n    \n                    min, max = 0, MAXREPEAT\n         \
      \           lo = hi = \"\"\n                    while source.next in DIGITS:\n\
      \                        lo += sourceget()\n                    if sourcematch(\"\
      ,\"):\n                        while source.next in DIGITS:\n              \
      \              hi += sourceget()\n                    else:\n              \
      \          hi = lo\n                    if not sourcematch(\"}\"):\n       \
      \                 subpatternappend((LITERAL, _ord(this)))\n                \
      \        source.seek(here)\n                        continue\n    \n       \
      \             if lo:\n                        min = int(lo)\n              \
      \          if min >= MAXREPEAT:\n                            raise OverflowError(\"\
      the repetition number is too large\")\n                    if hi:\n        \
      \                max = int(hi)\n                        if max >= MAXREPEAT:\n\
      \                            raise OverflowError(\"the repetition number is\
      \ too large\")\n                        if max < min:\n                    \
      \        raise source.error(\"min repeat greater than max repeat\",\n      \
      \                                         source.tell() - here)\n          \
      \      else:\n                    raise AssertionError(\"unsupported quantifier\
      \ %r\" % (char,))\n                # figure out which item to repeat\n     \
      \           if subpattern:\n                    item = subpattern[-1:]\n   \
      \             else:\n                    item = None\n                if not\
      \ item or item[0][0] is AT:\n>                   raise source.error(\"nothing\
      \ to repeat\",\n                                       source.tell() - here\
      \ + len(this))\nE                   re.error: nothing to repeat at position\
      \ 159 (line 9, column 17)\n\nC:\\Users\\86152\\AppData\\Local\\Programs\\Python\\\
      Python39\\lib\\sre_parse.py:668: error\n_______________ test_dateutil_parse_invalid_string_fails_safely\
      \ _______________\n\n    @pytest.mark.timeout(10)\n    def test_dateutil_parse_invalid_string_fails_safely():\n\
      \        \"\"\"\n        Robustness 3: invalid date string should raise, or\
      \ at least not crash/hang.\n        \"\"\"\n>       dateutil = _import_dateutil()\n\
      \ntests\\Dateutil\\robustness_test.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\Dateutil\\robustness_test.py:74:\
      \ in _import_dateutil\n    import dateutil  # type: ignore\ngeneration\\Dateutil\\\
      dateutil\\__init__.py:22: in <module>\n    _module = import_module(f\"{__name__}.{_name}\"\
      )\nC:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\importlib\\\
      __init__.py:127: in import_module\n    return _bootstrap._gcd_import(name[level:],\
      \ package, level)\ngeneration\\Dateutil\\dateutil\\parser\\__init__.py:31: in\
      \ <module>\n    _ISO_RE = _re.compile(\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\re.py:252: in compile\n    return _compile(pattern, flags)\n\
      C:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\re.py:304:\
      \ in _compile\n    p = sre_compile.compile(pattern, flags)\nC:\\Users\\86152\\\
      AppData\\Local\\Programs\\Python\\Python39\\lib\\sre_compile.py:764: in compile\n\
      \    p = sre_parse.parse(p, flags)\nC:\\Users\\86152\\AppData\\Local\\Programs\\\
      Python\\Python39\\lib\\sre_parse.py:948: in parse\n    p = _parse_sub(source,\
      \ state, flags & SRE_FLAG_VERBOSE, 0)\n"
    elapsed_time_s: 60.001701
    avg_memory_mb: 37.2
    avg_cpu_percent: 0.2
    passed: 0
    failed: 1
    skipped: 0
    total: 1
    timeout: true
    score_inputs_passed: 0
    score_inputs_failed: 1
    score_inputs_total: 1
    score_inputs_returncode: 124
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - robustness_suite_time_s
    - robustness_tests_total
  security:
    returncode: 0
    stdout: 'SECURITY_METRICS high_risk_count=0.0 files_scanned=5.0 total_loc=571.0

      .

      1 passed in 0.11s

      '
    elapsed_time_s: 1.242228
    avg_memory_mb: 31.66
    avg_cpu_percent: 95.9
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 5.0
      total_loc: 571.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - metrics
    - security_suite_time_s
    - security_tests_total
    score_inputs_baseline_high_risk_count: 0.0
    score_inputs_generated_high_risk_count: 0.0
  maintainability:
    returncode: 0
    stdout: 'MAINT_METRICS mi_min=21.5907 files_scanned=5.0 total_loc=571.0 max_cc=16.0

      .

      1 passed in 0.14s

      '
    elapsed_time_s: 1.289259
    avg_memory_mb: 31.63
    avg_cpu_percent: 100.0
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      mi_min: 21.5907
      files_scanned: 5.0
      total_loc: 571.0
      max_cc: 16.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - maintainability_suite_time_s
    - maintainability_tests_total
    - metrics
    score_inputs_baseline_mi_min: 0.0
    score_inputs_generated_mi_min: 21.5907
baseline_metrics:
  performance:
    performance_suite_time_s: 1.285375
    performance_tests_total: 1
  resource:
    resource_suite_time_s: 1.234135
    resource_tests_total: 2
    avg_memory_mb: 31.66
    avg_cpu_percent: 100.0
  functional:
    functional_suite_time_s: 1.125135
    functional_tests_total: 1
  robustness:
    robustness_suite_time_s: 1.313908
    robustness_tests_total: 6
  security:
    security_suite_time_s: 1.372555
    security_tests_total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 22.0
      total_loc: 5945.0
  maintainability:
    maintainability_suite_time_s: 3.147629
    maintainability_tests_total: 1
    metrics:
      mi_min: 0.0
      files_scanned: 37.0
      total_loc: 14362.0
      max_cc: 96.0
pytest_logs_dir: D:\桌面\RealAppCodeBench_generic_eval\results\Dateutil\pytest_logs
