project_name: Xmltodict
task_file: D:\桌面\RealAppCodeBench_generic_eval\tasks\Xmltodict\xmltodict.yaml
generated_repo: D:\桌面\RealAppCodeBench_generic_eval\generation\Xmltodict
timestamp: '2026-01-01 22:12:00'
functional_score: 0.0
non_functional_score: 0.6532
non_functional_subscores:
  maintainability: 0.7035
  security: 1.0
  robustness: 1.0
  performance: 0.0
  resource: 0.0
non_functional_weights:
  maintainability: 0.36
  security: 0.24
  robustness: 0.16
  performance: 0.12
  resource: 0.12
results:
  functional:
    returncode: 124
    stdout: "FFFFFFFFFFFF                                                        \
      \     [100%]\n================================== FAILURES ===================================\n\
      __________________________ test_parse_simple_element __________________________\n\
      \n    def test_parse_simple_element() -> None:\n        \"\"\"Parsing a simple\
      \ XML element should produce the expected dict.\"\"\"\n        xml = \"<root><message>Hello</message></root>\"\
      \n>       data = _parse(xml)\n\ntests\\Xmltodict\\functional_test.py:77: \n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\ntests\\Xmltodict\\functional_test.py:62: in _parse\n    return xmltodict.parse(xml,\
      \ **filtered)  # type: ignore[arg-type]\ngeneration\\Xmltodict\\xmltodict.py:144:\
      \ in parse\n    return _convert(root)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nel = <Element 'root' at 0x0000027F5928F130>\n\
      \n    def _convert(el: _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n\
      \        Convert *el* into mapping according to the rules described above and\n\
      \        return ``{el.tag: value}``.\n        \"\"\"\n        node_map: MutableMapping[str,\
      \ Any] = dict_constructor()\n    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n____________________ test_parse_repeated_elements_as_list\
      \ _____________________\n\n    def test_parse_repeated_elements_as_list() ->\
      \ None:\n        \"\"\"Repeated child elements should be represented as a list.\"\
      \"\"\n        xml = \"<root><item>1</item><item>2</item><item>3</item></root>\"\
      \n>       data = _parse(xml)\n\ntests\\Xmltodict\\functional_test.py:86: \n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\ntests\\Xmltodict\\functional_test.py:62: in _parse\n    return xmltodict.parse(xml,\
      \ **filtered)  # type: ignore[arg-type]\ngeneration\\Xmltodict\\xmltodict.py:144:\
      \ in parse\n    return _convert(root)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nel = <Element 'root' at 0x0000027F591ECD60>\n\
      \n    def _convert(el: _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n\
      \        Convert *el* into mapping according to the rules described above and\n\
      \        return ``{el.tag: value}``.\n        \"\"\"\n        node_map: MutableMapping[str,\
      \ Any] = dict_constructor()\n    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n_______________________\
      \ test_parse_attributes_and_text ________________________\n\n    def test_parse_attributes_and_text()\
      \ -> None:\n        \"\"\"Attributes and text content should be exposed using\
      \ @attr and #text keys.\"\"\"\n        xml = '<user id=\"123\">Alice</user>'\n\
      >       data = _parse(xml)\n\ntests\\Xmltodict\\functional_test.py:96: \n_ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _\ntests\\Xmltodict\\functional_test.py:62: in _parse\n    return xmltodict.parse(xml,\
      \ **filtered)  # type: ignore[arg-type]\ngeneration\\Xmltodict\\xmltodict.py:144:\
      \ in parse\n    return _convert(root)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nel = <Element 'user' at 0x0000027F59315040>\n\
      \n    def _convert(el: _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n\
      \        Convert *el* into mapping according to the rules described above and\n\
      \        return ``{el.tag: value}``.\n        \"\"\"\n        node_map: MutableMapping[str,\
      \ Any] = dict_constructor()\n    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n___________________ test_unparse_roundtrip_basic_structure\
      \ ____________________\n\n    def test_unparse_roundtrip_basic_structure() ->\
      \ None:\n        \"\"\"unparse() followed by parse() should preserve the logical\
      \ structure.\"\"\"\n        original = {\n            \"root\": {\n        \
      \        \"item\": [\n                    {\"@id\": \"1\", \"#text\": \"A\"\
      },\n                    {\"@id\": \"2\", \"#text\": \"B\"},\n              \
      \  ]\n            }\n        }\n    \n        xml = _unparse(original)\n>  \
      \     round_tripped = _parse(xml)\n\ntests\\Xmltodict\\functional_test.py:115:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\ntests\\Xmltodict\\functional_test.py:62: in _parse\n    return xmltodict.parse(xml,\
      \ **filtered)  # type: ignore[arg-type]\ngeneration\\Xmltodict\\xmltodict.py:144:\
      \ in parse\n    return _convert(root)\ngeneration\\Xmltodict\\xmltodict.py:121:\
      \ in _convert\n    child_mapping = _convert(child)\n_ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nel = <Element 'item'\
      \ at 0x0000027F591ECB30>\n\n    def _convert(el: _ET.Element) -> Mapping[str,\
      \ Any]:\n        \"\"\"\n        Convert *el* into mapping according to the\
      \ rules described above and\n        return ``{el.tag: value}``.\n        \"\
      \"\"\n        node_map: MutableMapping[str, Any] = dict_constructor()\n    \n\
      \        # Attributes ---------------------------------------------------- #\n\
      \        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n_____________________ test_namespace_prefix_is_preserved\
      \ ______________________\n\n    def test_namespace_prefix_is_preserved() ->\
      \ None:\n        \"\"\"Namespace prefixes in element names should be preserved\
      \ in dict keys.\"\"\"\n        xml = \"\"\"\n        <root xmlns:x=\"http://example.com/x\"\
      >\n            <x:item>value</x:item>\n        </root>\n        \"\"\"\n>  \
      \     data = _parse(xml)\n\ntests\\Xmltodict\\functional_test.py:127: \n_ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _\ntests\\Xmltodict\\functional_test.py:62: in _parse\n    return xmltodict.parse(xml,\
      \ **filtered)  # type: ignore[arg-type]\ngeneration\\Xmltodict\\xmltodict.py:144:\
      \ in parse\n    return _convert(root)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nel = <Element 'root' at 0x0000027F59209770>\n\
      \n    def _convert(el: _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n\
      \        Convert *el* into mapping according to the rules described above and\n\
      \        return ``{el.tag: value}``.\n        \"\"\"\n        node_map: MutableMapping[str,\
      \ Any] = dict_constructor()\n    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n_________________________\
      \ test_parse_nested_structure _________________________\n\n    def test_parse_nested_structure()\
      \ -> None:\n        \"\"\"Nested XML elements should map to nested dict structures.\"\
      \"\"\n        xml = \"\"\"\n        <root>\n            <user>\n           \
      \     <name>Ada</name>\n                <address>\n                    <city>London</city>\n\
      \                    <country>UK</country>\n                </address>\n   \
      \         </user>\n        </root>\n        \"\"\"\n>       data = _parse(xml)\n\
      \ntests\\Xmltodict\\functional_test.py:150: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\Xmltodict\\functional_test.py:62:\
      \ in _parse\n    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]\n\
      generation\\Xmltodict\\xmltodict.py:144: in parse\n    return _convert(root)\n\
      generation\\Xmltodict\\xmltodict.py:121: in _convert\n    child_mapping = _convert(child)\n\
      generation\\Xmltodict\\xmltodict.py:121: in _convert\n    child_mapping = _convert(child)\n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\n\nel = <Element 'address' at 0x0000027F592BBD60>\n\n    def _convert(el:\
      \ _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n        Convert *el* into\
      \ mapping according to the rules described above and\n        return ``{el.tag:\
      \ value}``.\n        \"\"\"\n        node_map: MutableMapping[str, Any] = dict_constructor()\n\
      \    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n__________________ test_force_list_option_for_single_element\
      \ __________________\n\n    def test_force_list_option_for_single_element()\
      \ -> None:\n        \"\"\"force_list should allow representing a single child\
      \ as a list when supported.\"\"\"\n        xml = \"<root><item>1</item></root>\"\
      \n    \n        # Prefer a targeted force_list that is common in xmltodict.\n\
      >       data = _parse(xml, force_list=(\"item\",))\n\ntests\\Xmltodict\\functional_test.py:161:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\ntests\\Xmltodict\\functional_test.py:62: in _parse\n    return xmltodict.parse(xml,\
      \ **filtered)  # type: ignore[arg-type]\ngeneration\\Xmltodict\\xmltodict.py:144:\
      \ in parse\n    return _convert(root)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nel = <Element 'root' at 0x0000027F59277E00>\n\
      \n    def _convert(el: _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n\
      \        Convert *el* into mapping according to the rules described above and\n\
      \        return ``{el.tag: value}``.\n        \"\"\"\n        node_map: MutableMapping[str,\
      \ Any] = dict_constructor()\n    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n_____________ test_custom_attr_prefix_and_cdata_key_if_supported\
      \ ______________\n\n    def test_custom_attr_prefix_and_cdata_key_if_supported()\
      \ -> None:\n        \"\"\"attr_prefix / cdata_key customization should reflect\
      \ in output when supported.\"\"\"\n        xml = '<user id=\"7\">Bob</user>'\n\
      \    \n>       data = _parse(xml, attr_prefix=\"$\", cdata_key=\"text\")\n\n\
      tests\\Xmltodict\\functional_test.py:176: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\Xmltodict\\functional_test.py:62:\
      \ in _parse\n    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]\n\
      generation\\Xmltodict\\xmltodict.py:144: in parse\n    return _convert(root)\n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\n\nel = <Element 'user' at 0x0000027F591ECF40>\n\n    def _convert(el:\
      \ _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n        Convert *el* into\
      \ mapping according to the rules described above and\n        return ``{el.tag:\
      \ value}``.\n        \"\"\"\n        node_map: MutableMapping[str, Any] = dict_constructor()\n\
      \    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n____________ test_xml_attribs_false_drops_attributes_if_supported\
      \ _____________\n\n    def test_xml_attribs_false_drops_attributes_if_supported()\
      \ -> None:\n        \"\"\"xml_attribs=False should omit attribute keys when\
      \ supported.\"\"\"\n        xml = '<user id=\"9\"><name>Alice</name></user>'\n\
      \    \n>       data = _parse(xml, xml_attribs=False)\n\ntests\\Xmltodict\\functional_test.py:191:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\ntests\\Xmltodict\\functional_test.py:62: in _parse\n    return xmltodict.parse(xml,\
      \ **filtered)  # type: ignore[arg-type]\ngeneration\\Xmltodict\\xmltodict.py:144:\
      \ in parse\n    return _convert(root)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nel = <Element 'user' at 0x0000027F5928FC20>\n\
      \n    def _convert(el: _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n\
      \        Convert *el* into mapping according to the rules described above and\n\
      \        return ``{el.tag: value}``.\n"
    elapsed_time_s: 60.019536
    avg_memory_mb: 32.95
    avg_cpu_percent: 0.25
    passed: 0
    failed: 1
    skipped: 0
    total: 1
    timeout: true
    score_inputs_passed: 0
    score_inputs_failed: 1
    score_inputs_total: 1
    score_inputs_returncode: 124
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - functional_suite_time_s
    - functional_tests_total
  performance:
    returncode: 1
    stdout: "F                                                                   \
      \     [100%]\n================================== FAILURES ===================================\n\
      ______________________ test_xmltodict_performance_smoke _______________________\n\
      \n    def test_xmltodict_performance_smoke() -> None:\n        \"\"\"Smoke test\
      \ to ensure the performance benchmark runs successfully.\"\"\"\n>       metrics\
      \ = run_xmltodict_performance_benchmark(iterations=5, n_users=50)\n\ntests\\\
      Xmltodict\\performance_test.py:84: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\Xmltodict\\performance_test.py:63:\
      \ in run_xmltodict_performance_benchmark\n    parsed = xmltodict.parse(xml)\n\
      generation\\Xmltodict\\xmltodict.py:144: in parse\n    return _convert(root)\n\
      generation\\Xmltodict\\xmltodict.py:121: in _convert\n    child_mapping = _convert(child)\n\
      generation\\Xmltodict\\xmltodict.py:121: in _convert\n    child_mapping = _convert(child)\n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\n\nel = <Element 'user' at 0x000001CFC8F3CE50>\n\n    def _convert(el:\
      \ _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n        Convert *el* into\
      \ mapping according to the rules described above and\n        return ``{el.tag:\
      \ value}``.\n        \"\"\"\n        node_map: MutableMapping[str, Any] = dict_constructor()\n\
      \    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n===========================\
      \ short test summary info ===========================\nFAILED tests/Xmltodict/performance_test.py::test_xmltodict_performance_smoke\n\
      1 failed in 0.34s\n"
    elapsed_time_s: 1.49524
    avg_memory_mb: 32.39
    avg_cpu_percent: 102.2
    passed: 0
    failed: 1
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 1
    score_inputs_total: 1
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - performance_suite_time_s
    - performance_tests_total
    score_inputs_baseline_time_s: 1.593666
    score_inputs_actual_time_s: 1.49524
  resource:
    returncode: 1
    stdout: "FF                                                                  \
      \     [100%]\n================================== FAILURES ===================================\n\
      ______________________ test_catalog_structure_and_types _______________________\n\
      \n    def test_catalog_structure_and_types() -> None:\n        \"\"\"The parsed\
      \ catalog should have the expected nested structure and types.\"\"\"\n>    \
      \   data = _parse_catalog()\n\ntests\\Xmltodict\\resource_test.py:57: \n_ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _\ntests\\Xmltodict\\resource_test.py:52: in _parse_catalog\n    return xmltodict.parse(_COMPLEX_XML)\n\
      generation\\Xmltodict\\xmltodict.py:144: in parse\n    return _convert(root)\n\
      generation\\Xmltodict\\xmltodict.py:121: in _convert\n    child_mapping = _convert(child)\n\
      generation\\Xmltodict\\xmltodict.py:121: in _convert\n    child_mapping = _convert(child)\n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\n\nel = <Element 'price' at 0x0000023F6756CEF0>\n\n    def _convert(el:\
      \ _ET.Element) -> Mapping[str, Any]:\n        \"\"\"\n        Convert *el* into\
      \ mapping according to the rules described above and\n        return ``{el.tag:\
      \ value}``.\n        \"\"\"\n        node_map: MutableMapping[str, Any] = dict_constructor()\n\
      \    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n_______________________\
      \ test_roundtrip_complex_catalog ________________________\n\n    def test_roundtrip_complex_catalog()\
      \ -> None:\n        \"\"\"\n        Parsing and then unparsing the complex catalog\
      \ XML should preserve\n        the logical structure when parsed again.\n  \
      \      \"\"\"\n>       original_dict = _parse_catalog()\n\ntests\\Xmltodict\\\
      resource_test.py:79: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\Xmltodict\\resource_test.py:52: in _parse_catalog\n\
      \    return xmltodict.parse(_COMPLEX_XML)\ngeneration\\Xmltodict\\xmltodict.py:144:\
      \ in parse\n    return _convert(root)\ngeneration\\Xmltodict\\xmltodict.py:121:\
      \ in _convert\n    child_mapping = _convert(child)\ngeneration\\Xmltodict\\\
      xmltodict.py:121: in _convert\n    child_mapping = _convert(child)\n_ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n\
      el = <Element 'price' at 0x0000023F67509720>\n\n    def _convert(el: _ET.Element)\
      \ -> Mapping[str, Any]:\n        \"\"\"\n        Convert *el* into mapping according\
      \ to the rules described above and\n        return ``{el.tag: value}``.\n  \
      \      \"\"\"\n        node_map: MutableMapping[str, Any] = dict_constructor()\n\
      \    \n        # Attributes ----------------------------------------------------\
      \ #\n        for k, v in el.attrib.items():\n            node_map[f\"{attr_prefix}{k}\"\
      ] = v\n    \n        # Children ------------------------------------------------------\
      \ #\n        for child in el:\n            child_mapping = _convert(child)\n\
      \            tag, value = next(iter(child_mapping.items()))\n    \n        \
      \    if tag in node_map:\n                existing = node_map[tag]\n       \
      \         if isinstance(existing, list):\n                    existing.append(value)\n\
      \                else:\n                    node_map[tag] = [existing, value]\n\
      \            else:\n                node_map[tag] = value\n    \n        # Text\
      \ ---------------------------------------------------------- #\n        text\
      \ = (el.text or \"\").strip()\n        if text:\n            if node_map:\n\
      \                node_map[cdata_key] = text\n            else:\n           \
      \     # No attributes/children – represent directly as text\n              \
      \  return dict_constructor(((el.tag, text),))\n    \n>       return dict_constructor(((el.tag,\
      \ node_map)))\nE       ValueError: too many values to unpack (expected 2)\n\n\
      generation\\Xmltodict\\xmltodict.py:142: ValueError\n===========================\
      \ short test summary info ===========================\nFAILED tests/Xmltodict/resource_test.py::test_catalog_structure_and_types\
      \ - V...\nFAILED tests/Xmltodict/resource_test.py::test_roundtrip_complex_catalog\
      \ - Val...\n2 failed in 0.36s\n"
    elapsed_time_s: 1.594743
    avg_memory_mb: 31.97
    avg_cpu_percent: 99.0
    passed: 0
    failed: 2
    skipped: 0
    total: 2
    score_inputs_passed: 0
    score_inputs_failed: 2
    score_inputs_total: 2
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - avg_cpu_percent
    - avg_memory_mb
    - resource_suite_time_s
    - resource_tests_total
    score_inputs_baseline_mem_mb: 32.5
    score_inputs_baseline_cpu_pct: 98.9
    score_inputs_actual_mem_mb: 31.97
    score_inputs_actual_cpu_pct: 99.0
  robustness:
    returncode: 0
    stdout: '....                                                                     [100%]

      4 passed in 0.13s

      '
    elapsed_time_s: 1.284552
    avg_memory_mb: 31.65
    avg_cpu_percent: 98.7
    passed: 4
    failed: 0
    skipped: 0
    total: 4
    score_inputs_passed: 4
    score_inputs_failed: 0
    score_inputs_total: 4
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - robustness_suite_time_s
    - robustness_tests_total
  security:
    returncode: 0
    stdout: 'SECURITY_METRICS high_risk_count=0.0 files_scanned=1.0 total_loc=200.0

      .

      1 passed in 0.09s

      '
    elapsed_time_s: 1.237488
    avg_memory_mb: 31.25
    avg_cpu_percent: 100.0
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 1.0
      total_loc: 200.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - metrics
    - security_suite_time_s
    - security_tests_total
    score_inputs_baseline_high_risk_count: 0.0
    score_inputs_generated_high_risk_count: 0.0
  maintainability:
    returncode: 0
    stdout: 'MAINT_METRICS mi_min=21.9275 files_scanned=1.0 total_loc=200.0 max_cc=21.0

      .

      1 passed in 0.11s

      '
    elapsed_time_s: 1.257375
    avg_memory_mb: 31.73
    avg_cpu_percent: 102.7
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      mi_min: 21.9275
      files_scanned: 1.0
      total_loc: 200.0
      max_cc: 21.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - maintainability_suite_time_s
    - maintainability_tests_total
    - metrics
    score_inputs_baseline_mi_min: 9.2435
    score_inputs_generated_mi_min: 21.9275
    score_inputs_ratio_g_over_b: 2.3722074971601668
baseline_metrics:
  performance:
    performance_suite_time_s: 1.593666
    performance_tests_total: 1
  resource:
    resource_suite_time_s: 1.556051
    resource_tests_total: 2
    avg_memory_mb: 32.5
    avg_cpu_percent: 98.9
  functional:
    functional_suite_time_s: 1.63732
    functional_tests_total: 12
  robustness:
    robustness_suite_time_s: 1.692569
    robustness_tests_total: 4
  security:
    security_suite_time_s: 1.470756
    security_tests_total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 1.0
      total_loc: 542.0
  maintainability:
    maintainability_suite_time_s: 1.751538
    maintainability_tests_total: 1
    metrics:
      mi_min: 9.2435
      files_scanned: 3.0
      total_loc: 1446.0
      max_cc: 44.0
pytest_logs_dir: D:\桌面\RealAppCodeBench_generic_eval\results\Xmltodict\pytest_logs
