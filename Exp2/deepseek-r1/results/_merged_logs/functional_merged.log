####################################################################################################
# MODEL: deepseek-r1
# NUM_PROJECT_LOGS: 22
####################################################################################################

==========================================================================================
PROJECT: Celery
LOG: D:\桌面\Exp1\deepseek-r1\results\Celery\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFF                                                               [100%]
================================== FAILURES ===================================
___________________ test_001_import_celery_and_core_symbols ___________________

    def test_001_import_celery_and_core_symbols() -> None:
        _ensure_celery_importable()
        import celery  # noqa: F401
    
        from celery import Celery  # noqa: F401
>       from celery import chain, chord, group, signature  # noqa: F401
E       ImportError: cannot import name 'chain' from 'celery' (D:\桌面\RealAppCodeBench_generic_eval\generation\Celery\celery\__init__.py)

tests\Celery\functional_test.py:61: ImportError
______________ test_002_create_app_and_register_task_runs_delay _______________

    def test_002_create_app_and_register_task_runs_delay() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() got an unexpected keyword argument 'task_always_eager'

tests\Celery\functional_test.py:41: TypeError
____ test_003_apply_async_supports_kwargs_and_counts_down_ignored_in_eager ____

    def test_003_apply_async_supports_kwargs_and_counts_down_ignored_in_eager() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() got an unexpected keyword argument 'task_always_eager'

tests\Celery\functional_test.py:41: TypeError
__________________ test_004_group_collects_results_in_order ___________________

    def test_004_group_collects_results_in_order() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() got an unexpected keyword argument 'task_always_eager'

tests\Celery\functional_test.py:41: TypeError
____________________ test_005_chain_passes_previous_result ____________________

    def test_005_chain_passes_previous_result() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() got an unexpected keyword argument 'task_always_eager'

tests\Celery\functional_test.py:41: TypeError
_______________ test_006_chord_runs_callback_over_group_results _______________

    def test_006_chord_runs_callback_over_group_results() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() got an unexpected keyword argument 'task_always_eager'

tests\Celery\functional_test.py:41: TypeError
______________ test_007_task_exception_propagates_in_eager_mode _______________

    def test_007_task_exception_propagates_in_eager_mode() -> None:
        """
        In some Celery versions/configs with task_always_eager=True and
        task_eager_propagates=True, the exception is raised immediately during
        delay()/apply_async() rather than on AsyncResult.get().
    
        This test accepts both correct behaviors:
        - delay raises ValueError directly, OR
        - delay returns a result whose .get() raises ValueError.
        """
>       app = _make_app()

tests\Celery\functional_test.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() got an unexpected keyword argument 'task_always_eager'

tests\Celery\functional_test.py:41: TypeError
_____________ test_008_disable_propagation_returns_failed_result ______________

    def test_008_disable_propagation_returns_failed_result() -> None:
        """
        With task_eager_propagates=False:
          - Some Celery builds still raise on get(..., propagate=True)
          - get(..., propagate=False) may return None OR return the exception object
        We accept both behaviors as long as the task is marked failed.
        """
>       app = _make_app()

tests\Celery\functional_test.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() got an unexpected keyword argument 'task_always_eager'

tests\Celery\functional_test.py:41: TypeError
_______________ test_009_signature_freeze_has_id_and_task_name ________________

    def test_009_signature_freeze_has_id_and_task_name() -> None:
>       app = _make_app()

tests\Celery\functional_test.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() got an unexpected keyword argument 'task_always_eager'

tests\Celery\functional_test.py:41: TypeError
____________ test_010_default_app_does_not_break_custom_app_usage _____________

    def test_010_default_app_does_not_break_custom_app_usage() -> None:
        """
        Ensure that importing celery and using a custom app is not polluted by globals.
        """
>       app = _make_app("celery_test_app_2")

tests\Celery\functional_test.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'celery_test_app_2'

    def _make_app(name: str = "celery_test_app"):
        _ensure_celery_importable()
        from celery import Celery
    
        app = Celery(
            name,
            broker="memory://",
            backend="cache+memory://",
            include=[],
        )
        # Pure local, synchronous execution: no broker/worker needed.
>       app.conf.update(
            task_always_eager=True,
            task_eager_propagates=True,
            task_store_eager_result=True,
            result_backend="cache+memory://",
            broker_url="memory://",
            enable_utc=True,
            timezone="UTC",
            accept_content=["json"],
            task_serializer="json",
            result_serializer="json",
        )
E       TypeError: update() got an unexpected keyword argument 'task_always_eager'

tests\Celery\functional_test.py:41: TypeError
=========================== short test summary info ===========================
FAILED tests/Celery/functional_test.py::test_001_import_celery_and_core_symbols
FAILED tests/Celery/functional_test.py::test_002_create_app_and_register_task_runs_delay
FAILED tests/Celery/functional_test.py::test_003_apply_async_supports_kwargs_and_counts_down_ignored_in_eager
FAILED tests/Celery/functional_test.py::test_004_group_collects_results_in_order
FAILED tests/Celery/functional_test.py::test_005_chain_passes_previous_result
FAILED tests/Celery/functional_test.py::test_006_chord_runs_callback_over_group_results
FAILED tests/Celery/functional_test.py::test_007_task_exception_propagates_in_eager_mode
FAILED tests/Celery/functional_test.py::test_008_disable_propagation_returns_failed_result
FAILED tests/Celery/functional_test.py::test_009_signature_freeze_has_id_and_task_name
FAILED tests/Celery/functional_test.py::test_010_default_app_does_not_break_custom_app_usage
10 failed in 0.68s

==========================================================================================
PROJECT: Click
LOG: D:\桌面\Exp1\deepseek-r1\results\Click\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
_______________ ERROR collecting tests/Click/functional_test.py _______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\Click\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\Click\functional_test.py:128: in <module>
    import click  # type: ignore  # noqa: E402
generation\Click\click\__init__.py:1: in <module>
    from .core import (
generation\Click\click\core.py:6: in <module>
    from .utils import echo, get_os_args
E   ImportError: cannot import name 'echo' from 'click.utils' (D:\桌面\RealAppCodeBench_generic_eval\generation\Click\click\utils.py)
=========================== short test summary info ===========================
ERROR tests/Click/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 2.96s

==========================================================================================
PROJECT: Cmd2
LOG: D:\桌面\Exp1\deepseek-r1\results\Cmd2\pytest_logs\functional.log
==========================================================================================
...........                                                              [100%]
11 passed in 3.10s

==========================================================================================
PROJECT: Fail2ban
LOG: D:\桌面\Exp1\deepseek-r1\results\Fail2ban\pytest_logs\functional.log
==========================================================================================
...F....F.FF                                                             [100%]
================================== FAILURES ===================================
________________ test_004_filter_core_symbols_exist_statically ________________

    def test_004_filter_core_symbols_exist_statically():
        """
        Do not assume helper names like isValidIP/searchIP (they vary across versions).
        Instead, require stable core anchors in fail2ban.server.filter:
          - A Filter class (or similarly named core filter object), OR
          - presence of key tokens that indicate regex-driven filtering (failregex/<HOST>).
        """
        filter_py = _pkg_dir() / "server" / "filter.py"
        src = _read_text(filter_py)
    
        has_filter_class = _ast_has_class(filter_py, "Filter") or ("class Filter" in src)
        has_regex_tokens = ("failregex" in src.lower()) or ("<host>" in src.lower())
    
>       assert has_filter_class or has_regex_tokens, "Expected core filter anchors (Filter class or failregex/<HOST> tokens)."
E       AssertionError: Expected core filter anchors (Filter class or failregex/<HOST> tokens).
E       assert (False or False)

tests\Fail2ban\functional_test.py:129: AssertionError
____________ test_009_import_filter_and_basic_behavior_if_possible ____________

    def test_009_import_filter_and_basic_behavior_if_possible():
        _prepend_import_path()
        try:
            from fail2ban.server import filter as f
        except ModuleNotFoundError as e:
            msg = str(e).lower()
            assert any(k in msg for k in ["pwd", "grp", "resource", "fcntl"]), f"Unexpected import failure: {e}"
            return
    
        # If import works, ensure the module exposes a core Filter-like object or regex constants.
        if hasattr(f, "Filter"):
            assert callable(getattr(f, "Filter"))
        else:
            src = _read_text(_pkg_dir() / "server" / "filter.py").lower()
>           assert ("failregex" in src) or ("<host>" in src)
E           assert ('failregex' in "import re\nimport ipaddress\n\ndef isvalidip(ip):\n    try:\n        ipaddress.ip_address(ip)\n        return true\n ...fa-f0-9:]+::?[a-fa-f0-9:]*)\\b'\n    match = re.search(ip_pattern, text)\n    return match.group(0) if match else none" or '<host>' in "import re\nimport ipaddress\n\ndef isvalidip(ip):\n    try:\n        ipaddress.ip_address(ip)\n        return true\n ...fa-f0-9:]+::?[a-fa-f0-9:]*)\\b'\n    match = re.search(ip_pattern, text)\n    return match.group(0) if match else none")

tests\Fail2ban\functional_test.py:187: AssertionError
_________________ test_011_fail2ban_regex_help_exits_quickly __________________

    def test_011_fail2ban_regex_help_exits_quickly():
        base = _resolve_repo_root()
        p = _run_script_help(base / "bin" / "fail2ban-regex", timeout_s=25)
        out = _out(p)
>       assert ("usage" in out) or ("options" in out) or ("fail2ban-regex" in out)
E       AssertionError: assert ('usage' in 'error: requires log file and pattern arguments\n\n' or 'options' in 'error: requires log file and pattern arguments\n\n' or 'fail2ban-regex' in 'error: requires log file and pattern arguments\n\n')

tests\Fail2ban\functional_test.py:202: AssertionError
___________ test_012_fail2ban_regex_matches_simple_pattern_offline ____________

    def test_012_fail2ban_regex_matches_simple_pattern_offline():
        """
        Offline-only functional check:
        - Create a temp log with repeated failure lines.
        - Run fail2ban-regex <LOG> <REGEX>
        - Assert output indicates it processed lines and found matches.
        """
        base = _resolve_repo_root()
        script = base / "bin" / "fail2ban-regex"
    
        env = os.environ.copy()
        env["PYTHONUNBUFFERED"] = "1"
        env["PYTHONPATH"] = str(_resolve_repo_root()) + (os.pathsep + env["PYTHONPATH"] if env.get("PYTHONPATH") else "")
    
        with tempfile.TemporaryDirectory(prefix="racb_fail2ban_") as td:
            logp = Path(td) / "auth.log"
            logp.write_text(
                "\n".join(
                    [
                        "Failed password for invalid user root from 203.0.113.5 port 2222 ssh2",
                        "Failed password for invalid user admin from 203.0.113.5 port 2223 ssh2",
                        "Accepted password for user ok from 198.51.100.2 port 3333 ssh2",
                        "Failed password for invalid user test from 203.0.113.9 port 4444 ssh2",
                    ]
                ),
                encoding="utf-8",
            )
    
            # Use a very simple regex (do not rely on <HOST> substitutions).
            regex = r"Failed password"
            p = subprocess.run(
                [sys.executable, str(script), str(logp), regex],
                text=True,
                input="",
                capture_output=True,
                timeout=30,
                env=env,
            )
            out = _out(p)
    
            # Must not hang; and should show it processed lines.
>           assert ("line" in out) or ("lines" in out)
E           AssertionError: assert ('line' in 'match: failed password for invalid user root from 203.0.113.5 port 2222 ssh2\nmatch: failed password for invalid user admin from 203.0.113.5 port 2223 ssh2\nmatch: failed password for invalid user test from 203.0.113.9 port 4444 ssh2\n\n' or 'lines' in 'match: failed password for invalid user root from 203.0.113.5 port 2222 ssh2\nmatch: failed password for invalid user admin from 203.0.113.5 port 2223 ssh2\nmatch: failed password for invalid user test from 203.0.113.9 port 4444 ssh2\n\n')

tests\Fail2ban\functional_test.py:246: AssertionError
=========================== short test summary info ===========================
FAILED tests/Fail2ban/functional_test.py::test_004_filter_core_symbols_exist_statically
FAILED tests/Fail2ban/functional_test.py::test_009_import_filter_and_basic_behavior_if_possible
FAILED tests/Fail2ban/functional_test.py::test_011_fail2ban_regex_help_exits_quickly
FAILED tests/Fail2ban/functional_test.py::test_012_fail2ban_regex_matches_simple_pattern_offline
4 failed, 8 passed in 1.18s

==========================================================================================
PROJECT: Folium
LOG: D:\桌面\Exp1\deepseek-r1\results\Folium\pytest_logs\functional.log
==========================================================================================
..FFFFFFFF.F                                                             [100%]
================================== FAILURES ===================================
__________________ test_002_create_basic_map_renders_leaflet __________________

    def test_002_create_basic_map_renders_leaflet():
        _prepend_import_path()
        import folium
    
>       m = folium.Map(location=[0, 0], zoom_start=2)

tests\Folium\functional_test.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <folium.map.Map object at 0x000002C46EE48700>, location = [0, 0]
zoom_start = 2, tiles = 'OpenStreetMap', width = '100%', height = '100%'

    def __init__(self, location=None, zoom_start=10, tiles='OpenStreetMap', width='100%', height='100%'):
        super().__init__()
        self.location = location or [0, 0]
        self.zoom_start = zoom_start
        self.width = width
        self.height = height
        self.tile_layer = None
        if tiles:
>           self.tile_layer = TileLayer(tiles).add_to(self)
E           NameError: name 'TileLayer' is not defined

generation\Folium\folium\map.py:14: NameError
_________________________ test_003_map_has_html_root __________________________

    def test_003_map_has_html_root():
        _prepend_import_path()
        import folium
    
>       m = folium.Map(location=[0, 0], zoom_start=2)

tests\Folium\functional_test.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <folium.map.Map object at 0x000002C46EE689D0>, location = [0, 0]
zoom_start = 2, tiles = 'OpenStreetMap', width = '100%', height = '100%'

    def __init__(self, location=None, zoom_start=10, tiles='OpenStreetMap', width='100%', height='100%'):
        super().__init__()
        self.location = location or [0, 0]
        self.zoom_start = zoom_start
        self.width = width
        self.height = height
        self.tile_layer = None
        if tiles:
>           self.tile_layer = TileLayer(tiles).add_to(self)
E           NameError: name 'TileLayer' is not defined

generation\Folium\folium\map.py:14: NameError
__________________ test_004_add_marker_layer_changes_output ___________________

    def test_004_add_marker_layer_changes_output():
        _prepend_import_path()
        import folium
    
>       m = folium.Map(location=[0, 0], zoom_start=2)

tests\Folium\functional_test.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <folium.map.Map object at 0x000002C46EE68280>, location = [0, 0]
zoom_start = 2, tiles = 'OpenStreetMap', width = '100%', height = '100%'

    def __init__(self, location=None, zoom_start=10, tiles='OpenStreetMap', width='100%', height='100%'):
        super().__init__()
        self.location = location or [0, 0]
        self.zoom_start = zoom_start
        self.width = width
        self.height = height
        self.tile_layer = None
        if tiles:
>           self.tile_layer = TileLayer(tiles).add_to(self)
E           NameError: name 'TileLayer' is not defined

generation\Folium\folium\map.py:14: NameError
__________________ test_005_add_circle_marker_changes_output __________________

    def test_005_add_circle_marker_changes_output():
        _prepend_import_path()
        import folium
    
>       m = folium.Map(location=[0, 0], zoom_start=2)

tests\Folium\functional_test.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <folium.map.Map object at 0x000002C46EE667C0>, location = [0, 0]
zoom_start = 2, tiles = 'OpenStreetMap', width = '100%', height = '100%'

    def __init__(self, location=None, zoom_start=10, tiles='OpenStreetMap', width='100%', height='100%'):
        super().__init__()
        self.location = location or [0, 0]
        self.zoom_start = zoom_start
        self.width = width
        self.height = height
        self.tile_layer = None
        if tiles:
>           self.tile_layer = TileLayer(tiles).add_to(self)
E           NameError: name 'TileLayer' is not defined

generation\Folium\folium\map.py:14: NameError
__________________ test_006_add_tile_layer_and_layer_control __________________

    def test_006_add_tile_layer_and_layer_control():
        _prepend_import_path()
        import folium
    
        m = folium.Map(location=[0, 0], zoom_start=2, tiles=None)
>       folium.TileLayer("OpenStreetMap", name="osm").add_to(m)
E       TypeError: __init__() got an unexpected keyword argument 'name'

tests\Folium\functional_test.py:92: TypeError
__________________ test_007_geojson_adds_feature_collection ___________________

    def test_007_geojson_adds_feature_collection():
        _prepend_import_path()
        import folium
    
        gj = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "properties": {"name": "p"},
                    "geometry": {"type": "Point", "coordinates": [0.0, 0.0]},
                }
            ],
        }
    
>       m = folium.Map(location=[0, 0], zoom_start=2)

tests\Folium\functional_test.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <folium.map.Map object at 0x000002C46EEA3790>, location = [0, 0]
zoom_start = 2, tiles = 'OpenStreetMap', width = '100%', height = '100%'

    def __init__(self, location=None, zoom_start=10, tiles='OpenStreetMap', width='100%', height='100%'):
        super().__init__()
        self.location = location or [0, 0]
        self.zoom_start = zoom_start
        self.width = width
        self.height = height
        self.tile_layer = None
        if tiles:
>           self.tile_layer = TileLayer(tiles).add_to(self)
E           NameError: name 'TileLayer' is not defined

generation\Folium\folium\map.py:14: NameError
_________________ test_008_geojson_style_function_serializes __________________

    def test_008_geojson_style_function_serializes():
        _prepend_import_path()
        import folium
    
        gj = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "properties": {"style": "x"},
                    "geometry": {"type": "Point", "coordinates": [0.0, 0.0]},
                }
            ],
        }
    
        def style_fn(feature):
            _ = feature
            return {"color": "red", "weight": 2}
    
>       m = folium.Map(location=[0, 0], zoom_start=2)

tests\Folium\functional_test.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <folium.map.Map object at 0x000002C46EE69880>, location = [0, 0]
zoom_start = 2, tiles = 'OpenStreetMap', width = '100%', height = '100%'

    def __init__(self, location=None, zoom_start=10, tiles='OpenStreetMap', width='100%', height='100%'):
        super().__init__()
        self.location = location or [0, 0]
        self.zoom_start = zoom_start
        self.width = width
        self.height = height
        self.tile_layer = None
        if tiles:
>           self.tile_layer = TileLayer(tiles).add_to(self)
E           NameError: name 'TileLayer' is not defined

generation\Folium\folium\map.py:14: NameError
________________________ test_009_map_save_writes_html ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-477/test_009_map_save_writes_html0')

    def test_009_map_save_writes_html(tmp_path: Path):
        _prepend_import_path()
        import folium
    
        out = tmp_path / "m.html"
>       m = folium.Map(location=[0, 0], zoom_start=2)

tests\Folium\functional_test.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <folium.map.Map object at 0x000002C46EEA3EE0>, location = [0, 0]
zoom_start = 2, tiles = 'OpenStreetMap', width = '100%', height = '100%'

    def __init__(self, location=None, zoom_start=10, tiles='OpenStreetMap', width='100%', height='100%'):
        super().__init__()
        self.location = location or [0, 0]
        self.zoom_start = zoom_start
        self.width = width
        self.height = height
        self.tile_layer = None
        if tiles:
>           self.tile_layer = TileLayer(tiles).add_to(self)
E           NameError: name 'TileLayer' is not defined

generation\Folium\folium\map.py:14: NameError
_________________ test_011_markercluster_adds_cluster_snippet _________________

    def test_011_markercluster_adds_cluster_snippet():
        _prepend_import_path()
        import folium
    
        plugins = _plugins_module()
        MarkerCluster = getattr(plugins, "MarkerCluster")
    
>       m = folium.Map(location=[0, 0], zoom_start=2)

tests\Folium\functional_test.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <folium.map.Map object at 0x000002C46EEB19D0>, location = [0, 0]
zoom_start = 2, tiles = 'OpenStreetMap', width = '100%', height = '100%'

    def __init__(self, location=None, zoom_start=10, tiles='OpenStreetMap', width='100%', height='100%'):
        super().__init__()
        self.location = location or [0, 0]
        self.zoom_start = zoom_start
        self.width = width
        self.height = height
        self.tile_layer = None
        if tiles:
>           self.tile_layer = TileLayer(tiles).add_to(self)
E           NameError: name 'TileLayer' is not defined

generation\Folium\folium\map.py:14: NameError
=========================== short test summary info ===========================
FAILED tests/Folium/functional_test.py::test_002_create_basic_map_renders_leaflet
FAILED tests/Folium/functional_test.py::test_003_map_has_html_root - NameErro...
FAILED tests/Folium/functional_test.py::test_004_add_marker_layer_changes_output
FAILED tests/Folium/functional_test.py::test_005_add_circle_marker_changes_output
FAILED tests/Folium/functional_test.py::test_006_add_tile_layer_and_layer_control
FAILED tests/Folium/functional_test.py::test_007_geojson_adds_feature_collection
FAILED tests/Folium/functional_test.py::test_008_geojson_style_function_serializes
FAILED tests/Folium/functional_test.py::test_009_map_save_writes_html - NameE...
FAILED tests/Folium/functional_test.py::test_011_markercluster_adds_cluster_snippet
9 failed, 3 passed in 0.67s

==========================================================================================
PROJECT: Lifelines
LOG: D:\桌面\Exp1\deepseek-r1\results\Lifelines\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFFFFFF                                                          [100%]
================================== FAILURES ===================================
______________________ test_kmf_on_small_manual_dataset _______________________

    def test_kmf_on_small_manual_dataset() -> None:
        """Basic sanity check for KaplanMeierFitter on a tiny dataset."""
        durations, events = _toy_kmf_data()
    
        kmf = KaplanMeierFitter()
>       kmf.fit(durations=durations, event_observed=events, label="test")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:84: TypeError
_________________________ test_kmf_on_waltons_groups __________________________

    def test_kmf_on_waltons_groups() -> None:
        """Fit KMF on the Waltons dataset for two groups."""
        df = load_waltons()
        assert {"T", "E", "group"}.issubset(df.columns)
    
        control = df[df["group"] == "control"]
        treated = df[df["group"] != "control"]
    
        kmf_control = KaplanMeierFitter()
        kmf_treated = KaplanMeierFitter()
    
>       kmf_control.fit(control["T"], control["E"], label="control")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:105: TypeError
____________________________ test_coxph_basic_fit _____________________________

    def test_coxph_basic_fit() -> None:
        """Fit a simple Cox proportional hazards model on a toy dataset."""
        df = _toy_cox_df()
    
        cph = CoxPHFitter()
        cph.fit(df, duration_col="duration", event_col="event")
        summary = cph.summary
    
        assert "coef" in summary.columns
        assert "se(coef)" in summary.columns
>       assert "p" in summary.columns or "p" in "".join(summary.columns).lower()
E       AssertionError: assert ('p' in Index(['coef', 'se(coef)'], dtype='object') or 'p' in 'coefse(coef)')
E        +  where Index(['coef', 'se(coef)'], dtype='object') =                coef  se(coef)\nage        0.043368       0.1\ntreatment -0.027688       0.1.columns
E        +  and   'coefse(coef)' = <built-in method lower of str object at 0x000002424803CAB0>()
E        +    where <built-in method lower of str object at 0x000002424803CAB0> = 'coefse(coef)'.lower
E        +      where 'coefse(coef)' = <built-in method join of str object at 0x0000024225764670>(Index(['coef', 'se(coef)'], dtype='object'))
E        +        where <built-in method join of str object at 0x0000024225764670> = ''.join
E        +        and   Index(['coef', 'se(coef)'], dtype='object') =                coef  se(coef)\nage        0.043368       0.1\ntreatment -0.027688       0.1.columns

tests\Lifelines\functional_test.py:127: AssertionError
____________________ test_kmf_predict_at_time_zero_is_one _____________________

    def test_kmf_predict_at_time_zero_is_one() -> None:
        """KMF predict at t=0 should be 1.0 for standard KM survival."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:140: TypeError
________________ test_kmf_predict_is_non_increasing_over_time _________________

    def test_kmf_predict_is_non_increasing_over_time() -> None:
        """KMF predicted survival should not increase as time increases."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:148: TypeError
________________ test_kmf_cumulative_density_is_non_decreasing ________________

    def test_kmf_cumulative_density_is_non_decreasing() -> None:
        """Cumulative density should be non-decreasing and within [0, 1]."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:169: TypeError
__________________ test_kmf_event_table_has_standard_columns __________________

    def test_kmf_event_table_has_standard_columns() -> None:
        """KM event table should include standard bookkeeping columns."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:182: TypeError
_____________ test_kmf_confidence_interval_matches_survival_index _____________

    def test_kmf_confidence_interval_matches_survival_index() -> None:
        """Confidence intervals should align with survival function index."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:191: TypeError
___________ test_kmf_median_survival_time_is_within_duration_range ____________

    def test_kmf_median_survival_time_is_within_duration_range() -> None:
        """Median survival time should be within the observed duration range."""
        durations, events = _toy_kmf_data()
>       kmf = KaplanMeierFitter().fit(durations=durations, event_observed=events, label="km")
E       TypeError: fit() got an unexpected keyword argument 'label'

tests\Lifelines\functional_test.py:204: TypeError
_________________ test_coxph_params_index_matches_covariates __________________

    def test_coxph_params_index_matches_covariates() -> None:
        """Cox model params_ should be indexed by covariate names."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
        params = cph.params_
>       assert list(params.index) == ["age", "treatment"]
E       AttributeError: 'numpy.ndarray' object has no attribute 'index'

tests\Lifelines\functional_test.py:216: AttributeError
___________ test_coxph_baseline_cumulative_hazard_is_non_decreasing ___________

    def test_coxph_baseline_cumulative_hazard_is_non_decreasing() -> None:
        """Baseline cumulative hazard should be non-decreasing over time."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
>       bch = cph.baseline_cumulative_hazard_
E       AttributeError: 'CoxPHFitter' object has no attribute 'baseline_cumulative_hazard_'

tests\Lifelines\functional_test.py:225: AttributeError
__________ test_coxph_predict_partial_hazard_is_positive_and_varies ___________

    def test_coxph_predict_partial_hazard_is_positive_and_varies() -> None:
        """Partial hazards should be positive and reflect covariate differences."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
        x_low = pd.DataFrame({"age": [25], "treatment": [0]})
        x_high = pd.DataFrame({"age": [55], "treatment": [1]})
    
>       h_low = float(cph.predict_partial_hazard(x_low).iloc[0])
E       AttributeError: 'CoxPHFitter' object has no attribute 'predict_partial_hazard'

tests\Lifelines\functional_test.py:240: AttributeError
____________ test_coxph_predict_survival_function_shape_and_bounds ____________

    def test_coxph_predict_survival_function_shape_and_bounds() -> None:
        """Predict survival functions for two individuals; verify shape and bounds."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
        x = pd.DataFrame({"age": [30, 60], "treatment": [0, 1]})
>       sf = cph.predict_survival_function(x)

tests\Lifelines\functional_test.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <lifelines.estimators.coxph.CoxPHFitter object at 0x00000242480D0130>
row =    age  treatment
0   30          0
1   60          1

    def predict_survival_function(self, row: pd.DataFrame) -> pd.DataFrame:
        """
        Predict survival function for a single observation.
    
        Parameters
        ----------
        row : pandas.DataFrame
            Single-row DataFrame with same covariates as training data.
    
        Returns
        -------
        pandas.DataFrame
            Survival function with values in [0, 1].
        """
        if not self._fitted:
            raise ValueError("Model must be fitted before prediction.")
    
        # Extract covariates (exclude duration and event columns if present)
        covariate_cols = self._summary.index.tolist()
        covariates = row[covariate_cols].values.astype(np.float64).flatten()
    
        # Calculate linear predictor
>       linear_predictor = np.dot(covariates, self.params_)
E       ValueError: shapes (4,) and (2,) not aligned: 4 (dim 0) != 2 (dim 0)

generation\Lifelines\lifelines\estimators\coxph.py:147: ValueError
________________ test_coxph_concordance_index_in_unit_interval ________________

    def test_coxph_concordance_index_in_unit_interval() -> None:
        """Concordance index should lie in [0, 1] after fitting."""
        df = _toy_cox_df()
        cph = CoxPHFitter().fit(df, duration_col="duration", event_col="event")
    
>       c = float(cph.concordance_index_)
E       AttributeError: 'CoxPHFitter' object has no attribute 'concordance_index_'

tests\Lifelines\functional_test.py:269: AttributeError
_____________ test_coxph_fit_on_waltons_with_binary_group_feature _____________

    def test_coxph_fit_on_waltons_with_binary_group_feature() -> None:
        """Fit CoxPH on Waltons dataset using a binary treated indicator derived from group."""
        df = load_waltons()
        assert {"T", "E", "group"}.issubset(df.columns)
    
        df2 = df.copy()
        df2["treated"] = (df2["group"] != "control").astype(int)
    
        model_df = df2[["T", "E", "treated"]].rename(columns={"T": "duration", "E": "event"})
    
        cph = CoxPHFitter()
        cph.fit(model_df, duration_col="duration", event_col="event")
    
>       coef = float(cph.params_.loc["treated"])
E       AttributeError: 'numpy.ndarray' object has no attribute 'loc'

tests\Lifelines\functional_test.py:286: AttributeError
=========================== short test summary info ===========================
FAILED tests/Lifelines/functional_test.py::test_kmf_on_small_manual_dataset
FAILED tests/Lifelines/functional_test.py::test_kmf_on_waltons_groups - TypeE...
FAILED tests/Lifelines/functional_test.py::test_coxph_basic_fit - AssertionEr...
FAILED tests/Lifelines/functional_test.py::test_kmf_predict_at_time_zero_is_one
FAILED tests/Lifelines/functional_test.py::test_kmf_predict_is_non_increasing_over_time
FAILED tests/Lifelines/functional_test.py::test_kmf_cumulative_density_is_non_decreasing
FAILED tests/Lifelines/functional_test.py::test_kmf_event_table_has_standard_columns
FAILED tests/Lifelines/functional_test.py::test_kmf_confidence_interval_matches_survival_index
FAILED tests/Lifelines/functional_test.py::test_kmf_median_survival_time_is_within_duration_range
FAILED tests/Lifelines/functional_test.py::test_coxph_params_index_matches_covariates
FAILED tests/Lifelines/functional_test.py::test_coxph_baseline_cumulative_hazard_is_non_decreasing
FAILED tests/Lifelines/functional_test.py::test_coxph_predict_partial_hazard_is_positive_and_varies
FAILED tests/Lifelines/functional_test.py::test_coxph_predict_survival_function_shape_and_bounds
FAILED tests/Lifelines/functional_test.py::test_coxph_concordance_index_in_unit_interval
FAILED tests/Lifelines/functional_test.py::test_coxph_fit_on_waltons_with_binary_group_feature
15 failed in 3.36s

==========================================================================================
PROJECT: Mailpile
LOG: D:\桌面\Exp1\deepseek-r1\results\Mailpile\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
_____________ ERROR collecting tests/Mailpile/functional_test.py ______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\Mailpile\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\Mailpile\functional_test.py:176: in <module>
    from mailpile.safe_popen import PIPE, Popen, Safe_Pipe  # type: ignore
E   ImportError: cannot import name 'PIPE' from 'mailpile.safe_popen' (D:\桌面\RealAppCodeBench_generic_eval\.converted\Mailpile\generated\mailpile\safe_popen.py)
=========================== short test summary info ===========================
ERROR tests/Mailpile/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 1.79s

==========================================================================================
PROJECT: Markdown
LOG: D:\桌面\Exp1\deepseek-r1\results\Markdown\pytest_logs\functional.log
==========================================================================================

1 skipped in 0.13s

==========================================================================================
PROJECT: Mitmproxy
LOG: D:\桌面\Exp1\deepseek-r1\results\Mitmproxy\pytest_logs\functional.log
==========================================================================================
........FFF                                                              [100%]
================================== FAILURES ===================================
________________ test_009_proxy_mode_specs_mentions_ProxyMode _________________

    def test_009_proxy_mode_specs_mentions_ProxyMode():
        """
        Anchor: mitmproxy.proxy.mode_specs is part of the CLI import chain.
        Runtime import may require mitmproxy_rs; we assert the file contains ProxyMode constructs.
        """
        pkg = _mitmproxy_pkg_dir()
        ms_py = pkg / "proxy" / "mode_specs.py"
>       assert ms_py.is_file()
E       AssertionError: assert False
E        +  where False = is_file()
E        +    where is_file = WindowsPath('D:/桌面/RealAppCodeBench_generic_eval/generation/Mitmproxy/mitmproxy/proxy/mode_specs.py').is_file

tests\Mitmproxy\functional_test.py:156: AssertionError
_________ test_010_conditional_import_http_module_depends_on_OpenSSL __________

    def test_010_conditional_import_http_module_depends_on_OpenSSL():
        """
        Importing mitmproxy.http may require pyOpenSSL (OpenSSL module) through mitmproxy.certs.
        If OpenSSL is installed, import must succeed.
        If not installed, import must fail with ModuleNotFoundError mentioning OpenSSL.
        """
        _prepend_import_path()
        have_openssl = _has_module("OpenSSL")
        if have_openssl:
            import mitmproxy.http  # noqa: F401
        else:
            with pytest.raises(ModuleNotFoundError) as ei:
>               import mitmproxy.http  # noqa: F401
E               Failed: DID NOT RAISE <class 'ModuleNotFoundError'>

tests\Mitmproxy\functional_test.py:173: Failed
_______ test_011_conditional_import_tools_main_depends_on_mitmproxy_rs ________

    def test_011_conditional_import_tools_main_depends_on_mitmproxy_rs():
        """
        Importing mitmproxy.tools.main currently pulls in mitmproxy.proxy.mode_specs,
        which imports mitmproxy_rs. If mitmproxy_rs is installed, import should succeed.
        Otherwise, it should fail with ModuleNotFoundError mentioning mitmproxy_rs.
        """
        _prepend_import_path()
        have_rs = _has_module("mitmproxy_rs")
        if have_rs:
            from mitmproxy.tools import main as tools_main  # noqa: F401
            assert hasattr(tools_main, "mitmdump")
        else:
            with pytest.raises(ModuleNotFoundError) as ei:
>               from mitmproxy.tools import main as tools_main  # noqa: F401
E               Failed: DID NOT RAISE <class 'ModuleNotFoundError'>

tests\Mitmproxy\functional_test.py:190: Failed
=========================== short test summary info ===========================
FAILED tests/Mitmproxy/functional_test.py::test_009_proxy_mode_specs_mentions_ProxyMode
FAILED tests/Mitmproxy/functional_test.py::test_010_conditional_import_http_module_depends_on_OpenSSL
FAILED tests/Mitmproxy/functional_test.py::test_011_conditional_import_tools_main_depends_on_mitmproxy_rs
3 failed, 8 passed in 0.54s

==========================================================================================
PROJECT: Mutagen
LOG: D:\桌面\Exp1\deepseek-r1\results\Mutagen\pytest_logs\functional.log
==========================================================================================

1 skipped in 0.12s

==========================================================================================
PROJECT: Pendulum
LOG: D:\桌面\Exp1\deepseek-r1\results\Pendulum\pytest_logs\functional.log
==========================================================================================

1 skipped in 0.15s

==========================================================================================
PROJECT: Petl
LOG: D:\桌面\Exp1\deepseek-r1\results\Petl\pytest_logs\functional.log
==========================================================================================

1 skipped in 0.17s

==========================================================================================
PROJECT: Pygments
LOG: D:\桌面\Exp1\deepseek-r1\results\Pygments\pytest_logs\functional.log
==========================================================================================
Traceback (most recent call last):
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\runpy.py", line 188, in _run_module_as_main
    mod_name, mod_spec, code = _get_module_details(mod_name, _Error)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\runpy.py", line 147, in _get_module_details
    return _get_module_details(pkg_main_name, error)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\runpy.py", line 111, in _get_module_details
    __import__(pkg_name)
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\pytest\__init__.py", line 8, in <module>
    from _pytest._code import ExceptionInfo
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_code\__init__.py", line 5, in <module>
    from .code import Code
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_code\code.py", line 44, in <module>
    from _pytest._io import TerminalWriter
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_io\__init__.py", line 3, in <module>
    from .terminalwriter import get_terminal_width
  File "C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\site-packages\_pytest\_io\terminalwriter.py", line 13, in <module>
    import pygments
  File "D:\桌面\RealAppCodeBench_generic_eval\generation\Pygments\pygments\__init__.py", line 12, in <module>
    from pygments import lexers
  File "D:\桌面\RealAppCodeBench_generic_eval\generation\Pygments\pygments\lexers\__init__.py", line 6, in <module>
    from pygments.lexer import Lexer, RegexLexer
ModuleNotFoundError: No module named 'pygments.lexer'

==========================================================================================
PROJECT: PyJWT
LOG: D:\桌面\Exp1\deepseek-r1\results\PyJWT\pytest_logs\functional.log
==========================================================================================
.F.FF...F.s                                                              [100%]
================================== FAILURES ===================================
_____________________ test_hs512_encode_decode_roundtrip ______________________

    def test_hs512_encode_decode_roundtrip() -> None:
        payload = {"scope": ["read", "write"], "active": True}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS512")

tests\PyJWT\functional_test.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
generation\PyJWT\jwt\__init__.py:28: in encode
    return _encode(payload, key, algorithm, **kwargs)
generation\PyJWT\jwt\api_jwt.py:63: in encode
    signature = _sign(msg, key, algorithm)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

msg = b'eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzY29wZSI6WyJyZWFkIiwid3JpdGUiXSwiYWN0aXZlIjp0cnVlfQ'
key = 'secret', algorithm = 'HS512'

    def _sign(msg: bytes, key: str, algorithm: str) -> str:
        """Create HMAC signature."""
        if algorithm != "HS256":
>           raise DecodeError("Algorithm not supported")
E           jwt.exceptions.DecodeError: Algorithm not supported

generation\PyJWT\jwt\api_jwt.py:31: DecodeError
_______________ test_encode_decode_with_datetime_exp_in_future ________________

    def test_encode_decode_with_datetime_exp_in_future() -> None:
        exp_dt = _fixed_dt_utc(2099, 1, 1, 0, 0, 0)
        payload = {"sub": "u-123", "exp": exp_dt}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS256")

tests\PyJWT\functional_test.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
generation\PyJWT\jwt\__init__.py:28: in encode
    return _encode(payload, key, algorithm, **kwargs)
generation\PyJWT\jwt\api_jwt.py:58: in encode
    payload_json = json.dumps(payload, separators=(',', ':')).encode('utf-8')
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x00000291E4FC7CD0>
o = datetime.datetime(2099, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
________________ test_encode_decode_with_datetime_nbf_in_past _________________

    def test_encode_decode_with_datetime_nbf_in_past() -> None:
        nbf_dt = _fixed_dt_utc(2000, 1, 1, 0, 0, 0)
        payload = {"feature": "enabled", "nbf": nbf_dt}
>       decoded = _encode_decode(payload, key="secret", algorithm="HS256")

tests\PyJWT\functional_test.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\PyJWT\functional_test.py:130: in _encode_decode
    token = _normalize_token(jwt.encode(payload, key, algorithm=algorithm))
generation\PyJWT\jwt\__init__.py:28: in encode
    return _encode(payload, key, algorithm, **kwargs)
generation\PyJWT\jwt\api_jwt.py:58: in encode
    payload_json = json.dumps(payload, separators=(',', ':')).encode('utf-8')
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\__init__.py:234: in dumps
    return cls(
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:199: in encode
    chunks = self.iterencode(o, _one_shot=True)
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:257: in iterencode
    return _iterencode(o, 0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x00000291E5035CD0>
o = datetime.datetime(2000, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type datetime is not JSON serializable

C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\json\encoder.py:179: TypeError
_____________ test_unverified_header_contains_alg_and_custom_kid ______________

    def test_unverified_header_contains_alg_and_custom_kid() -> None:
        payload = {"foo": "bar"}
        key = "secret"
        token = _normalize_token(jwt.encode(payload, key, algorithm="HS256", headers={"kid": "k1", "typ": "JWT"}))
    
>       header = jwt.get_unverified_header(token)
E       AttributeError: module 'jwt' has no attribute 'get_unverified_header'

tests\PyJWT\functional_test.py:210: AttributeError
=========================== short test summary info ===========================
FAILED tests/PyJWT/functional_test.py::test_hs512_encode_decode_roundtrip - j...
FAILED tests/PyJWT/functional_test.py::test_encode_decode_with_datetime_exp_in_future
FAILED tests/PyJWT/functional_test.py::test_encode_decode_with_datetime_nbf_in_past
FAILED tests/PyJWT/functional_test.py::test_unverified_header_contains_alg_and_custom_kid
4 failed, 6 passed, 1 skipped in 0.63s

==========================================================================================
PROJECT: Requests
LOG: D:\桌面\Exp1\deepseek-r1\results\Requests\pytest_logs\functional.log
==========================================================================================
..........                                                               [100%]
10 passed in 2.71s

==========================================================================================
PROJECT: Schedule
LOG: D:\桌面\Exp1\deepseek-r1\results\Schedule\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFFF                                                             [100%]
================================== FAILURES ===================================
________________________ test_basic_every_and_run_all _________________________

    def test_basic_every_and_run_all() -> None:
        """every(...).seconds/minutes + run_all execute jobs."""
        _clear()
        calls: List[str] = []
    
        def job1() -> None:
            calls.append("job1")
    
        def job2() -> None:
            calls.append("job2")
    
>       schedule.every(5).seconds.do(job1).tag("sec", "common")
E       AttributeError: 'function' object has no attribute 'do'

tests\Schedule\functional_test.py:97: AttributeError
_________________________ test_tags_and_clear_by_tag __________________________

    def test_tags_and_clear_by_tag() -> None:
        """Jobs can be tagged, selected by tag, and cleared by tag."""
        _clear()
        calls: List[str] = []
    
        def job_keep() -> None:
            calls.append("keep")
    
        def job_drop() -> None:
            calls.append("drop")
    
>       schedule.every().hour.do(job_keep).tag("keep", "group")
E       AttributeError: 'Job' object has no attribute 'hour'

tests\Schedule\functional_test.py:121: AttributeError
_____________________ test_cancel_job_removes_single_job ______________________

    def test_cancel_job_removes_single_job() -> None:
        """cancel_job removes a single job from the scheduler."""
        _clear()
        calls: List[str] = []
    
        def job1() -> None:
            calls.append("job1")
    
        def job2() -> None:
            calls.append("job2")
    
>       j1 = schedule.every().day.do(job1)
E       AttributeError: 'Job' object has no attribute 'day'

tests\Schedule\functional_test.py:148: AttributeError
__________________ test_repeat_decorator_registers_and_runs ___________________

    def test_repeat_decorator_registers_and_runs() -> None:
        """@repeat(every(...)) schedules a function correctly and run_all triggers it."""
        _clear()
        call_count = 0
    
>       @schedule.repeat(schedule.every().seconds)
E       AttributeError: module 'schedule' has no attribute 'repeat'

tests\Schedule\functional_test.py:164: AttributeError
_______________ test_run_pending_executes_due_job_without_sleep _______________

    def test_run_pending_executes_due_job_without_sleep() -> None:
        """run_pending executes jobs that are due, without relying on real time waiting."""
        _clear()
        calls: List[str] = []
    
        def job() -> None:
            calls.append("ran")
    
>       j = schedule.every(10).seconds.do(job)
E       AttributeError: 'function' object has no attribute 'do'

tests\Schedule\functional_test.py:184: AttributeError
_______________ test_job_next_run_is_datetime_after_scheduling ________________

    def test_job_next_run_is_datetime_after_scheduling() -> None:
        """A newly scheduled job should have a next_run datetime set."""
        _clear()
    
        def job() -> None:
            return None
    
>       j = schedule.every().minute.do(job)
E       AttributeError: 'Job' object has no attribute 'minute'

tests\Schedule\functional_test.py:198: AttributeError
______________ test_every_day_at_sets_time_component_in_next_run ______________

    def test_every_day_at_sets_time_component_in_next_run() -> None:
        """Scheduling with .day.at('HH:MM') should include that time in the next_run."""
        _clear()
    
        def job() -> None:
            return None
    
>       j = schedule.every().day.at("10:30").do(job)
E       AttributeError: 'Job' object has no attribute 'day'

tests\Schedule\functional_test.py:210: AttributeError
______________ test_weekday_scheduling_creates_job_and_next_run _______________

    def test_weekday_scheduling_creates_job_and_next_run() -> None:
        """Weekday scheduling (e.g., monday) should create a job with next_run."""
        _clear()
    
        def job() -> None:
            return None
    
>       j = schedule.every().monday.at("09:00").do(job)
E       AttributeError: 'function' object has no attribute 'at'

tests\Schedule\functional_test.py:224: AttributeError
________________ test_every_to_creates_job_with_interval_range ________________

    def test_every_to_creates_job_with_interval_range() -> None:
        """every(A).to(B).seconds should create a job and be runnable via run_all."""
        _clear()
        calls: List[str] = []
    
        def job() -> None:
            calls.append("x")
    
>       j = schedule.every(2).to(5).seconds.do(job)
E       AttributeError: 'Job' object has no attribute 'to'

tests\Schedule\functional_test.py:239: AttributeError
______________________ test_idle_seconds_returns_number _______________________

    def test_idle_seconds_returns_number() -> None:
        """idle_seconds should return a numeric value when jobs exist."""
        _clear()
    
        def job() -> None:
            return None
    
>       schedule.every().hour.do(job)
E       AttributeError: 'Job' object has no attribute 'hour'

tests\Schedule\functional_test.py:253: AttributeError
_____________________ test_get_jobs_by_tag_filters_subset _____________________

    def test_get_jobs_by_tag_filters_subset() -> None:
        """get_jobs(tag) should return only jobs with that tag."""
        _clear()
    
        def a() -> None:
            return None
    
        def b() -> None:
            return None
    
>       schedule.every().minute.do(a).tag("alpha")
E       AttributeError: 'Job' object has no attribute 'minute'

tests\Schedule\functional_test.py:269: AttributeError
______________________ test_run_all_sets_last_run_on_job ______________________

    def test_run_all_sets_last_run_on_job() -> None:
        """After running, last_run should be populated on the job in typical implementations."""
        _clear()
    
        def job() -> None:
            return None
    
>       j = schedule.every().minute.do(job)
E       AttributeError: 'Job' object has no attribute 'minute'

tests\Schedule\functional_test.py:290: AttributeError
=========================== short test summary info ===========================
FAILED tests/Schedule/functional_test.py::test_basic_every_and_run_all - Attr...
FAILED tests/Schedule/functional_test.py::test_tags_and_clear_by_tag - Attrib...
FAILED tests/Schedule/functional_test.py::test_cancel_job_removes_single_job
FAILED tests/Schedule/functional_test.py::test_repeat_decorator_registers_and_runs
FAILED tests/Schedule/functional_test.py::test_run_pending_executes_due_job_without_sleep
FAILED tests/Schedule/functional_test.py::test_job_next_run_is_datetime_after_scheduling
FAILED tests/Schedule/functional_test.py::test_every_day_at_sets_time_component_in_next_run
FAILED tests/Schedule/functional_test.py::test_weekday_scheduling_creates_job_and_next_run
FAILED tests/Schedule/functional_test.py::test_every_to_creates_job_with_interval_range
FAILED tests/Schedule/functional_test.py::test_idle_seconds_returns_number - ...
FAILED tests/Schedule/functional_test.py::test_get_jobs_by_tag_filters_subset
FAILED tests/Schedule/functional_test.py::test_run_all_sets_last_run_on_job
12 failed in 0.58s

==========================================================================================
PROJECT: Sqlmap
LOG: D:\桌面\Exp1\deepseek-r1\results\Sqlmap\pytest_logs\functional.log
==========================================================================================
.........                                                                [100%]
9 passed in 1.91s

==========================================================================================
PROJECT: Stegano
LOG: D:\桌面\Exp1\deepseek-r1\results\Stegano\pytest_logs\functional.log
==========================================================================================
FFFFFF..FFFF                                                             [100%]
================================== FAILURES ===================================
________________________ test_lsb_hide_and_reveal_text ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-478/test_lsb_hide_and_reveal_text0')

    def test_lsb_hide_and_reveal_text(tmp_path: Path) -> None:
        """lsb.hide(..., str) then lsb.reveal(...) returns the same string."""
        _ensure_image_samples_exist()
    
        secret = "hello world"
        output = tmp_path / "lsb_lenna.png"
    
>       encoded_img = lsb.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'hello world', generator = None, shift = 0, encoding = 'UTF-8'
auto_convert_rgb = False

    def hide(image, message, generator=None, shift=0, encoding="UTF-8", auto_convert_rgb=False):
        if auto_convert_rgb:
            image = convert_image(image)
>       pixels = image.load()
E       AttributeError: 'str' object has no attribute 'load'

generation\Stegano\stegano\lsb\lsb.py:9: AttributeError
___________________ test_lsb_hide_and_reveal_with_generator ___________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-478/test_lsb_hide_and_reveal_with_0')

    def test_lsb_hide_and_reveal_with_generator(tmp_path: Path) -> None:
        """lsb hide/reveal with a deterministic generator."""
        _ensure_image_samples_exist()
    
        secret = "generator secret"
        output = tmp_path / "lsb_generator.png"
    
        gen = generators.eratosthenes()
>       encoded_img = lsb.hide(str(LENNA_PNG), secret, generator=gen)

tests\Stegano\functional_test.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'generator secret'
generator = <generator object eratosthenes at 0x0000025B3B889C80>, shift = 0
encoding = 'UTF-8', auto_convert_rgb = False

    def hide(image, message, generator=None, shift=0, encoding="UTF-8", auto_convert_rgb=False):
        if auto_convert_rgb:
            image = convert_image(image)
>       pixels = image.load()
E       AttributeError: 'str' object has no attribute 'load'

generation\Stegano\stegano\lsb\lsb.py:9: AttributeError
__________________ test_lsb_hide_and_reveal_long_ascii_text ___________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-478/test_lsb_hide_and_reveal_long_0')

    def test_lsb_hide_and_reveal_long_ascii_text(tmp_path: Path) -> None:
        """LSB should roundtrip a longer ASCII text message (still < typical capacity)."""
        _ensure_image_samples_exist()
    
        secret = "This is a longer secret message with punctuation: 12345, hello-world!"
        output = tmp_path / "lsb_long.png"
    
>       encoded_img = lsb.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'This is a longer secret message with punctuation: 12345, hello-world!'
generator = None, shift = 0, encoding = 'UTF-8', auto_convert_rgb = False

    def hide(image, message, generator=None, shift=0, encoding="UTF-8", auto_convert_rgb=False):
        if auto_convert_rgb:
            image = convert_image(image)
>       pixels = image.load()
E       AttributeError: 'str' object has no attribute 'load'

generation\Stegano\stegano\lsb\lsb.py:9: AttributeError
______________________ test_lsb_reveal_from_image_object ______________________

    def test_lsb_reveal_from_image_object() -> None:
        """lsb.reveal should work when passed a PIL.Image object (common API usage)."""
        _ensure_image_samples_exist()
    
        secret = "object input"
>       img_obj = lsb.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'object input', generator = None, shift = 0, encoding = 'UTF-8'
auto_convert_rgb = False

    def hide(image, message, generator=None, shift=0, encoding="UTF-8", auto_convert_rgb=False):
        if auto_convert_rgb:
            image = convert_image(image)
>       pixels = image.load()
E       AttributeError: 'str' object has no attribute 'load'

generation\Stegano\stegano\lsb\lsb.py:9: AttributeError
________________________ test_red_hide_and_reveal_text ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-478/test_red_hide_and_reveal_text0')

    def test_red_hide_and_reveal_text(tmp_path: Path) -> None:
        """red.hide(..., str) then red.reveal(...) returns the same string."""
        _ensure_image_samples_exist()
    
        secret = "red secret"
        output = tmp_path / "red_lenna.png"
    
>       encoded_img = red.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Stegano\stegano\red\red.py:6: in hide
    image = convert_image(image)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'

    def convert_image(image):
>       if image.mode not in ('RGB', 'RGBA'):
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\tools\utils.py:4: AttributeError
________________ test_red_hide_and_reveal_extended_latin_text _________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-478/test_red_hide_and_reveal_exten0')

    def test_red_hide_and_reveal_extended_latin_text(tmp_path: Path) -> None:
        """Red backend stores per-char ord() into a byte channel; Latin-1 chars like 'é' are valid."""
        _ensure_image_samples_exist()
    
        secret = "Café au lait"
        output = tmp_path / "red_latin.png"
    
>       encoded_img = red.hide(str(LENNA_PNG), secret)

tests\Stegano\functional_test.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Stegano\stegano\red\red.py:6: in hide
    image = convert_image(image)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'

    def convert_image(image):
>       if image.mode not in ('RGB', 'RGBA'):
E       AttributeError: 'str' object has no attribute 'mode'

generation\Stegano\stegano\tools\utils.py:4: AttributeError
________________________ test_wav_hide_and_reveal_text ________________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-478/test_wav_hide_and_reveal_text0')

    def test_wav_hide_and_reveal_text(tmp_path: Path) -> None:
        """wav.hide writes output WAV; wav.reveal returns the same string."""
        wav_in = _pick_sample_wav()
    
        secret = "wav secret"
        output = tmp_path / "out.wav"
    
        wav.hide(str(wav_in), secret, str(output))
        assert output.exists()
        assert output.stat().st_size > 0
    
        revealed = wav.reveal(str(output))
>       assert revealed == secret
E       assert '~j(\x12.-\rE...\x0b{\x17\x7f' == 'wav secret'
E         
E         - wav secret
E         + ~j(.-
E         + E~
E         + ("(?}"+tT
E         
E         + J'y\xaae^h(\x08\x0f\u04f2\x08gu9(*g]TW("...
E         
E         ...Full output truncated (9 lines hidden), use '-vv' to show

tests\Stegano\functional_test.py:224: AssertionError
_____________________ test_wav_hide_and_reveal_short_text _____________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-478/test_wav_hide_and_reveal_short0')

    def test_wav_hide_and_reveal_short_text(tmp_path: Path) -> None:
        """A short message should also roundtrip."""
        wav_in = _pick_sample_wav()
    
        secret = "ok"
        output = tmp_path / "out_short.wav"
    
        wav.hide(str(wav_in), secret, str(output))
        assert output.exists()
        assert output.stat().st_size > 0
    
        revealed = wav.reveal(str(output))
>       assert revealed == secret
E       assert '|(,E"(\x15\x...\x0b{\x17\x7f' == 'ok'
E         
E         - ok
E         + |(,E"(U|T
E         
E         + J'y\xaae^h(\x08\x0f\u04f2\x08gu9(*g]TW("
E         + ut _:5LV{TZ
E         ...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

tests\Stegano\functional_test.py:239: AssertionError
____________________ test_wav_hide_and_reveal_longer_text _____________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-478/test_wav_hide_and_reveal_longe0')

    def test_wav_hide_and_reveal_longer_text(tmp_path: Path) -> None:
        """Roundtrip a longer ASCII message via WAV backend."""
        wav_in = _pick_sample_wav()
    
        secret = "WAV backend long message: 1234567890 abcdefghijklmnopqrstuvwxyz"
        output = tmp_path / "out_long.wav"
    
        wav.hide(str(wav_in), secret, str(output))
        assert output.exists()
        assert output.stat().st_size > 0
    
        revealed = wav.reveal(str(output))
>       assert revealed == secret
E       assert 'vj \x12&-\rE...(\x1f=}"))e\\' == 'WAV backend ...nopqrstuvwxyz'
E         
E         - WAV backend long message: 1234567890 abcdefghijklmnopqrstuvwxyz
E         + vj &-
E         + E|((=}"))e\

tests\Stegano\functional_test.py:254: AssertionError
_____________________ test_lsb_and_red_outputs_are_files ______________________

tmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-478/test_lsb_and_red_outputs_are_f0')

    def test_lsb_and_red_outputs_are_files(tmp_path: Path) -> None:
        """Ensure image-encoding backends produce files that can be written to disk."""
        _ensure_image_samples_exist()
    
        out_lsb = tmp_path / "lsb_file.png"
        out_red = tmp_path / "red_file.png"
    
>       lsb.hide(str(LENNA_PNG), "x").save(str(out_lsb))

tests\Stegano\functional_test.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

image = 'D:\\桌面\\RealAppCodeBench_generic_eval\\repositories\\Stegano\\tests\\sample-files\\Lenna.png'
message = 'x', generator = None, shift = 0, encoding = 'UTF-8'
auto_convert_rgb = False

    def hide(image, message, generator=None, shift=0, encoding="UTF-8", auto_convert_rgb=False):
        if auto_convert_rgb:
            image = convert_image(image)
>       pixels = image.load()
E       AttributeError: 'str' object has no attribute 'load'

generation\Stegano\stegano\lsb\lsb.py:9: AttributeError
=========================== short test summary info ===========================
FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_text - Attr...
FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_with_generator
FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_long_ascii_text
FAILED tests/Stegano/functional_test.py::test_lsb_reveal_from_image_object - ...
FAILED tests/Stegano/functional_test.py::test_red_hide_and_reveal_text - Attr...
FAILED tests/Stegano/functional_test.py::test_red_hide_and_reveal_extended_latin_text
FAILED tests/Stegano/functional_test.py::test_wav_hide_and_reveal_text - asse...
FAILED tests/Stegano/functional_test.py::test_wav_hide_and_reveal_short_text
FAILED tests/Stegano/functional_test.py::test_wav_hide_and_reveal_longer_text
FAILED tests/Stegano/functional_test.py::test_lsb_and_red_outputs_are_files
10 failed, 2 passed in 1.91s

==========================================================================================
PROJECT: Tablib
LOG: D:\桌面\Exp1\deepseek-r1\results\Tablib\pytest_logs\functional.log
==========================================================================================
.F..F...F..                                                              [100%]
================================== FAILURES ===================================
__________________ test_dataset_export_import_tsv_roundtrip ___________________

    def test_dataset_export_import_tsv_roundtrip() -> None:
        """TSV export/import should preserve shape and values (type-coercion tolerant)."""
        if not _format_supported("tsv"):
            pytest.skip("tsv format not available in this tablib build")
    
        data = _build_sample_dataset()
>       tsv_text = data.export("tsv")

tests\Tablib\functional_test.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Dataset height=3, width=3>, fmt = 'tsv'

    def export(self, fmt: str) -> str:
        """Export dataset to specified format."""
        if fmt == 'csv':
            from .formats._csv import export_csv
            return export_csv(self)
        elif fmt == 'json':
            from .formats._json import export_json
            return export_json(self)
        else:
>           raise ValueError(f"Unsupported format: {fmt}")
E           ValueError: Unsupported format: tsv

generation\Tablib\tablib\core.py:167: ValueError
__________________ test_dataset_insert_and_pop_row_semantics __________________

    def test_dataset_insert_and_pop_row_semantics() -> None:
        """Dataset should support inserting and popping rows (list-like usage)."""
        data = tablib.Dataset(headers=("id", "name"))
        data.append((1, "a"))
        data.append((3, "c"))
    
        # Insert a missing middle row.
>       data.insert(1, (2, "b"))
E       AttributeError: 'Dataset' object has no attribute 'insert'

tests\Tablib\functional_test.py:233: AttributeError
______________ test_dataset_export_html_contains_table_structure ______________

    def test_dataset_export_html_contains_table_structure() -> None:
        """HTML export (if available) should include a table-like structure and headers."""
        if not _format_supported("html"):
            pytest.skip("html format not available in this tablib build")
    
        data = _build_sample_dataset()
>       html = data.export("html")

tests\Tablib\functional_test.py:292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Dataset height=3, width=3>, fmt = 'html'

    def export(self, fmt: str) -> str:
        """Export dataset to specified format."""
        if fmt == 'csv':
            from .formats._csv import export_csv
            return export_csv(self)
        elif fmt == 'json':
            from .formats._json import export_json
            return export_json(self)
        else:
>           raise ValueError(f"Unsupported format: {fmt}")
E           ValueError: Unsupported format: html

generation\Tablib\tablib\core.py:167: ValueError
=========================== short test summary info ===========================
FAILED tests/Tablib/functional_test.py::test_dataset_export_import_tsv_roundtrip
FAILED tests/Tablib/functional_test.py::test_dataset_insert_and_pop_row_semantics
FAILED tests/Tablib/functional_test.py::test_dataset_export_html_contains_table_structure
3 failed, 8 passed in 0.54s

==========================================================================================
PROJECT: Tabulate
LOG: D:\桌面\Exp1\deepseek-r1\results\Tabulate\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFF.                                                             [100%]
================================== FAILURES ===================================
___________________ test_basic_list_of_lists_default_simple ___________________

    def test_basic_list_of_lists_default_simple() -> None:
        table = [
            ["Sun", 696000, 1.9891e9],
            ["Earth", 6371, 5973.6],
            ["Moon", 1737, 73.5],
            ["Mars", 3390, 641.85],
        ]
    
>       output = tabulate(table)

tests\Tabulate\functional_test.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

table = [['Sun', 696000, 1989100000.0], ['Earth', 6371, 5973.6], ['Moon', 1737, 73.5], ['Mars', 3390, 641.85]]
headers = None, tablefmt = 'plain', numalign = 'right', stralign = 'left'

    def tabulate(table, headers=None, tablefmt="plain", numalign="right", stralign="left"):
        if tablefmt in PRESET_FORMATS:
            fmt = PRESET_FORMATS[tablefmt]
        else:
            raise ValueError(f"Table format {tablefmt} not supported")
    
        headers, rows = _normalize_table(table, headers)
        if not rows:
            return ""
    
        widths = _calculate_widths(headers, rows)
        align_funcs = []
        for i in range(len(widths)):
            if headers and i < len(headers) and any(isinstance(row[i], (int, float)) for row in rows if i < len(row)):
                align = numalign
            else:
                align = stralign
            if align == "left":
                align_funcs.append(str.ljust)
            elif align == "right":
                align_funcs.append(str.rjust)
            elif align == "center":
                align_funcs.append(str.center)
            else:
                align_funcs.append(str.ljust)
    
        output_lines = []
        if fmt.lineabove and (headers or "lineabove" not in fmt.with_header_hide):
            output_lines.append(fmt.lineabove(widths))
    
        if headers:
            aligned_headers = _align_row(headers, widths, align_funcs)
            header_line = fmt.headerrow(aligned_headers, widths)
            output_lines.append(header_line)
            if fmt.linebelowheader and (headers or "linebelowheader" not in fmt.with_header_hide):
                output_lines.append(fmt.linebelowheader(widths))
    
        for i, row in enumerate(rows):
            if i > 0 and fmt.linebetweenrows:
                output_lines.append(fmt.linebetweenrows(widths))
            aligned_row = _align_row(row, widths, align_funcs)
            output_lines.append(fmt.datarow(aligned_row, widths))
    
        if fmt.linebelow and (headers or "linebelow" not in fmt.with_header_hide):
            output_lines.append(fmt.linebelow(widths))
    
>       return '\n'.join(output_lines)
E       TypeError: sequence item 0: expected str instance, list found

generation\Tabulate\tabulate\core.py:103: TypeError
____________________ test_headers_as_list_and_plain_format ____________________

    def test_headers_as_list_and_plain_format() -> None:
        table = [
            ["spam", 42],
            ["eggs", 451],
            ["bacon", 0],
        ]
        headers = ["item", "qty"]
    
>       output = tabulate(table, headers=headers, tablefmt="plain")

tests\Tabulate\functional_test.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

table = [['spam', 42], ['eggs', 451], ['bacon', 0]], headers = ['item', 'qty']
tablefmt = 'plain', numalign = 'right', stralign = 'left'

    def tabulate(table, headers=None, tablefmt="plain", numalign="right", stralign="left"):
        if tablefmt in PRESET_FORMATS:
            fmt = PRESET_FORMATS[tablefmt]
        else:
            raise ValueError(f"Table format {tablefmt} not supported")
    
        headers, rows = _normalize_table(table, headers)
        if not rows:
            return ""
    
        widths = _calculate_widths(headers, rows)
        align_funcs = []
        for i in range(len(widths)):
            if headers and i < len(headers) and any(isinstance(row[i], (int, float)) for row in rows if i < len(row)):
                align = numalign
            else:
                align = stralign
            if align == "left":
                align_funcs.append(str.ljust)
            elif align == "right":
                align_funcs.append(str.rjust)
            elif align == "center":
                align_funcs.append(str.center)
            else:
                align_funcs.append(str.ljust)
    
        output_lines = []
        if fmt.lineabove and (headers or "lineabove" not in fmt.with_header_hide):
            output_lines.append(fmt.lineabove(widths))
    
        if headers:
            aligned_headers = _align_row(headers, widths, align_funcs)
            header_line = fmt.headerrow(aligned_headers, widths)
            output_lines.append(header_line)
            if fmt.linebelowheader and (headers or "linebelowheader" not in fmt.with_header_hide):
                output_lines.append(fmt.linebelowheader(widths))
    
        for i, row in enumerate(rows):
            if i > 0 and fmt.linebetweenrows:
                output_lines.append(fmt.linebetweenrows(widths))
            aligned_row = _align_row(row, widths, align_funcs)
            output_lines.append(fmt.datarow(aligned_row, widths))
    
        if fmt.linebelow and (headers or "linebelow" not in fmt.with_header_hide):
            output_lines.append(fmt.linebelow(widths))
    
>       return '\n'.join(output_lines)
E       TypeError: sequence item 0: expected str instance, list found

generation\Tabulate\tabulate\core.py:103: TypeError
___________________ test_headers_firstrow_and_simple_format ___________________

    def test_headers_firstrow_and_simple_format() -> None:
        table = [
            ["Name", "Age"],
            ["Alice", 24],
            ["Bob", 19],
        ]
    
>       output = tabulate(table, headers="firstrow", tablefmt="simple")

tests\Tabulate\functional_test.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

table = [['Name', 'Age'], ['Alice', 24], ['Bob', 19]], headers = 'firstrow'
tablefmt = 'simple', numalign = 'right', stralign = 'left'

    def tabulate(table, headers=None, tablefmt="plain", numalign="right", stralign="left"):
        if tablefmt in PRESET_FORMATS:
            fmt = PRESET_FORMATS[tablefmt]
        else:
>           raise ValueError(f"Table format {tablefmt} not supported")
E           ValueError: Table format simple not supported

generation\Tabulate\tabulate\core.py:61: ValueError
___________________ test_headers_keys_on_dict_of_iterables ____________________

    def test_headers_keys_on_dict_of_iterables() -> None:
        table = {
            "Name": ["Alice", "Bob"],
            "Age": [24, 19],
        }
    
>       output = tabulate(table, headers="keys")

tests\Tabulate\functional_test.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
generation\Tabulate\tabulate\core.py:63: in tabulate
    headers, rows = _normalize_table(table, headers)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

table = {'Age': [24, 19], 'Name': ['Alice', 'Bob']}, headers = 'keys'

    def _normalize_table(table, headers):
        if not table:
            return [], []
    
>       if isinstance(table[0], dict):
E       KeyError: 0

generation\Tabulate\tabulate\core.py:7: KeyError
___________________________ test_showindex_variants ___________________________

    def test_showindex_variants() -> None:
        table = [
            ["F", 24],
            ["M", 19],
        ]
    
>       out_true = tabulate(table, showindex=True)
E       TypeError: tabulate() got an unexpected keyword argument 'showindex'

tests\Tabulate\functional_test.py:151: TypeError
________________________ test_github_and_grid_formats _________________________

    def test_github_and_grid_formats() -> None:
        table = [
            ["item", "qty"],
            ["spam", 42],
            ["eggs", 451],
            ["bacon", 0],
        ]
    
>       out_github = tabulate(table[1:], headers=table[0], tablefmt="github")

tests\Tabulate\functional_test.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

table = [['spam', 42], ['eggs', 451], ['bacon', 0]], headers = ['item', 'qty']
tablefmt = 'github', numalign = 'right', stralign = 'left'

    def tabulate(table, headers=None, tablefmt="plain", numalign="right", stralign="left"):
        if tablefmt in PRESET_FORMATS:
            fmt = PRESET_FORMATS[tablefmt]
        else:
>           raise ValueError(f"Table format {tablefmt} not supported")
E           ValueError: Table format github not supported

generation\Tabulate\tabulate\core.py:61: ValueError
____________________ test_list_of_dicts_headers_keys_plain ____________________

    def test_list_of_dicts_headers_keys_plain() -> None:
        rows = [
            {"name": "Alice", "score": 10},
            {"name": "Bob", "score": 12},
        ]
>       output = tabulate(rows, headers="keys", tablefmt="plain")

tests\Tabulate\functional_test.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

table = [{'name': 'Alice', 'score': 10}, {'name': 'Bob', 'score': 12}]
headers = ['name', 'score'], tablefmt = 'plain', numalign = 'right'
stralign = 'left'

    def tabulate(table, headers=None, tablefmt="plain", numalign="right", stralign="left"):
        if tablefmt in PRESET_FORMATS:
            fmt = PRESET_FORMATS[tablefmt]
        else:
            raise ValueError(f"Table format {tablefmt} not supported")
    
        headers, rows = _normalize_table(table, headers)
        if not rows:
            return ""
    
        widths = _calculate_widths(headers, rows)
        align_funcs = []
        for i in range(len(widths)):
            if headers and i < len(headers) and any(isinstance(row[i], (int, float)) for row in rows if i < len(row)):
                align = numalign
            else:
                align = stralign
            if align == "left":
                align_funcs.append(str.ljust)
            elif align == "right":
                align_funcs.append(str.rjust)
            elif align == "center":
                align_funcs.append(str.center)
            else:
                align_funcs.append(str.ljust)
    
        output_lines = []
        if fmt.lineabove and (headers or "lineabove" not in fmt.with_header_hide):
            output_lines.append(fmt.lineabove(widths))
    
        if headers:
            aligned_headers = _align_row(headers, widths, align_funcs)
            header_line = fmt.headerrow(aligned_headers, widths)
            output_lines.append(header_line)
            if fmt.linebelowheader and (headers or "linebelowheader" not in fmt.with_header_hide):
                output_lines.append(fmt.linebelowheader(widths))
    
        for i, row in enumerate(rows):
            if i > 0 and fmt.linebetweenrows:
                output_lines.append(fmt.linebetweenrows(widths))
            aligned_row = _align_row(row, widths, align_funcs)
            output_lines.append(fmt.datarow(aligned_row, widths))
    
        if fmt.linebelow and (headers or "linebelow" not in fmt.with_header_hide):
            output_lines.append(fmt.linebelow(widths))
    
>       return '\n'.join(output_lines)
E       TypeError: sequence item 0: expected str instance, list found

generation\Tabulate\tabulate\core.py:103: TypeError
_____________________ test_missingval_renders_placeholder _____________________

    def test_missingval_renders_placeholder() -> None:
        rows = [
            ["Alice", None],
            ["Bob", "ok"],
        ]
>       output = tabulate(rows, headers=["name", "status"], tablefmt="plain", missingval="N/A")
E       TypeError: tabulate() got an unexpected keyword argument 'missingval'

tests\Tabulate\functional_test.py:207: TypeError
__________________ test_floatfmt_controls_numeric_rendering ___________________

    def test_floatfmt_controls_numeric_rendering() -> None:
        rows = [
            ["pi", 3.14159],
            ["e", 2.71828],
        ]
>       output = tabulate(rows, headers=["name", "value"], tablefmt="plain", floatfmt=".2f")
E       TypeError: tabulate() got an unexpected keyword argument 'floatfmt'

tests\Tabulate\functional_test.py:222: TypeError
_______________ test_disable_numparse_preserves_numeric_strings _______________

    def test_disable_numparse_preserves_numeric_strings() -> None:
        rows = [
            ["code", "value"],
            ["A", "001"],
            ["B", "010"],
        ]
>       output = tabulate(rows[1:], headers=rows[0], tablefmt="plain", disable_numparse=True)
E       TypeError: tabulate() got an unexpected keyword argument 'disable_numparse'

tests\Tabulate\functional_test.py:236: TypeError
______________________ test_maxcolwidths_wraps_long_text ______________________

    def test_maxcolwidths_wraps_long_text() -> None:
        long_text = "alpha beta gamma delta epsilon zeta"
        rows = [
            ["id", "note"],
            [1, long_text],
            [2, "short"],
        ]
>       output = tabulate(
            rows[1:],
            headers=rows[0],
            tablefmt="simple",
            maxcolwidths=[None, 10],
        )
E       TypeError: tabulate() got an unexpected keyword argument 'maxcolwidths'

tests\Tabulate\functional_test.py:251: TypeError
=========================== short test summary info ===========================
FAILED tests/Tabulate/functional_test.py::test_basic_list_of_lists_default_simple
FAILED tests/Tabulate/functional_test.py::test_headers_as_list_and_plain_format
FAILED tests/Tabulate/functional_test.py::test_headers_firstrow_and_simple_format
FAILED tests/Tabulate/functional_test.py::test_headers_keys_on_dict_of_iterables
FAILED tests/Tabulate/functional_test.py::test_showindex_variants - TypeError...
FAILED tests/Tabulate/functional_test.py::test_github_and_grid_formats - Valu...
FAILED tests/Tabulate/functional_test.py::test_list_of_dicts_headers_keys_plain
FAILED tests/Tabulate/functional_test.py::test_missingval_renders_placeholder
FAILED tests/Tabulate/functional_test.py::test_floatfmt_controls_numeric_rendering
FAILED tests/Tabulate/functional_test.py::test_disable_numparse_preserves_numeric_strings
FAILED tests/Tabulate/functional_test.py::test_maxcolwidths_wraps_long_text
11 failed, 1 passed in 0.69s

==========================================================================================
PROJECT: TinyDB
LOG: D:\桌面\Exp1\deepseek-r1\results\TinyDB\pytest_logs\functional.log
==========================================================================================

=================================== ERRORS ====================================
______________ ERROR collecting tests/TinyDB/functional_test.py _______________
ImportError while importing test module 'D:\桌面\RealAppCodeBench_generic_eval\tests\TinyDB\functional_test.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
C:\Users\86152\AppData\Local\Programs\Python\Python39\lib\importlib\__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
tests\TinyDB\functional_test.py:49: in <module>
    from tinydb import TinyDB, Query, where  # type: ignore  # noqa: E402
E   ImportError: cannot import name 'Query' from 'tinydb' (D:\桌面\RealAppCodeBench_generic_eval\generation\TinyDB\tinydb\__init__.py)
=========================== short test summary info ===========================
ERROR tests/TinyDB/functional_test.py
!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!
1 error in 0.60s

==========================================================================================
PROJECT: Xmltodict
LOG: D:\桌面\Exp1\deepseek-r1\results\Xmltodict\pytest_logs\functional.log
==========================================================================================
FFFFFFFFFFFF                                                             [100%]
================================== FAILURES ===================================
__________________________ test_parse_simple_element __________________________

    def test_parse_simple_element() -> None:
        """Parsing a simple XML element should produce the expected dict."""
        xml = "<root><message>Hello</message></root>"
        data = _parse(xml)
    
>       assert "root" in data
E       AssertionError: assert 'root' in {'message': 'Hello'}

tests\Xmltodict\functional_test.py:79: AssertionError
____________________ test_parse_repeated_elements_as_list _____________________

    def test_parse_repeated_elements_as_list() -> None:
        """Repeated child elements should be represented as a list."""
        xml = "<root><item>1</item><item>2</item><item>3</item></root>"
        data = _parse(xml)
    
>       items = data["root"]["item"]
E       KeyError: 'root'

tests\Xmltodict\functional_test.py:88: KeyError
_______________________ test_parse_attributes_and_text ________________________

    def test_parse_attributes_and_text() -> None:
        """Attributes and text content should be exposed using @attr and #text keys."""
        xml = '<user id="123">Alice</user>'
        data = _parse(xml)
    
>       user = data["user"]
E       KeyError: 'user'

tests\Xmltodict\functional_test.py:98: KeyError
___________________ test_unparse_roundtrip_basic_structure ____________________

    def test_unparse_roundtrip_basic_structure() -> None:
        """unparse() followed by parse() should preserve the logical structure."""
        original = {
            "root": {
                "item": [
                    {"@id": "1", "#text": "A"},
                    {"@id": "2", "#text": "B"},
                ]
            }
        }
    
        xml = _unparse(original)
        round_tripped = _parse(xml)
    
>       assert round_tripped == original
E       AssertionError: assert {'item': [{'#... '@id': '2'}]} == {'root': {'it...'@id': '2'}]}}
E         
E         Left contains 1 more item:
E         {'item': [{'#text': 'A', '@id': '1'}, {'#text': 'B', '@id': '2'}]}
E         Right contains 1 more item:
E         {'root': {'item': [{'#text': 'A', '@id': '1'}, {'#text': 'B', '@id': '2'}]}}
E         Use -v to get more diff

tests\Xmltodict\functional_test.py:117: AssertionError
_____________________ test_namespace_prefix_is_preserved ______________________

    def test_namespace_prefix_is_preserved() -> None:
        """Namespace prefixes in element names should be preserved in dict keys."""
        xml = """
        <root xmlns:x="http://example.com/x">
            <x:item>value</x:item>
        </root>
        """
        data = _parse(xml)
    
>       root = data["root"]
E       KeyError: 'root'

tests\Xmltodict\functional_test.py:129: KeyError
_________________________ test_parse_nested_structure _________________________

    def test_parse_nested_structure() -> None:
        """Nested XML elements should map to nested dict structures."""
        xml = """
        <root>
            <user>
                <name>Ada</name>
                <address>
                    <city>London</city>
                    <country>UK</country>
                </address>
            </user>
        </root>
        """
        data = _parse(xml)
>       assert data["root"]["user"]["name"] == "Ada"
E       KeyError: 'root'

tests\Xmltodict\functional_test.py:151: KeyError
__________________ test_force_list_option_for_single_element __________________

    def test_force_list_option_for_single_element() -> None:
        """force_list should allow representing a single child as a list when supported."""
        xml = "<root><item>1</item></root>"
    
        # Prefer a targeted force_list that is common in xmltodict.
        data = _parse(xml, force_list=("item",))
    
>       item = data["root"]["item"]
E       KeyError: 'root'

tests\Xmltodict\functional_test.py:163: KeyError
_____________ test_custom_attr_prefix_and_cdata_key_if_supported ______________

    def test_custom_attr_prefix_and_cdata_key_if_supported() -> None:
        """attr_prefix / cdata_key customization should reflect in output when supported."""
        xml = '<user id="7">Bob</user>'
    
        data = _parse(xml, attr_prefix="$", cdata_key="text")
>       user = data["user"]
E       KeyError: 'user'

tests\Xmltodict\functional_test.py:177: KeyError
____________ test_xml_attribs_false_drops_attributes_if_supported _____________

    def test_xml_attribs_false_drops_attributes_if_supported() -> None:
        """xml_attribs=False should omit attribute keys when supported."""
        xml = '<user id="9"><name>Alice</name></user>'
    
        data = _parse(xml, xml_attribs=False)
>       user = data["user"]
E       KeyError: 'user'

tests\Xmltodict\functional_test.py:192: KeyError
______________________ test_dict_constructor_ordereddict ______________________

    def test_dict_constructor_ordereddict() -> None:
        """dict_constructor should allow choosing mapping type (e.g., OrderedDict) when supported."""
        xml = "<root><a>1</a><b>2</b></root>"
        data = _parse(xml, dict_constructor=OrderedDict)
    
        if "dict_constructor" in _PARSE_PARAMS:
            assert isinstance(data, OrderedDict)
            assert isinstance(data["root"], OrderedDict)
        else:
            assert isinstance(data, dict)
    
>       assert data["root"]["a"] == "1"
E       KeyError: 'root'

tests\Xmltodict\functional_test.py:215: KeyError
_____________________ test_unparse_pretty_and_parse_back ______________________

    def test_unparse_pretty_and_parse_back() -> None:
        """Pretty/full_document knobs should not break roundtrip of basic structure."""
        original: Dict[str, Any] = {"root": {"x": "1", "y": "2"}}
    
        xml = _unparse(original, pretty=True, full_document=True)
        assert "<root>" in xml or "<root" in xml
    
        round_tripped = _parse(xml)
>       assert round_tripped == original
E       AssertionError: assert {'x': '1', 'y': '2'} == {'root': {'x': '1', 'y': '2'}}
E         
E         Left contains 2 more items:
E         {'x': '1', 'y': '2'}
E         Right contains 1 more item:
E         {'root': {'x': '1', 'y': '2'}}
E         Use -v to get more diff

tests\Xmltodict\functional_test.py:227: AssertionError
______________ test_postprocessor_transforms_value_if_supported _______________

    def test_postprocessor_transforms_value_if_supported() -> None:
        """postprocessor can transform values in a happy-path parse when supported."""
        xml = "<root><message>Hello</message></root>"
    
        def _pp(path: Any, key: str, value: Any) -> Any:
            if key == "message" and isinstance(value, str):
                return key, value.upper()
            return key, value
    
>       data = _parse(xml, postprocessor=_pp)

tests\Xmltodict\functional_test.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\Xmltodict\functional_test.py:62: in _parse
    return xmltodict.parse(xml, **filtered)  # type: ignore[arg-type]
generation\Xmltodict\xmltodict.py:70: in parse
    return _element_to_dict(
generation\Xmltodict\xmltodict.py:116: in _element_to_dict
    child_dict = _element_to_dict(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

element = <Element 'message' at 0x0000029B4CAA7860>, process_namespaces = False
namespace_separator = ':', force_list = []
postprocessor = <function test_postprocessor_transforms_value_if_supported.<locals>._pp at 0x0000029B4CB23F70>

    def _element_to_dict(
        element: ET.Element,
        process_namespaces: bool,
        namespace_separator: str,
        force_list: List[str],
        postprocessor: Any
    ) -> Union[XMLDict, str]:
        """Convert XML element to dictionary."""
    
        # Handle tag name
        tag = element.tag
        if process_namespaces and '}' in tag:
            # Extract namespace and local name
            namespace_match = re.match(r'\{.*?\}', tag)
            if namespace_match:
                namespace = namespace_match.group(0)[1:-1]
                local_name = tag[namespace_match.end():]
                tag = f"{namespace}{namespace_separator}{local_name}"
    
        # Start with attributes
        result: XMLDict = {}
        if element.attrib:
            for key, value in element.attrib.items():
                attr_key = f"@{key}"
                if process_namespaces and '}' in key:
                    namespace_match = re.match(r'\{.*?\}', key)
                    if namespace_match:
                        namespace = namespace_match.group(0)[1:-1]
                        local_name = key[namespace_match.end():]
                        attr_key = f"@{namespace}{namespace_separator}{local_name}"
                result[attr_key] = value
    
        # Handle children
        children_by_tag: Dict[str, List[Any]] = {}
        text_parts: List[str] = []
    
        for child in element:
            if isinstance(child, ET.Element):
                child_dict = _element_to_dict(
                    child,
                    process_namespaces,
                    namespace_separator,
                    force_list,
                    postprocessor
                )
    
                child_tag = child.tag
                if process_namespaces and '}' in child_tag:
                    namespace_match = re.match(r'\{.*?\}', child_tag)
                    if namespace_match:
                        namespace = namespace_match.group(0)[1:-1]
                        local_name = child_tag[namespace_match.end():]
                        child_tag = f"{namespace}{namespace_separator}{local_name}"
    
                if child_tag not in children_by_tag:
                    children_by_tag[child_tag] = []
                children_by_tag[child_tag].append(child_dict)
            elif child.tail:
                text_parts.append(child.tail)
    
        # Add children to result
        for child_tag, children in children_by_tag.items():
            if len(children) == 1 and child_tag not in force_list:
                result[child_tag] = children[0]
            else:
                result[child_tag] = children
    
        # Handle text
        if element.text and element.text.strip():
            text = element.text.strip()
            if text_parts:
                text = text + ''.join(text_parts)
    
            if '#text' in result:
                if isinstance(result['#text'], list):
                    result['#text'].append(text)
                else:
                    result['#text'] = [result['#text'], text]
            else:
                result['#text'] = text
    
        # Apply postprocessor
        if postprocessor:
>           result = postprocessor(tag, result)
E           TypeError: _pp() missing 1 required positional argument: 'value'

generation\Xmltodict\xmltodict.py:161: TypeError
=========================== short test summary info ===========================
FAILED tests/Xmltodict/functional_test.py::test_parse_simple_element - Assert...
FAILED tests/Xmltodict/functional_test.py::test_parse_repeated_elements_as_list
FAILED tests/Xmltodict/functional_test.py::test_parse_attributes_and_text - K...
FAILED tests/Xmltodict/functional_test.py::test_unparse_roundtrip_basic_structure
FAILED tests/Xmltodict/functional_test.py::test_namespace_prefix_is_preserved
FAILED tests/Xmltodict/functional_test.py::test_parse_nested_structure - KeyE...
FAILED tests/Xmltodict/functional_test.py::test_force_list_option_for_single_element
FAILED tests/Xmltodict/functional_test.py::test_custom_attr_prefix_and_cdata_key_if_supported
FAILED tests/Xmltodict/functional_test.py::test_xml_attribs_false_drops_attributes_if_supported
FAILED tests/Xmltodict/functional_test.py::test_dict_constructor_ordereddict
FAILED tests/Xmltodict/functional_test.py::test_unparse_pretty_and_parse_back
FAILED tests/Xmltodict/functional_test.py::test_postprocessor_transforms_value_if_supported
12 failed in 0.68s

