.F..F.F.F.F                                                              [100%]
================================== FAILURES ===================================
__________________ test_dataset_export_import_tsv_roundtrip ___________________

    def test_dataset_export_import_tsv_roundtrip() -> None:
        """TSV export/import should preserve shape and values (type-coercion tolerant)."""
        if not _format_supported("tsv"):
            pytest.skip("tsv format not available in this tablib build")
    
        data = _build_sample_dataset()
>       tsv_text = data.export("tsv")

tests\Tablib\functional_test.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tablib.core.Dataset object at 0x00000277FA1EDF10>, fmt = 'tsv'

    def export(self, fmt):
        """Export dataset to a format.
    
        Args:
            fmt: Format string ('csv', 'json', etc.)
    
        Returns:
            String representation in the requested format
        """
        fmt = fmt.lower()
    
        if fmt == 'csv':
            from tablib.formats import _csv
            return _csv.export_set(self)
        elif fmt == 'json':
            from tablib.formats import _json
            return _json.export_set(self)
        else:
>           raise ValueError(f"Unsupported format: {fmt}")
E           ValueError: Unsupported format: tsv

generation\Tablib\tablib\core.py:157: ValueError
__________________ test_dataset_insert_and_pop_row_semantics __________________

    def test_dataset_insert_and_pop_row_semantics() -> None:
        """Dataset should support inserting and popping rows (list-like usage)."""
        data = tablib.Dataset(headers=("id", "name"))
        data.append((1, "a"))
        data.append((3, "c"))
    
        # Insert a missing middle row.
>       data.insert(1, (2, "b"))
E       AttributeError: 'Dataset' object has no attribute 'insert'

tests\Tablib\functional_test.py:233: AttributeError
_________________ test_dataset_title_and_headers_persistence __________________

    def test_dataset_title_and_headers_persistence() -> None:
        """Dataset title and headers should be assignable and remain consistent."""
        data = tablib.Dataset(headers=("k", "v"))
        data.title = "Config"
        data.append(("a", 1))
        data.append(("b", 2))
    
        assert getattr(data, "title") == "Config"
        assert tuple(data.headers) == ("k", "v")
        assert data.height == 2
>       assert data[1][0] == "b"

tests\Tablib\functional_test.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tablib.core.Dataset object at 0x00000277FA268CD0>, key = 1

    def __getitem__(self, key):
        """Get rows by slice or column by name.
    
        Args:
            key: Either a slice for rows or a string for column access
    
        Returns:
            For slice: list of row tuples
            For string: list of column values
        """
        if isinstance(key, slice):
            return self._data[key]
        elif isinstance(key, str):
            # Column access by header name
            if self._headers is None:
                raise KeyError(f"No headers defined")
            if key not in self._headers:
                raise KeyError(f"Column '{key}' not found")
    
            col_index = self._headers.index(key)
            return [row[col_index] if col_index < len(row) else None for row in self._data]
        else:
>           raise TypeError(f"Invalid key type: {type(key)}")
E           TypeError: Invalid key type: <class 'int'>

generation\Tablib\tablib\core.py:119: TypeError
______________ test_dataset_export_html_contains_table_structure ______________

    def test_dataset_export_html_contains_table_structure() -> None:
        """HTML export (if available) should include a table-like structure and headers."""
        if not _format_supported("html"):
            pytest.skip("html format not available in this tablib build")
    
        data = _build_sample_dataset()
>       html = data.export("html")

tests\Tablib\functional_test.py:292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tablib.core.Dataset object at 0x00000277FA2973D0>, fmt = 'html'

    def export(self, fmt):
        """Export dataset to a format.
    
        Args:
            fmt: Format string ('csv', 'json', etc.)
    
        Returns:
            String representation in the requested format
        """
        fmt = fmt.lower()
    
        if fmt == 'csv':
            from tablib.formats import _csv
            return _csv.export_set(self)
        elif fmt == 'json':
            from tablib.formats import _json
            return _json.export_set(self)
        else:
>           raise ValueError(f"Unsupported format: {fmt}")
E           ValueError: Unsupported format: html

generation\Tablib\tablib\core.py:157: ValueError
_________________ test_databook_add_sheet_and_iteration_order _________________

    def test_databook_add_sheet_and_iteration_order() -> None:
        """Databook should allow adding sheets and preserve the order in iteration."""
        s1 = tablib.Dataset((1, "x"), headers=("id", "val"))
        s1.title = "S1"
        s2 = tablib.Dataset((2, "y"), headers=("id", "val"))
        s2.title = "S2"
    
        book = tablib.Databook([s1])
    
        if hasattr(book, "add_sheet"):
            book.add_sheet(s2)  # type: ignore[attr-defined]
        else:
            # Fallback: reconstruct via the public constructor (still normal usage).
            book = tablib.Databook([s1, s2])
    
        assert book.size == 2
    
        sheets = _iter_databook_sheets(book)
        assert len(sheets) == 2
        assert sheets[0].title == "S1"
        assert sheets[1].title == "S2"
>       assert sheets[0][0] == (1, "x")

tests\Tablib\functional_test.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tablib.core.Dataset object at 0x00000277FA211D90>, key = 0

    def __getitem__(self, key):
        """Get rows by slice or column by name.
    
        Args:
            key: Either a slice for rows or a string for column access
    
        Returns:
            For slice: list of row tuples
            For string: list of column values
        """
        if isinstance(key, slice):
            return self._data[key]
        elif isinstance(key, str):
            # Column access by header name
            if self._headers is None:
                raise KeyError(f"No headers defined")
            if key not in self._headers:
                raise KeyError(f"Column '{key}' not found")
    
            col_index = self._headers.index(key)
            return [row[col_index] if col_index < len(row) else None for row in self._data]
        else:
>           raise TypeError(f"Invalid key type: {type(key)}")
E           TypeError: Invalid key type: <class 'int'>

generation\Tablib\tablib\core.py:119: TypeError
=========================== short test summary info ===========================
FAILED tests/Tablib/functional_test.py::test_dataset_export_import_tsv_roundtrip
FAILED tests/Tablib/functional_test.py::test_dataset_insert_and_pop_row_semantics
FAILED tests/Tablib/functional_test.py::test_dataset_title_and_headers_persistence
FAILED tests/Tablib/functional_test.py::test_dataset_export_html_contains_table_structure
FAILED tests/Tablib/functional_test.py::test_databook_add_sheet_and_iteration_order
5 failed, 6 passed in 0.70s
