project_name: Stegano
task_file: D:\桌面\RealAppCodeBench_generic_eval\tasks\Stegano\stegano.yaml
generated_repo: D:\桌面\RealAppCodeBench_generic_eval\generation\Stegano
timestamp: '2026-01-02 08:02:42'
functional_score: 0.1667
non_functional_score: 0.594
non_functional_subscores:
  maintainability: 0.5389
  security: 1.0
  robustness: 1.0
  performance: 0.0
  resource: 0.0
non_functional_weights:
  maintainability: 0.36
  security: 0.24
  robustness: 0.16
  performance: 0.12
  resource: 0.12
results:
  functional:
    returncode: 1
    stdout: "FFFFFF..FFFF                                                        \
      \     [100%]\n================================== FAILURES ===================================\n\
      ________________________ test_lsb_hide_and_reveal_text ________________________\n\
      \ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-489/test_lsb_hide_and_reveal_text0')\n\
      \n    def test_lsb_hide_and_reveal_text(tmp_path: Path) -> None:\n        \"\
      \"\"lsb.hide(..., str) then lsb.reveal(...) returns the same string.\"\"\"\n\
      \        _ensure_image_samples_exist()\n    \n        secret = \"hello world\"\
      \n        output = tmp_path / \"lsb_lenna.png\"\n    \n>       encoded_img =\
      \ lsb.hide(str(LENNA_PNG), secret)\n\ntests\\Stegano\\functional_test.py:90:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nimage = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\\repositories\\\
      \\Stegano\\\\tests\\\\sample-files\\\\Lenna.png'\nmessage = 'hello world', generator\
      \ = None, shift = 0, encoding = 'UTF-8'\nauto_convert_rgb = False\n\n    def\
      \ hide(\n        image: Image.Image,\n        message: str,\n        generator:\
      \ Optional[Iterator[int]] = None,\n        shift: int = 0,\n        encoding:\
      \ str = \"UTF-8\",\n        auto_convert_rgb: bool = False\n    ) -> Image.Image:\n\
      \        \"\"\"\n        Hide a text message in the image using LSB steganography.\n\
      \        :param image: PIL Image to use as cover.\n        :param message: The\
      \ text message to hide.\n        :param generator: Iterator of pixel indices\
      \ to use for hiding bits (default: consecutive).\n        :param shift: Number\
      \ of LSB positions to skip from the start (default 0).\n        :param encoding:\
      \ Text encoding for the message (default: UTF-8).\n        :param auto_convert_rgb:\
      \ If True and image is not 'RGB', convert it.\n        :return: A new PIL Image\
      \ with the hidden message.\n        \"\"\"\n        if auto_convert_rgb and\
      \ image.mode != \"RGB\":\n            image = image.convert(\"RGB\")\n>    \
      \   elif image.mode not in (\"RGB\", \"RGBA\"):\nE       AttributeError: 'str'\
      \ object has no attribute 'mode'\n\ngeneration\\Stegano\\stegano\\lsb\\lsb.py:33:\
      \ AttributeError\n___________________ test_lsb_hide_and_reveal_with_generator\
      \ ___________________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-489/test_lsb_hide_and_reveal_with_0')\n\
      \n    def test_lsb_hide_and_reveal_with_generator(tmp_path: Path) -> None:\n\
      \        \"\"\"lsb hide/reveal with a deterministic generator.\"\"\"\n     \
      \   _ensure_image_samples_exist()\n    \n        secret = \"generator secret\"\
      \n        output = tmp_path / \"lsb_generator.png\"\n    \n        gen = generators.eratosthenes()\n\
      >       encoded_img = lsb.hide(str(LENNA_PNG), secret, generator=gen)\n\ntests\\\
      Stegano\\functional_test.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nimage = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\
      \\repositories\\\\Stegano\\\\tests\\\\sample-files\\\\Lenna.png'\nmessage =\
      \ 'generator secret'\ngenerator = <generator object eratosthenes at 0x00000246AC653EB0>,\
      \ shift = 0\nencoding = 'UTF-8', auto_convert_rgb = False\n\n    def hide(\n\
      \        image: Image.Image,\n        message: str,\n        generator: Optional[Iterator[int]]\
      \ = None,\n        shift: int = 0,\n        encoding: str = \"UTF-8\",\n   \
      \     auto_convert_rgb: bool = False\n    ) -> Image.Image:\n        \"\"\"\n\
      \        Hide a text message in the image using LSB steganography.\n       \
      \ :param image: PIL Image to use as cover.\n        :param message: The text\
      \ message to hide.\n        :param generator: Iterator of pixel indices to use\
      \ for hiding bits (default: consecutive).\n        :param shift: Number of LSB\
      \ positions to skip from the start (default 0).\n        :param encoding: Text\
      \ encoding for the message (default: UTF-8).\n        :param auto_convert_rgb:\
      \ If True and image is not 'RGB', convert it.\n        :return: A new PIL Image\
      \ with the hidden message.\n        \"\"\"\n        if auto_convert_rgb and\
      \ image.mode != \"RGB\":\n            image = image.convert(\"RGB\")\n>    \
      \   elif image.mode not in (\"RGB\", \"RGBA\"):\nE       AttributeError: 'str'\
      \ object has no attribute 'mode'\n\ngeneration\\Stegano\\stegano\\lsb\\lsb.py:33:\
      \ AttributeError\n__________________ test_lsb_hide_and_reveal_long_ascii_text\
      \ ___________________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-489/test_lsb_hide_and_reveal_long_0')\n\
      \n    def test_lsb_hide_and_reveal_long_ascii_text(tmp_path: Path) -> None:\n\
      \        \"\"\"LSB should roundtrip a longer ASCII text message (still < typical\
      \ capacity).\"\"\"\n        _ensure_image_samples_exist()\n    \n        secret\
      \ = \"This is a longer secret message with punctuation: 12345, hello-world!\"\
      \n        output = tmp_path / \"lsb_long.png\"\n    \n>       encoded_img =\
      \ lsb.hide(str(LENNA_PNG), secret)\n\ntests\\Stegano\\functional_test.py:120:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nimage = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\\repositories\\\
      \\Stegano\\\\tests\\\\sample-files\\\\Lenna.png'\nmessage = 'This is a longer\
      \ secret message with punctuation: 12345, hello-world!'\ngenerator = None, shift\
      \ = 0, encoding = 'UTF-8', auto_convert_rgb = False\n\n    def hide(\n     \
      \   image: Image.Image,\n        message: str,\n        generator: Optional[Iterator[int]]\
      \ = None,\n        shift: int = 0,\n        encoding: str = \"UTF-8\",\n   \
      \     auto_convert_rgb: bool = False\n    ) -> Image.Image:\n        \"\"\"\n\
      \        Hide a text message in the image using LSB steganography.\n       \
      \ :param image: PIL Image to use as cover.\n        :param message: The text\
      \ message to hide.\n        :param generator: Iterator of pixel indices to use\
      \ for hiding bits (default: consecutive).\n        :param shift: Number of LSB\
      \ positions to skip from the start (default 0).\n        :param encoding: Text\
      \ encoding for the message (default: UTF-8).\n        :param auto_convert_rgb:\
      \ If True and image is not 'RGB', convert it.\n        :return: A new PIL Image\
      \ with the hidden message.\n        \"\"\"\n        if auto_convert_rgb and\
      \ image.mode != \"RGB\":\n            image = image.convert(\"RGB\")\n>    \
      \   elif image.mode not in (\"RGB\", \"RGBA\"):\nE       AttributeError: 'str'\
      \ object has no attribute 'mode'\n\ngeneration\\Stegano\\stegano\\lsb\\lsb.py:33:\
      \ AttributeError\n______________________ test_lsb_reveal_from_image_object ______________________\n\
      \n    def test_lsb_reveal_from_image_object() -> None:\n        \"\"\"lsb.reveal\
      \ should work when passed a PIL.Image object (common API usage).\"\"\"\n   \
      \     _ensure_image_samples_exist()\n    \n        secret = \"object input\"\
      \n>       img_obj = lsb.hide(str(LENNA_PNG), secret)\n\ntests\\Stegano\\functional_test.py:132:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nimage = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\\repositories\\\
      \\Stegano\\\\tests\\\\sample-files\\\\Lenna.png'\nmessage = 'object input',\
      \ generator = None, shift = 0, encoding = 'UTF-8'\nauto_convert_rgb = False\n\
      \n    def hide(\n        image: Image.Image,\n        message: str,\n      \
      \  generator: Optional[Iterator[int]] = None,\n        shift: int = 0,\n   \
      \     encoding: str = \"UTF-8\",\n        auto_convert_rgb: bool = False\n \
      \   ) -> Image.Image:\n        \"\"\"\n        Hide a text message in the image\
      \ using LSB steganography.\n        :param image: PIL Image to use as cover.\n\
      \        :param message: The text message to hide.\n        :param generator:\
      \ Iterator of pixel indices to use for hiding bits (default: consecutive).\n\
      \        :param shift: Number of LSB positions to skip from the start (default\
      \ 0).\n        :param encoding: Text encoding for the message (default: UTF-8).\n\
      \        :param auto_convert_rgb: If True and image is not 'RGB', convert it.\n\
      \        :return: A new PIL Image with the hidden message.\n        \"\"\"\n\
      \        if auto_convert_rgb and image.mode != \"RGB\":\n            image =\
      \ image.convert(\"RGB\")\n>       elif image.mode not in (\"RGB\", \"RGBA\"\
      ):\nE       AttributeError: 'str' object has no attribute 'mode'\n\ngeneration\\\
      Stegano\\stegano\\lsb\\lsb.py:33: AttributeError\n________________________ test_red_hide_and_reveal_text\
      \ ________________________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-489/test_red_hide_and_reveal_text0')\n\
      \n    def test_red_hide_and_reveal_text(tmp_path: Path) -> None:\n        \"\
      \"\"red.hide(..., str) then red.reveal(...) returns the same string.\"\"\"\n\
      \        _ensure_image_samples_exist()\n    \n        secret = \"red secret\"\
      \n        output = tmp_path / \"red_lenna.png\"\n    \n>       encoded_img =\
      \ red.hide(str(LENNA_PNG), secret)\n\ntests\\Stegano\\functional_test.py:148:\
      \ \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _\n\nimage = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\\repositories\\\
      \\Stegano\\\\tests\\\\sample-files\\\\Lenna.png'\nmessage = 'red secret'\n\n\
      \    def hide(image: Image.Image, message: str) -> Image.Image:\n        \"\"\
      \"\n        Hide a text message using only the red channel.\n        :param\
      \ image: PIL Image to use as cover (RGB or RGBA ideally).\n        :param message:\
      \ The text message to hide.\n        :return: A new PIL Image with the hidden\
      \ message.\n        \"\"\"\n>       if image.mode not in (\"RGB\", \"RGBA\"\
      ):\nE       AttributeError: 'str' object has no attribute 'mode'\n\ngeneration\\\
      Stegano\\stegano\\red\\red.py:18: AttributeError\n________________ test_red_hide_and_reveal_extended_latin_text\
      \ _________________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-489/test_red_hide_and_reveal_exten0')\n\
      \n    def test_red_hide_and_reveal_extended_latin_text(tmp_path: Path) -> None:\n\
      \        \"\"\"Red backend stores per-char ord() into a byte channel; Latin-1\
      \ chars like 'é' are valid.\"\"\"\n        _ensure_image_samples_exist()\n \
      \   \n        secret = \"Café au lait\"\n        output = tmp_path / \"red_latin.png\"\
      \n    \n>       encoded_img = red.hide(str(LENNA_PNG), secret)\n\ntests\\Stegano\\\
      functional_test.py:162: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nimage = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\
      \\repositories\\\\Stegano\\\\tests\\\\sample-files\\\\Lenna.png'\nmessage =\
      \ 'Café au lait'\n\n    def hide(image: Image.Image, message: str) -> Image.Image:\n\
      \        \"\"\"\n        Hide a text message using only the red channel.\n \
      \       :param image: PIL Image to use as cover (RGB or RGBA ideally).\n   \
      \     :param message: The text message to hide.\n        :return: A new PIL\
      \ Image with the hidden message.\n        \"\"\"\n>       if image.mode not\
      \ in (\"RGB\", \"RGBA\"):\nE       AttributeError: 'str' object has no attribute\
      \ 'mode'\n\ngeneration\\Stegano\\stegano\\red\\red.py:18: AttributeError\n________________________\
      \ test_wav_hide_and_reveal_text ________________________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-489/test_wav_hide_and_reveal_text0')\n\
      \n    def test_wav_hide_and_reveal_text(tmp_path: Path) -> None:\n        \"\
      \"\"wav.hide writes output WAV; wav.reveal returns the same string.\"\"\"\n\
      \        wav_in = _pick_sample_wav()\n    \n        secret = \"wav secret\"\n\
      \        output = tmp_path / \"out.wav\"\n    \n>       wav.hide(str(wav_in),\
      \ secret, str(output))\n\ntests\\Stegano\\functional_test.py:219: \n_ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n\
      input_file = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\\repositories\\\\\
      Stegano\\\\tests\\\\sample-files\\\\free-software-song.wav'\nmessage = 'wav\
      \ secret'\noutput_file = 'C:\\\\Users\\\\86152\\\\AppData\\\\Local\\\\Temp\\\
      \\pytest-of-86152\\\\pytest-489\\\\test_wav_hide_and_reveal_text0\\\\out.wav'\n\
      kwargs = {}\nf_in = <_io.BufferedReader name='D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\
      \\repositories\\\\Stegano\\\\tests\\\\sample-files\\\\free-software-song.wav'>\n\
      wav_data = b'RIFF\\xdai\\x1a\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\\
      x00@\\x1f\\x00\\x00\\x80>\\x00\\x00\\x02\\x00\\x10\\x00data\\xb6i\\x1a\\x00...fe\\\
      xd4\\xfd\\xb6\\xfd\\xe6\\xfd\\xc2\\xfe\\xf6\\xfe\\xf7\\xfe\\xb9\\xff\\xd9\\\
      x00\\xe7\\x01\\xdc\\x01\\xa7\\x01F\\x01\\xb3\\x00;\\x00M\\xffR\\xfe'\noffset\
      \ = 36, fmt_offset = 12, data_offset = 44, data_size = 1730998\nchunk_id = b'data'\n\
      \n    def hide(input_file, message, output_file, **kwargs):\n        \"\"\"\n\
      \        Hide a message string in a 16-bit PCM WAV file, in the LSB of each\
      \ sample.\n        Writes a new file to output_file.\n        :param input_file:\
      \ path to the cover WAV file.\n        :param message: the text message to embed.\n\
      \        :param output_file: output path for the modified WAV.\n        :param\
      \ kwargs: additional arguments (ignored for signature compatibility).\n    \
      \    \"\"\"\n        with open(input_file, \"rb\") as f_in:\n            wav_data\
      \ = f_in.read()\n    \n        # Parse header\n        if not wav_data.startswith(b\"\
      RIFF\") or not wav_data[8:12] == b\"WAVE\":\n            raise ValueError(\"\
      Not a valid WAV file (missing RIFF/WAVE).\")\n    \n        # Search for 'fmt\
      \ ' chunk, 'data' chunk\n        # We'll do a simple pass to find them\n   \
      \     offset = 12  # skip RIFF header\n        fmt_offset = None\n        data_offset\
      \ = None\n        data_size = None\n    \n        while offset < len(wav_data):\n\
      \            chunk_id = wav_data[offset:offset+4]\n            chunk_size =\
      \ struct.unpack(\"<I\", wav_data[offset+4:offset+8])[0]\n            if chunk_id\
      \ == b\"fmt \":\n                fmt_offset = offset\n            elif chunk_id\
      \ == b\"data\":\n                data_offset = offset + 8\n                data_size\
      \ = chunk_size\n                break\n            offset += 8 + chunk_size\n\
      \    \n        if fmt_offset is None or data_offset is None or data_size is\
      \ None:\n            raise ValueError(\"Could not find required chunks in WAV\
      \ file.\")\n    \n        # Check if it's 16-bit PCM\n        # Format code\
      \ is at fmt_offset+8 (2 bytes)\n        audio_format, num_channels, sample_rate,\
      \ byte_rate, block_align, bits_per_sample = struct.unpack(\n            \"<HHIIHH\"\
      , wav_data[fmt_offset+8:fmt_offset+8+16]\n        )\n        if audio_format\
      \ != 1 or bits_per_sample != 16:\n            raise ValueError(\"Only 16-bit\
      \ PCM WAV is supported by this simple steganography.\")\n    \n        # Get\
      \ the sample data\n        audio_data = bytearray(wav_data[data_offset:data_offset+data_size])\n\
      \    \n        # Convert message to bits\n        # We'll store len(message)\
      \ as 4 bytes + message\n        message_bytes = message.encode(\"utf-8\")\n\
      \        msg_len = len(message_bytes)\n        length_bytes = struct.pack(\"\
      <I\", msg_len)\n        full_payload = length_bytes + message_bytes\n    \n\
      \        # Each sample is 2 bytes => we can store 1 bit per sample (LSB).\n\
      \        num_samples = len(audio_data) // 2\n    \n        total_bits = len(full_payload)\
      \ * 8\n        if total_bits > num_samples:\n            raise ValueError(\"\
      Message is too large to fit in the given WAV.\")\n    \n        # Hide bits\n\
      \        bit_idx = 0\n        for i in range(len(full_payload)):\n         \
      \   byte_val = full_payload[i]\n            for b in range(8):\n           \
      \     bit = (byte_val >> b) & 1\n                # replace LSB of sample\n \
      \               sample_idx = bit_idx\n                sample_bytes = audio_data[sample_idx*2:(sample_idx*2)+2]\n\
      \                sample_val = struct.unpack(\"<h\", sample_bytes)[0]\n     \
      \           sample_val = (sample_val & 0xFFFE) | bit\n>               audio_data[sample_idx*2:(sample_idx*2)+2]\
      \ = struct.pack(\"<h\", sample_val)\nE               struct.error: short format\
      \ requires (-32768) <= number <= 32767\n\ngeneration\\Stegano\\stegano\\wav\\\
      wav.py:82: error\n_____________________ test_wav_hide_and_reveal_short_text\
      \ _____________________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-489/test_wav_hide_and_reveal_short0')\n\
      \n    def test_wav_hide_and_reveal_short_text(tmp_path: Path) -> None:\n   \
      \     \"\"\"A short message should also roundtrip.\"\"\"\n        wav_in = _pick_sample_wav()\n\
      \    \n        secret = \"ok\"\n        output = tmp_path / \"out_short.wav\"\
      \n    \n>       wav.hide(str(wav_in), secret, str(output))\n\ntests\\Stegano\\\
      functional_test.py:234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ninput_file = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\
      \\repositories\\\\Stegano\\\\tests\\\\sample-files\\\\free-software-song.wav'\n\
      message = 'ok'\noutput_file = 'C:\\\\Users\\\\86152\\\\AppData\\\\Local\\\\\
      Temp\\\\pytest-of-86152\\\\pytest-489\\\\test_wav_hide_and_reveal_short0\\\\\
      out_short.wav'\nkwargs = {}\nf_in = <_io.BufferedReader name='D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\
      \\repositories\\\\Stegano\\\\tests\\\\sample-files\\\\free-software-song.wav'>\n\
      wav_data = b'RIFF\\xdai\\x1a\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\\
      x00@\\x1f\\x00\\x00\\x80>\\x00\\x00\\x02\\x00\\x10\\x00data\\xb6i\\x1a\\x00...fe\\\
      xd4\\xfd\\xb6\\xfd\\xe6\\xfd\\xc2\\xfe\\xf6\\xfe\\xf7\\xfe\\xb9\\xff\\xd9\\\
      x00\\xe7\\x01\\xdc\\x01\\xa7\\x01F\\x01\\xb3\\x00;\\x00M\\xffR\\xfe'\noffset\
      \ = 36, fmt_offset = 12, data_offset = 44, data_size = 1730998\nchunk_id = b'data'\n\
      \n    def hide(input_file, message, output_file, **kwargs):\n        \"\"\"\n\
      \        Hide a message string in a 16-bit PCM WAV file, in the LSB of each\
      \ sample.\n        Writes a new file to output_file.\n        :param input_file:\
      \ path to the cover WAV file.\n        :param message: the text message to embed.\n\
      \        :param output_file: output path for the modified WAV.\n        :param\
      \ kwargs: additional arguments (ignored for signature compatibility).\n    \
      \    \"\"\"\n        with open(input_file, \"rb\") as f_in:\n            wav_data\
      \ = f_in.read()\n    \n        # Parse header\n        if not wav_data.startswith(b\"\
      RIFF\") or not wav_data[8:12] == b\"WAVE\":\n            raise ValueError(\"\
      Not a valid WAV file (missing RIFF/WAVE).\")\n    \n        # Search for 'fmt\
      \ ' chunk, 'data' chunk\n        # We'll do a simple pass to find them\n   \
      \     offset = 12  # skip RIFF header\n        fmt_offset = None\n        data_offset\
      \ = None\n        data_size = None\n    \n        while offset < len(wav_data):\n\
      \            chunk_id = wav_data[offset:offset+4]\n            chunk_size =\
      \ struct.unpack(\"<I\", wav_data[offset+4:offset+8])[0]\n            if chunk_id\
      \ == b\"fmt \":\n                fmt_offset = offset\n            elif chunk_id\
      \ == b\"data\":\n                data_offset = offset + 8\n                data_size\
      \ = chunk_size\n                break\n            offset += 8 + chunk_size\n\
      \    \n        if fmt_offset is None or data_offset is None or data_size is\
      \ None:\n            raise ValueError(\"Could not find required chunks in WAV\
      \ file.\")\n    \n        # Check if it's 16-bit PCM\n        # Format code\
      \ is at fmt_offset+8 (2 bytes)\n        audio_format, num_channels, sample_rate,\
      \ byte_rate, block_align, bits_per_sample = struct.unpack(\n            \"<HHIIHH\"\
      , wav_data[fmt_offset+8:fmt_offset+8+16]\n        )\n        if audio_format\
      \ != 1 or bits_per_sample != 16:\n            raise ValueError(\"Only 16-bit\
      \ PCM WAV is supported by this simple steganography.\")\n    \n        # Get\
      \ the sample data\n        audio_data = bytearray(wav_data[data_offset:data_offset+data_size])\n\
      \    \n        # Convert message to bits\n        # We'll store len(message)\
      \ as 4 bytes + message\n        message_bytes = message.encode(\"utf-8\")\n\
      \        msg_len = len(message_bytes)\n        length_bytes = struct.pack(\"\
      <I\", msg_len)\n        full_payload = length_bytes + message_bytes\n    \n\
      \        # Each sample is 2 bytes => we can store 1 bit per sample (LSB).\n\
      \        num_samples = len(audio_data) // 2\n    \n        total_bits = len(full_payload)\
      \ * 8\n        if total_bits > num_samples:\n            raise ValueError(\"\
      Message is too large to fit in the given WAV.\")\n    \n        # Hide bits\n\
      \        bit_idx = 0\n        for i in range(len(full_payload)):\n         \
      \   byte_val = full_payload[i]\n            for b in range(8):\n           \
      \     bit = (byte_val >> b) & 1\n                # replace LSB of sample\n \
      \               sample_idx = bit_idx\n                sample_bytes = audio_data[sample_idx*2:(sample_idx*2)+2]\n\
      \                sample_val = struct.unpack(\"<h\", sample_bytes)[0]\n     \
      \           sample_val = (sample_val & 0xFFFE) | bit\n>               audio_data[sample_idx*2:(sample_idx*2)+2]\
      \ = struct.pack(\"<h\", sample_val)\nE               struct.error: short format\
      \ requires (-32768) <= number <= 32767\n\ngeneration\\Stegano\\stegano\\wav\\\
      wav.py:82: error\n____________________ test_wav_hide_and_reveal_longer_text\
      \ _____________________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-489/test_wav_hide_and_reveal_longe0')\n\
      \n    def test_wav_hide_and_reveal_longer_text(tmp_path: Path) -> None:\n  \
      \      \"\"\"Roundtrip a longer ASCII message via WAV backend.\"\"\"\n     \
      \   wav_in = _pick_sample_wav()\n    \n        secret = \"WAV backend long message:\
      \ 1234567890 abcdefghijklmnopqrstuvwxyz\"\n        output = tmp_path / \"out_long.wav\"\
      \n    \n>       wav.hide(str(wav_in), secret, str(output))\n\ntests\\Stegano\\\
      functional_test.py:249: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ninput_file = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\
      \\repositories\\\\Stegano\\\\tests\\\\sample-files\\\\free-software-song.wav'\n\
      message = 'WAV backend long message: 1234567890 abcdefghijklmnopqrstuvwxyz'\n\
      output_file = 'C:\\\\Users\\\\86152\\\\AppData\\\\Local\\\\Temp\\\\pytest-of-86152\\\
      \\pytest-489\\\\test_wav_hide_and_reveal_longe0\\\\out_long.wav'\nkwargs = {}\n\
      f_in = <_io.BufferedReader name='D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\
      \\repositories\\\\Stegano\\\\tests\\\\sample-files\\\\free-software-song.wav'>\n\
      wav_data = b'RIFF\\xdai\\x1a\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\\
      x00@\\x1f\\x00\\x00\\x80>\\x00\\x00\\x02\\x00\\x10\\x00data\\xb6i\\x1a\\x00...fe\\\
      xd4\\xfd\\xb6\\xfd\\xe6\\xfd\\xc2\\xfe\\xf6\\xfe\\xf7\\xfe\\xb9\\xff\\xd9\\\
      x00\\xe7\\x01\\xdc\\x01\\xa7\\x01F\\x01\\xb3\\x00;\\x00M\\xffR\\xfe'\noffset\
      \ = 36, fmt_offset = 12, data_offset = 44, data_size = 1730998\nchunk_id = b'data'\n\
      \n    def hide(input_file, message, output_file, **kwargs):\n        \"\"\"\n\
      \        Hide a message string in a 16-bit PCM WAV file, in the LSB of each\
      \ sample.\n        Writes a new file to output_file.\n        :param input_file:\
      \ path to the cover WAV file.\n        :param message: the text message to embed.\n\
      \        :param output_file: output path for the modified WAV.\n        :param\
      \ kwargs: additional arguments (ignored for signature compatibility).\n    \
      \    \"\"\"\n        with open(input_file, \"rb\") as f_in:\n            wav_data\
      \ = f_in.read()\n    \n        # Parse header\n        if not wav_data.startswith(b\"\
      RIFF\") or not wav_data[8:12] == b\"WAVE\":\n            raise ValueError(\"\
      Not a valid WAV file (missing RIFF/WAVE).\")\n    \n        # Search for 'fmt\
      \ ' chunk, 'data' chunk\n        # We'll do a simple pass to find them\n   \
      \     offset = 12  # skip RIFF header\n        fmt_offset = None\n        data_offset\
      \ = None\n        data_size = None\n    \n        while offset < len(wav_data):\n\
      \            chunk_id = wav_data[offset:offset+4]\n            chunk_size =\
      \ struct.unpack(\"<I\", wav_data[offset+4:offset+8])[0]\n            if chunk_id\
      \ == b\"fmt \":\n                fmt_offset = offset\n            elif chunk_id\
      \ == b\"data\":\n                data_offset = offset + 8\n                data_size\
      \ = chunk_size\n                break\n            offset += 8 + chunk_size\n\
      \    \n        if fmt_offset is None or data_offset is None or data_size is\
      \ None:\n            raise ValueError(\"Could not find required chunks in WAV\
      \ file.\")\n    \n        # Check if it's 16-bit PCM\n        # Format code\
      \ is at fmt_offset+8 (2 bytes)\n        audio_format, num_channels, sample_rate,\
      \ byte_rate, block_align, bits_per_sample = struct.unpack(\n            \"<HHIIHH\"\
      , wav_data[fmt_offset+8:fmt_offset+8+16]\n        )\n        if audio_format\
      \ != 1 or bits_per_sample != 16:\n            raise ValueError(\"Only 16-bit\
      \ PCM WAV is supported by this simple steganography.\")\n    \n        # Get\
      \ the sample data\n        audio_data = bytearray(wav_data[data_offset:data_offset+data_size])\n\
      \    \n        # Convert message to bits\n        # We'll store len(message)\
      \ as 4 bytes + message\n        message_bytes = message.encode(\"utf-8\")\n\
      \        msg_len = len(message_bytes)\n        length_bytes = struct.pack(\"\
      <I\", msg_len)\n        full_payload = length_bytes + message_bytes\n    \n\
      \        # Each sample is 2 bytes => we can store 1 bit per sample (LSB).\n\
      \        num_samples = len(audio_data) // 2\n    \n        total_bits = len(full_payload)\
      \ * 8\n        if total_bits > num_samples:\n            raise ValueError(\"\
      Message is too large to fit in the given WAV.\")\n    \n        # Hide bits\n\
      \        bit_idx = 0\n        for i in range(len(full_payload)):\n         \
      \   byte_val = full_payload[i]\n            for b in range(8):\n           \
      \     bit = (byte_val >> b) & 1\n                # replace LSB of sample\n \
      \               sample_idx = bit_idx\n                sample_bytes = audio_data[sample_idx*2:(sample_idx*2)+2]\n\
      \                sample_val = struct.unpack(\"<h\", sample_bytes)[0]\n     \
      \           sample_val = (sample_val & 0xFFFE) | bit\n>               audio_data[sample_idx*2:(sample_idx*2)+2]\
      \ = struct.pack(\"<h\", sample_val)\nE               struct.error: short format\
      \ requires (-32768) <= number <= 32767\n\ngeneration\\Stegano\\stegano\\wav\\\
      wav.py:82: error\n_____________________ test_lsb_and_red_outputs_are_files ______________________\n\
      \ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-489/test_lsb_and_red_outputs_are_f0')\n\
      \n    def test_lsb_and_red_outputs_are_files(tmp_path: Path) -> None:\n    \
      \    \"\"\"Ensure image-encoding backends produce files that can be written\
      \ to disk.\"\"\"\n        _ensure_image_samples_exist()\n    \n        out_lsb\
      \ = tmp_path / \"lsb_file.png\"\n        out_red = tmp_path / \"red_file.png\"\
      \n    \n>       lsb.hide(str(LENNA_PNG), \"x\").save(str(out_lsb))\n\ntests\\\
      Stegano\\functional_test.py:268: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nimage = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\
      \\repositories\\\\Stegano\\\\tests\\\\sample-files\\\\Lenna.png'\nmessage =\
      \ 'x', generator = None, shift = 0, encoding = 'UTF-8'\nauto_convert_rgb = False\n\
      \n    def hide(\n        image: Image.Image,\n        message: str,\n      \
      \  generator: Optional[Iterator[int]] = None,\n        shift: int = 0,\n   \
      \     encoding: str = \"UTF-8\",\n        auto_convert_rgb: bool = False\n \
      \   ) -> Image.Image:\n        \"\"\"\n        Hide a text message in the image\
      \ using LSB steganography.\n        :param image: PIL Image to use as cover.\n\
      \        :param message: The text message to hide.\n        :param generator:\
      \ Iterator of pixel indices to use for hiding bits (default: consecutive).\n\
      \        :param shift: Number of LSB positions to skip from the start (default\
      \ 0).\n        :param encoding: Text encoding for the message (default: UTF-8).\n\
      \        :param auto_convert_rgb: If True and image is not 'RGB', convert it.\n\
      \        :return: A new PIL Image with the hidden message.\n        \"\"\"\n\
      \        if auto_convert_rgb and image.mode != \"RGB\":\n            image =\
      \ image.convert(\"RGB\")\n>       elif image.mode not in (\"RGB\", \"RGBA\"\
      ):\nE       AttributeError: 'str' object has no attribute 'mode'\n\ngeneration\\\
      Stegano\\stegano\\lsb\\lsb.py:33: AttributeError\n===========================\
      \ short test summary info ===========================\nFAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_text\
      \ - Attr...\nFAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_with_generator\n\
      FAILED tests/Stegano/functional_test.py::test_lsb_hide_and_reveal_long_ascii_text\n\
      FAILED tests/Stegano/functional_test.py::test_lsb_reveal_from_image_object -\
      \ ...\nFAILED tests/Stegano/functional_test.py::test_red_hide_and_reveal_text\
      \ - Attr...\nFAILED tests/Stegano/functional_test.py::test_red_hide_and_reveal_extended_latin_text\n\
      FAILED tests/Stegano/functional_test.py::test_wav_hide_and_reveal_text - stru...\n\
      FAILED tests/Stegano/functional_test.py::test_wav_hide_and_reveal_short_text\n\
      FAILED tests/Stegano/functional_test.py::test_wav_hide_and_reveal_longer_text\n\
      FAILED tests/Stegano/functional_test.py::test_lsb_and_red_outputs_are_files\n\
      10 failed, 2 passed in 45.49s\n"
    elapsed_time_s: 46.765549
    avg_memory_mb: 37.85
    avg_cpu_percent: 0.31
    passed: 2
    failed: 10
    skipped: 0
    total: 12
    score_inputs_passed: 2
    score_inputs_failed: 10
    score_inputs_total: 12
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - functional_suite_time_s
    - functional_tests_total
  performance:
    returncode: 1
    stdout: "F                                                                   \
      \     [100%]\n================================== FAILURES ===================================\n\
      _________________________ test_lsb_performance_smoke __________________________\n\
      \n    def test_lsb_performance_smoke() -> None:\n        \"\"\"Simple performance\
      \ sanity check for LSB hide/reveal.\"\"\"\n>       avg_hide, avg_reveal = _measure_hide_reveal(iterations=5)\n\
      \ntests\\Stegano\\performance_test.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests\\Stegano\\performance_test.py:48:\
      \ in _measure_hide_reveal\n    secret_img = lsb.hide(str(LENNA_PNG), message)\n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\n\nimage = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\\repositories\\\
      \\Stegano\\\\tests\\\\sample-files\\\\Lenna.png'\nmessage = 'Performance benchmark\
      \ message for SteganoPerformance benchmark message for SteganoPerformance benchmark\
      \ message for Stegano'\ngenerator = None, shift = 0, encoding = 'UTF-8', auto_convert_rgb\
      \ = False\n\n    def hide(\n        image: Image.Image,\n        message: str,\n\
      \        generator: Optional[Iterator[int]] = None,\n        shift: int = 0,\n\
      \        encoding: str = \"UTF-8\",\n        auto_convert_rgb: bool = False\n\
      \    ) -> Image.Image:\n        \"\"\"\n        Hide a text message in the image\
      \ using LSB steganography.\n        :param image: PIL Image to use as cover.\n\
      \        :param message: The text message to hide.\n        :param generator:\
      \ Iterator of pixel indices to use for hiding bits (default: consecutive).\n\
      \        :param shift: Number of LSB positions to skip from the start (default\
      \ 0).\n        :param encoding: Text encoding for the message (default: UTF-8).\n\
      \        :param auto_convert_rgb: If True and image is not 'RGB', convert it.\n\
      \        :return: A new PIL Image with the hidden message.\n        \"\"\"\n\
      \        if auto_convert_rgb and image.mode != \"RGB\":\n            image =\
      \ image.convert(\"RGB\")\n>       elif image.mode not in (\"RGB\", \"RGBA\"\
      ):\nE       AttributeError: 'str' object has no attribute 'mode'\n\ngeneration\\\
      Stegano\\stegano\\lsb\\lsb.py:33: AttributeError\n===========================\
      \ short test summary info ===========================\nFAILED tests/Stegano/performance_test.py::test_lsb_performance_smoke\
      \ - Attrib...\n1 failed in 0.40s\n"
    elapsed_time_s: 1.662788
    avg_memory_mb: 33.04
    avg_cpu_percent: 98.0
    passed: 0
    failed: 1
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 1
    score_inputs_total: 1
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - performance_suite_time_s
    - performance_tests_total
    score_inputs_baseline_time_s: 2.257945
    score_inputs_actual_time_s: 1.662788
  resource:
    returncode: 1
    stdout: "F                                                                   \
      \     [100%]\n================================== FAILURES ===================================\n\
      __________________________ test_resource_usage_smoke __________________________\n\
      \n    def test_resource_usage_smoke() -> None:\n        \"\"\"\n        Smoke\
      \ test: exercise a representative workload.\n    \n        Important:\n    \
      \      - Benchmark runner (measure_generated.py) measures resource usage of\
      \ pytest subprocess.\n          - This test remains a correctness-oriented smoke\
      \ test.\n        \"\"\"\n        assert LENNA_PNG.exists(), f\"Missing sample\
      \ file: {LENNA_PNG}\"\n    \n        proc = psutil.Process()\n        rss_before\
      \ = proc.memory_info().rss\n    \n        secret = \"resource secret\"\n   \
      \     out = REPO_ROOT / \"tmp_resource.png\"\n    \n>       encoded_img = lsb.hide(str(LENNA_PNG),\
      \ secret)  # returns PIL.Image\n\ntests\\Stegano\\resource_test.py:55: \n_ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _\n\nimage = 'D:\\\\桌面\\\\RealAppCodeBench_generic_eval\\\\repositories\\\\\
      Stegano\\\\tests\\\\sample-files\\\\Lenna.png'\nmessage = 'resource secret',\
      \ generator = None, shift = 0, encoding = 'UTF-8'\nauto_convert_rgb = False\n\
      \n    def hide(\n        image: Image.Image,\n        message: str,\n      \
      \  generator: Optional[Iterator[int]] = None,\n        shift: int = 0,\n   \
      \     encoding: str = \"UTF-8\",\n        auto_convert_rgb: bool = False\n \
      \   ) -> Image.Image:\n        \"\"\"\n        Hide a text message in the image\
      \ using LSB steganography.\n        :param image: PIL Image to use as cover.\n\
      \        :param message: The text message to hide.\n        :param generator:\
      \ Iterator of pixel indices to use for hiding bits (default: consecutive).\n\
      \        :param shift: Number of LSB positions to skip from the start (default\
      \ 0).\n        :param encoding: Text encoding for the message (default: UTF-8).\n\
      \        :param auto_convert_rgb: If True and image is not 'RGB', convert it.\n\
      \        :return: A new PIL Image with the hidden message.\n        \"\"\"\n\
      \        if auto_convert_rgb and image.mode != \"RGB\":\n            image =\
      \ image.convert(\"RGB\")\n>       elif image.mode not in (\"RGB\", \"RGBA\"\
      ):\nE       AttributeError: 'str' object has no attribute 'mode'\n\ngeneration\\\
      Stegano\\stegano\\lsb\\lsb.py:33: AttributeError\n===========================\
      \ short test summary info ===========================\nFAILED tests/Stegano/resource_test.py::test_resource_usage_smoke\
      \ - AttributeE...\n1 failed in 0.41s\n"
    elapsed_time_s: 1.574074
    avg_memory_mb: 34.58
    avg_cpu_percent: 101.1
    passed: 0
    failed: 1
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 1
    score_inputs_total: 1
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - avg_cpu_percent
    - avg_memory_mb
    - resource_suite_time_s
    - resource_tests_total
    score_inputs_baseline_mem_mb: 50.48
    score_inputs_baseline_cpu_pct: 96.4
    score_inputs_actual_mem_mb: 34.58
    score_inputs_actual_cpu_pct: 101.1
  robustness:
    returncode: 0
    stdout: '....                                                                     [100%]

      4 passed in 0.23s

      '
    elapsed_time_s: 1.481481
    avg_memory_mb: 34.1
    avg_cpu_percent: 101.1
    passed: 4
    failed: 0
    skipped: 0
    total: 4
    score_inputs_passed: 4
    score_inputs_failed: 0
    score_inputs_total: 4
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - robustness_suite_time_s
    - robustness_tests_total
  security:
    returncode: 0
    stdout: 'SECURITY_METRICS high_risk_count=0.0 files_scanned=16.0 total_loc=486.0

      .

      1 passed in 0.12s

      '
    elapsed_time_s: 1.230479
    avg_memory_mb: 31.58
    avg_cpu_percent: 98.7
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 16.0
      total_loc: 486.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - metrics
    - security_suite_time_s
    - security_tests_total
    score_inputs_baseline_high_risk_count: 0.0
    score_inputs_generated_high_risk_count: 0.0
  maintainability:
    returncode: 0
    stdout: 'MAINT_METRICS mi_min=26.2416 files_scanned=16.0 total_loc=486.0 max_cc=17.0

      .

      1 passed in 0.16s

      '
    elapsed_time_s: 1.290945
    avg_memory_mb: 31.79
    avg_cpu_percent: 98.7
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      mi_min: 26.2416
      files_scanned: 16.0
      total_loc: 486.0
      max_cc: 17.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - maintainability_suite_time_s
    - maintainability_tests_total
    - metrics
    score_inputs_baseline_mi_min: 22.4495
    score_inputs_generated_mi_min: 26.2416
    score_inputs_ratio_g_over_b: 1.1689169023808992
baseline_metrics:
  functional:
    functional_suite_time_s: 12.134699
    functional_tests_total: 12
  performance:
    performance_suite_time_s: 2.257945
    performance_tests_total: 1
  resource:
    resource_suite_time_s: 1.861629
    resource_tests_total: 1
    avg_memory_mb: 50.48
    avg_cpu_percent: 96.4
  robustness:
    robustness_suite_time_s: 1.749913
    robustness_tests_total: 4
  security:
    security_suite_time_s: 1.434441
    security_tests_total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 20.0
      total_loc: 1057.0
  maintainability:
    maintainability_suite_time_s: 1.529301
    maintainability_tests_total: 1
    metrics:
      mi_min: 22.4495
      files_scanned: 18.0
      total_loc: 1057.0
      max_cc: 20.0
pytest_logs_dir: D:\桌面\RealAppCodeBench_generic_eval\results\Stegano\pytest_logs
