<file:name=mailpile/__init__.py>
# Minimal Mailpile core-slice package used for benchmarks/tests.

__all__ = [
    "safe_popen",
    "util",
    "vcard",
    "i18n",
]
</file>

<file:name=mailpile/safe_popen.py>
import os
import subprocess
import threading
from typing import Optional, Sequence, Union


def _to_bytes(data):
    if data is None:
        return None
    if isinstance(data, bytes):
        return data
    return str(data).encode("utf-8", "replace")


def _to_text(data):
    if data is None:
        return None
    if isinstance(data, str):
        return data
    return data.decode("utf-8", "replace")


class SafePopen(subprocess.Popen):
    """
    Small wrapper around subprocess.Popen with convenience helpers and safe
    defaults: no shell by default, close_fds, and optional text-mode I/O.
    """

    def __init__(
        self,
        args: Union[str, Sequence[str]],
        stdin=None,
        stdout=None,
        stderr=None,
        shell: bool = False,
        close_fds: bool = True,
        env: Optional[dict] = None,
        cwd: Optional[str] = None,
        text: bool = False,
        **kwargs,
    ):
        self._text_mode = bool(text)
        super().__init__(
            args,
            stdin=stdin,
            stdout=stdout,
            stderr=stderr,
            shell=shell,
            close_fds=close_fds,
            env=env,
            cwd=cwd,
            **kwargs,
        )

    def communicate(self, input=None, timeout=None):
        if self._text_mode and isinstance(input, str):
            input = _to_bytes(input)
        out, err = super().communicate(input=input, timeout=timeout)
        if self._text_mode:
            out = _to_text(out)
            err = _to_text(err)
        return out, err


def safe_popen(*args, **kwargs) -> SafePopen:
    return SafePopen(*args, **kwargs)


def safe_popen_get_output(
    args: Union[str, Sequence[str]],
    input_data: Optional[Union[str, bytes]] = None,
    env: Optional[dict] = None,
    cwd: Optional[str] = None,
    timeout: Optional[float] = None,
    text: bool = True,
) -> str:
    """
    Run a subprocess and return stdout (decoded if text=True). Raises CalledProcessError on failure.
    """
    p = SafePopen(
        args,
        stdin=subprocess.PIPE if input_data is not None else None,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=env,
        cwd=cwd,
        text=False,
    )
    out, err = p.communicate(input=_to_bytes(input_data), timeout=timeout)
    rc = p.returncode
    if rc != 0:
        e = subprocess.CalledProcessError(rc, args, output=out, stderr=err)
        raise e
    if text:
        return _to_text(out or b"")
    return out or b""


class PipeReader(threading.Thread):
    """
    Helper thread which reads from a file-like object until EOF.
    """

    def __init__(self, fd, collect: bool = True):
        super().__init__(daemon=True)
        self.fd = fd
        self.collect = collect
        self.data = b""
        self._done = threading.Event()

    def run(self):
        try:
            chunks = []
            while True:
                buf = self.fd.read(8192)
                if not buf:
                    break
                if self.collect:
                    chunks.append(buf)
            if self.collect:
                self.data = b"".join(chunks)
        finally:
            self._done.set()

    def join_and_get(self, timeout: Optional[float] = None) -> bytes:
        self.join(timeout=timeout)
        return self.data


def pipe(*cmd, input_data: Optional[Union[str, bytes]] = None, env=None, cwd=None) -> bytes:
    """
    Run a command and return raw stdout bytes. Convenience wrapper.
    """
    return safe_popen_get_output(list(cmd), input_data=input_data, env=env, cwd=cwd, text=False)
</file>

<file:name=mailpile/util.py>
import re
import time
from typing import Any, Iterable, Optional

B36_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz"
_B36_MAP = {c: i for i, c in enumerate(B36_ALPHABET)}


def b36(n: int) -> str:
    """Convert an integer to base36 (lowercase)."""
    if n is None:
        raise TypeError("b36() requires an integer")
    if n == 0:
        return "0"
    if n < 0:
        return "-" + b36(-n)
    out = []
    while n:
        n, r = divmod(n, 36)
        out.append(B36_ALPHABET[r])
    return "".join(reversed(out))


def unb36(s: str) -> int:
    """Convert base36 string to integer."""
    if s is None:
        raise TypeError("unb36() requires a string")
    s = str(s).strip().lower()
    if not s:
        raise ValueError("Empty base36 value")
    neg = s.startswith("-")
    if neg:
        s = s[1:]
    n = 0
    for ch in s:
        if ch not in _B36_MAP:
            raise ValueError("Invalid base36 character: %r" % ch)
        n = n * 36 + _B36_MAP[ch]
    return -n if neg else n


_WS_RE = re.compile(r"\s+", re.UNICODE)


def CleanText(s: Any, maxlen: Optional[int] = None) -> str:
    """
    Normalize arbitrary input to a safe-ish single-line string:
    - convert to str
    - replace CR/LF/TAB with spaces
    - collapse whitespace
    - strip
    - optionally truncate
    """
    if s is None:
        s = ""
    if isinstance(s, bytes):
        s = s.decode("utf-8", "replace")
    else:
        s = str(s)
    s = s.replace("\r", " ").replace("\n", " ").replace("\t", " ")
    s = _WS_RE.sub(" ", s).strip()
    if maxlen is not None and maxlen >= 0 and len(s) > maxlen:
        s = s[:maxlen]
    return s


def elapsed_timestamp(ts: Optional[float] = None) -> str:
    """
    Return a compact, deterministic timestamp string used in logs/ids.
    """
    if ts is None:
        ts = time.time()
    # Milliseconds, base36, for compactness.
    ms = int(ts * 1000)
    return b36(ms)


def dict_merge(*dicts: dict) -> dict:
    out = {}
    for d in dicts:
        if d:
            out.update(d)
    return out


def uniq(seq: Iterable[Any]) -> list:
    """Stable unique of a sequence."""
    seen = set()
    out = []
    for x in seq:
        if x not in seen:
            seen.add(x)
            out.append(x)
    return out
</file>

<file:name=mailpile/vcard.py>
import re
from typing import Dict, List, Optional, Tuple


def _unescape_value(val: str) -> str:
    # vCard escaping (subset sufficient for tests)
    return (
        val.replace(r"\n", "\n")
        .replace(r"\N", "\n")
        .replace(r"\,", ",")
        .replace(r"\;", ";")
        .replace(r"\\", "\\")
    )


def _escape_value(val: str) -> str:
    val = val.replace("\\", r"\\")
    val = val.replace("\n", r"\n")
    val = val.replace(",", r"\,")
    val = val.replace(";", r"\;")
    return val


_PARAM_SPLIT_RE = re.compile(r";(?=(?:[^"]*"[^"]*")*[^"]*$)")


class VCardLine:
    """
    Parse and serialize a single vCard content line.

    Supported format:
      NAME;PARAM=VALUE;PARAM2=V1,V2:VALUE
    """

    def __init__(
        self,
        name: str,
        value: str = "",
        params: Optional[Dict[str, List[str]]] = None,
        group: Optional[str] = None,
    ):
        self.group = group
        self.name = (name or "").upper()
        self.params: Dict[str, List[str]] = {}
        if params:
            for k, v in params.items():
                self.params[k.upper()] = list(v)
        self.value = value

    @classmethod
    def parse(cls, line: str) -> "VCardLine":
        if isinstance(line, bytes):
            line = line.decode("utf-8", "replace")
        line = line.strip("\r\n")
        if ":" not in line:
            raise ValueError("Invalid vCard line (missing ':'): %r" % line)
        left, value = line.split(":", 1)

        group = None
        if "." in left:
            group, left = left.split(".", 1)

        parts = _PARAM_SPLIT_RE.split(left)
        name = parts[0]
        params: Dict[str, List[str]] = {}
        for p in parts[1:]:
            if not p:
                continue
            if "=" in p:
                k, v = p.split("=", 1)
                k = k.strip().upper()
                v = v.strip()
                # Remove surrounding quotes; keep simple
                if len(v) >= 2 and v[0] == '"' and v[-1] == '"':
                    v = v[1:-1]
                vals = [x for x in v.split(",") if x != ""]
                params[k] = vals
            else:
                # "TYPE" shorthand (RFC allows bare parameter values)
                params.setdefault("TYPE", []).append(p.strip())
        return cls(name=name, value=_unescape_value(value), params=params, group=group)

    def as_vcardline(self) -> str:
        left = self.name
        if self.group:
            left = f"{self.group}.{left}"

        # Stable order: TYPE first, then others sorted
        items: List[Tuple[str, List[str]]] = []
        if "TYPE" in self.params:
            items.append(("TYPE", self.params["TYPE"]))
        for k in sorted(k for k in self.params.keys() if k != "TYPE"):
            items.append((k, self.params[k])

                         )
        for k, vals in items:
            if vals is None:
                continue
            if len(vals) == 0:
                left += f";{k}="
            else:
                left += f";{k}=" + ",".join(vals)
        return left + ":" + _escape_value(self.value)

    def __str__(self) -> str:
        return self.as_vcardline()

    def get_param(self, key: str, default=None):
        key = (key or "").upper()
        if key not in self.params:
            return default
        return self.params[key]

    def set_param(self, key: str, values):
        key = (key or "").upper()
        if values is None:
            self.params.pop(key, None)
        elif isinstance(values, (list, tuple)):
            self.params[key] = [str(v) for v in values]
        else:
            self.params[key] = [str(values)]
</file>

<file:name=mailpile/i18n.py>
"""
Tiny gettext passthrough used by tests.

Mailpile's full codebase has richer i18n; for this slice we only provide:
  - gettext: identity
  - ngettext: plural passthrough
  - _ and N_ aliases
"""


def gettext(msg: str) -> str:
    return msg


def ngettext(singular: str, plural: str, n: int) -> str:
    return singular if n == 1 else plural


_ = gettext


def N_(msg: str) -> str:
    # Marker for strings to be translated; runtime no-op.
    return msg
</file>

<file:name=setup.py>
from setuptools import setup, find_packages

setup(
    name="mailpile-slice",
    version="0.0.0",
    description="Self-contained slice of Mailpile core modules for benchmarks/tests",
    packages=find_packages(),
)
</file>