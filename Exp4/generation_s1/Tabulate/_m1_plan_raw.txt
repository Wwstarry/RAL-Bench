<plan>
1) Repository layout and import graph
   - Package layout
     - tabulate/__init__.py
       - Re-export: tabulate(), simple_separated_format()
       - Expose: PRESET_FORMATS (optional but convenient)
       - Define __all__
     - tabulate/core.py
       - Implements tabulate() and all normalization/formatting logic
       - Contains internal helpers: data normalization, type detection, alignment, width computation, multiline rendering, numeric parsing/formatting, header inference
       - Imports table format definitions from tabulate/formats.py
     - tabulate/formats.py
       - Defines TableFormat and Line templates (lightweight, pure-Python)
       - Defines simple_separated_format()
       - Defines preset formats dict: plain, grid, pipe, html, tsv, csv (and any other minimal ones required by tests)
     - tabulate/cli.py
       - Minimal CLI wrapper around core.tabulate
       - Parses stdin / file, delimiter choice, tablefmt, headers, and prints output
       - Not required by core tests but included for completeness
   - Import graph
     - __init__.py imports from core and formats
     - core.py imports formats (PRESET_FORMATS and TableFormat helpers)
     - formats.py is standalone (only stdlib)
     - cli.py imports core.tabulate and formats.PRESET_FORMATS

2) Public APIs to implement (modules/classes/functions)
   - tabulate/__init__.py
     - tabulate(...) -> str
     - simple_separated_format(...) -> TableFormat
     - Possibly: __version__ (optional; not required unless tests expect it)
   - tabulate/core.py
     - tabulate(tabular_data, headers=(), tablefmt="simple"/"plain"/..., floatfmt="g", numalign="decimal", stralign="left", missingval="", showindex="default", disable_numparse=False, colalign=None, maxcolwidths=None, ...) -> str
       - Implement the core options most likely exercised by black-box tests:
         - tabular_data: list-of-lists, list-of-tuples, list-of-dicts, dict-of-lists, dict (mapping), iterable of iterables
         - headers: (), "firstrow", "keys", list/tuple
         - tablefmt: string key into PRESET_FORMATS or a TableFormat instance
         - floatfmt: "g" (default), ".2f", etc. (format spec)
         - numalign: "right"/"center"/"left"/"decimal"
         - stralign: "left"/"center"/"right"
         - missingval: replacement for None / missing keys
         - showindex: False/True/"always"/"never"/"default" (support True/False and "always"/"never" minimally)
         - disable_numparse: bool
         - colalign: list of alignments per column; overrides numalign/stralign decisions
         - maxcolwidths: None or int or list[int] (truncate/wrap; if tests don’t cover, keep minimal truncate behavior)
     - Internal helpers (not public, but implement cleanly):
       - _normalize_tabular_data(tabular_data, headers, showindex, missingval) -> (rows, headers)
       - _is_dict_like(obj), _is_iterable(obj)
       - _infer_headers(tabular_data, headers)
       - _format_cell(value, floatfmt, missingval, disable_numparse) -> str
       - _split_multiline(text) -> list[str]
       - _compute_widths(rows, headers, pad) -> widths
       - _align(text, width, alignment, pad_left, pad_right, decimal_point=".")
       - _decimal_align(texts, width) for numalign="decimal"
       - _pad_cell_lines(lines, height) to equalize multiline rows
       - _render_table(rows, headers, tablefmt_obj, colalign, widths) -> str
   - tabulate/formats.py
     - Data structures:
       - Line: a simple container for left, mid, right, and fill characters (or literal strings) used in separators
       - TableFormat: container defining:
         - lineabove, linebelowheader, linebetweenrows, linebelow (Line or None)
         - headerrow (Line-like: vertical separators; or use strings)
         - datarow (Line-like)
         - padding (int or (left,right))
         - with_header_hide (list of strings; optional)
         - rowsep (bool) for formats like grid that draw between each row
         - multiline strategy (default: expand rows)
         - predefined "html" behavior (wrap <table><tr><td> etc.)
     - simple_separated_format(separator="\t", ...) -> TableFormat
       - For TSV/CSV-like formats with no borders, just join cells with separator.
       - Handle quoting minimally for CSV if tests expect it; otherwise keep simple join with separator and replace newlines appropriately.
     - Preset formats dictionary, at least:
       - "plain": no borders, spaces as separators between columns (single space), no header underline unless requested by tests; for Tabulate compatibility, plain typically uses no lines and uses minimal spacing.
       - "grid": ASCII grid with +---+ and | cells |
       - "pipe": Markdown pipe table with header separator row using dashes and optional colons for alignment
       - "html": HTML table (<table><thead>...); keep minimal valid output
       - "tsv": separator = "\t"
       - "csv": separator = ","
   - tabulate/cli.py
     - main(argv=None) -> int
       - Read stdin, split by delimiter (default: whitespace or CSV)
       - Call tabulate(...), print.
     - If black-box tests don’t call CLI, keep it correct but minimal.

3) Key behaviors & edge cases
   - Input normalization
     - list of lists/tuples: treat each inner iterable as a row; ragged rows should be padded with missingval to max columns.
     - dict-of-lists: keys become headers if headers="keys" or headers empty; values are columns; transpose into rows; missing/short columns filled with missingval.
     - list of dicts:
       - If headers="keys": union of keys preserving insertion order of first dict then new keys as encountered (match typical behavior).
       - If headers is a list: use that order; missing keys use missingval.
     - single dict (mapping):
       - Common tabulate behavior is two-column table of key/value unless dict values are iterables forming columns. Implement simplest robust approach:
         - If all values are scalar (non-iterable or string/bytes treated scalar): render as two columns: key, value, headers = ["key","value"] unless headers provided.
         - If values are iterable and of equal lengths: treat as dict-of-lists.
   - Headers behavior
     - headers=(): no header row.
     - headers="firstrow": first row becomes header, remaining rows are data.
     - headers="keys": use dict keys as header; for list-of-dicts use union of keys.
     - headers as list/tuple: use directly; if shorter than columns, pad; if longer, ignore extra.
   - Type handling and number parsing
     - Mixed numeric and strings:
       - Determine per-cell string representation via:
         - None -> missingval
         - bool should not be treated as number for decimal alignment (reference tabulate treats bool as int-ish sometimes; safer: treat bool as string unless tests require numeric; mitigation: treat bool as numeric only if disable_numparse is False and numalign requested).
         - int/float/Decimal/Fraction: numeric
         - numeric-like strings: if disable_numparse=False, attempt parse to Decimal for alignment decisions; but keep original string for output (except float formatting for actual numbers).
       - float formatting:
         - If value is float/Decimal and floatfmt provided, apply format spec (e.g., format(x, floatfmt) if floatfmt looks like ".2f" or "g"); for compatibility implement:
           - if floatfmt is a string: use format(value, floatfmt)
           - if floatfmt is a list/tuple per-column (optional if tests cover)
     - Alignment decisions
       - Column default alignment:
         - If colalign provided: use it.
         - Else: if column is numeric (all non-empty cells numeric): use numalign (default "decimal"); else use stralign ("left").
       - Decimal alignment:
         - Align decimal points by splitting at "." (or locale decimal point not needed); compute max left and right widths; pad left so decimal points line up.
         - If a cell has no decimal point, treat right part length 0; still align decimal point position.
         - For scientific notation, leave as-is and right-align unless tests expect special handling; simplest: treat "1e-3" as no decimal point and right-align.
   - Width calculation and padding
     - Convert all cells to strings, then handle multiline:
       - Split by "\n" into lines; width is max visual line length (len of line; no wide unicode handling unless tests require).
       - Row height is max number of lines among its cells; expand other cells with empty lines.
     - Apply padding:
       - For borderless formats, ensure at least one space between columns (except separated formats like TSV/CSV where separator controls spacing).
       - For bordered formats, pad inside cell by 1 space left/right (typical grid).
   - Multiline cell handling
     - For grid/plain/pipe:
       - Expand rows to multiple physical lines, keeping column widths consistent.
       - For grid: each physical line is rendered with | separators and proper padding; horizontal lines should span full width.
       - For plain/pipe: render each physical line similarly; in pipe, keep “|” at ends for each physical line.
     - For TSV/CSV: multiline likely should be preserved inside the cell; simplest: keep newline as-is (may break row structure). Better: replace internal newlines with "\\n" or spaces. Unless tests cover, choose reference-like behavior: tabulate typically expands multiline for most formats; for separated formats, join lines with " " (space).
   - Table format rendering specifics
     - plain:
       - No borders, no horizontal rules. Columns separated by a single space (or two spaces) consistently. To match common tabulate behavior, use two spaces between columns for readability (reference uses 2 spaces in “plain”/“simple”). However user asked “plain”; implement “plain” with single space; and additionally include a “simple” preset with 2-space separation and header underline (if needed by tests). Even if not requested, tests may reference “simple”.
     - grid:
       - +----+ style lines above, between header and data, between rows (optional), and below.
       - Use header separator always when headers present.
     - pipe (Markdown):
       - Header row with pipes.
       - Alignment rule row:
         - left: :---, right: ---:, center: :---:, default: ---.
         - Width at least 3 dashes, or match column width.
     - html:
       - <table>
           <thead><tr><th>...</th></tr></thead>
           <tbody><tr><td>...</td></tr></tbody>
         - Escape &, <, >, " in cell content.
         - For multiline, replace "\n" with "<br/>".
     - tsv/csv:
       - Join cells with separator.
       - For csv, implement minimal RFC4180 quoting:
         - If cell contains separator, quote, or newline: wrap in quotes and double internal quotes.
   - showindex behavior
     - If showindex is True/"always": prepend an index column (0..n-1) with header "" (or "#"/"index" depending on tests; default use "")
     - If showindex is False: do not add.
     - If showindex is "default": do not add unless input is a DataFrame-like (not implemented).
   - Deterministic ordering
     - For dict keys ordering: preserve insertion order (Python 3.7+). For union of keys, preserve first-seen order.

4) Minimal internal test plan (what to test and why)
   - Core data normalization
     - list-of-lists with ragged rows -> correct padding with missingval.
     - list-of-dicts with headers="keys" -> union ordering stable, missing keys filled.
     - dict-of-lists -> transpose correctness, unequal lengths padded.
     - dict scalar -> key/value 2-col rendering.
     - headers="firstrow" -> first row extracted.
     - showindex True -> correct index column widths/alignment.
   - Formatting snapshots per format
     - plain:
       - no borders, consistent spacing, alignment left/right/decimal.
     - grid:
       - correct border lengths, header separator, multiline expansion.
     - pipe:
       - correct alignment rule row, widths, multiline.
     - html:
       - escaping and <br/> for multiline.
     - tsv/csv:
       - correct separators; csv quoting with commas/quotes/newlines.
   - Alignment and width computation
     - numeric vs string column detection:
       - ["1","2.0","x"] should become string-aligned unless disable_numparse=False and majority numeric not implemented; keep strict “all numeric” to choose numeric alignment; test that.
     - decimal alignment:
       - ["1", "10.2", "3.45"] align decimal points.
     - multiline:
       - cell "a\nbb" next to "ccc" => row height 2, widths correct.
   - Edge cases
     - empty input -> "" (or header-only behavior).
     - headers provided but no rows -> header-only output consistent.
     - non-string objects (e.g., objects with __str__) -> string conversion.
     - wide unicode not tested; ignore.

5) Risks (dependencies, tricky behaviors) and mitigations
   - Risk: Reference tabulate has many options and nuanced defaults (e.g., “simple” vs “plain”, header underlines, spacing rules).
     - Mitigation: Implement “plain”, “simple”, “grid”, “pipe”, “html”, “tsv”, “csv”; map unknown “tablefmt” names to closest (raise KeyError otherwise). Keep defaults aligned with common tabulate: default tablefmt="simple", numalign="decimal", stralign="left".
   - Risk: Numeric parsing differences (strings that look numeric, bool handling, Decimal alignment rules).
     - Mitigation: Implement conservative numeric inference:
       - Treat actual numbers as numeric always.
       - Optionally parse numeric-like strings only if disable_numparse=False; but only use for alignment decisions, not for changing output text.
       - Exclude booleans from numeric unless explicitly desired (configurable internally).
   - Risk: Multiline rendering and border calculations are easy to off-by-one.
     - Mitigation: Centralize width computation on per-line max, then render using a single path that takes (lines per cell, widths, alignments). Add snapshot-like internal tests for each format with multiline.
   - Risk: HTML escaping/quoting for CSV.
     - Mitigation: Use stdlib: html.escape for html; implement small CSV quote routine without external deps.
   - Risk: Ordering of dict keys in union for list-of-dicts.
     - Mitigation: Preserve first-seen order deterministically (iterate rows, add unseen keys to list).
   - Risk: CLI parsing conflicts with tests importing cli.py.
     - Mitigation: Keep cli.py minimal, avoid side effects at import time; only run main under if __name__ == "__main__".
</plan>