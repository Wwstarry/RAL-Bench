<file:name=stegano/__init__.py>
"""
Pure-Python steganography library implementing a subset of the public API of
the reference "Stegano" project.

This package exposes the following submodules:
- stegano.lsb
- stegano.red
- stegano.exifHeader
- stegano.wav
"""
from __future__ import annotations

from . import lsb, red, exifHeader, wav  # re-export for "from stegano import ..."

__all__ = ["lsb", "red", "exifHeader", "wav"]
</file>

<file:name=stegano/lsb/__init__.py>
from __future__ import annotations

from .lsb import hide, reveal
from . import generators

__all__ = ["hide", "reveal", "generators"]
</file>

<file:name=stegano/lsb/generators.py>
from __future__ import annotations

from collections.abc import Iterator


def eratosthenes() -> Iterator[int]:
    """
    Infinite generator of prime numbers: 2, 3, 5, 7, ...

    Uses an incremental sieve (often called the "dictionary" sieve).
    """
    D: dict[int, list[int]] = {}
    q = 2
    while True:
        if q not in D:
            yield q
            D[q * q] = [q]
        else:
            for p in D[q]:
                D.setdefault(p + q, []).append(p)
            del D[q]
        q += 1
</file>

<file:name=stegano/lsb/lsb.py>
from __future__ import annotations

from collections.abc import Iterator
from typing import Optional, Union, Any

from PIL import Image

from stegano.tools.bititerator import bytes_to_bits, bits_to_bytes
from stegano.tools.utils import (
    ensure_image,
    frame_payload,
    parse_length_prefix_from_bits,
    validate_length_against_capacity_bytes,
)


def _embeddable_mode(img: Image.Image, auto_convert_rgb: bool) -> Image.Image:
    if img.mode in ("RGB", "RGBA"):
        return img
    if auto_convert_rgb:
        return img.convert("RGB")
    raise ValueError(f"Unsupported image mode {img.mode!r}. Use auto_convert_rgb=True to convert.")


def _capacity_bits(img: Image.Image) -> int:
    w, h = img.size
    if img.mode == "RGB":
        return w * h * 3
    if img.mode == "RGBA":
        # only RGB channels used
        return w * h * 3
    raise ValueError(f"Unsupported image mode for LSB: {img.mode!r}")


def _slot_to_xyc(img: Image.Image, slot: int) -> tuple[int, int, int]:
    """
    Map a slot index into (x, y, channel) where channel indexes RGB as 0,1,2.
    For both RGB and RGBA, slots are defined over RGB channels only.
    """
    w, h = img.size
    pixel_index = slot // 3
    channel = slot % 3
    if pixel_index < 0 or pixel_index >= w * h:
        raise ValueError("Slot out of bounds")
    x = pixel_index % w
    y = pixel_index // w
    return x, y, channel


def _iter_positions(capacity: int, generator: Optional[Iterator[int]], shift: int) -> Iterator[int]:
    if shift < 0:
        raise ValueError("shift must be >= 0")
    if generator is None:
        # sequential
        start = shift
        for pos in range(start, capacity):
            yield pos
        return

    # generator-based: advance by shift yields
    for _ in range(shift):
        next(generator)

    while True:
        pos = next(generator)
        if pos < 0:
            continue
        # ignore out of range positions; this matches a "sparse" generator behavior
        # but could lead to infinite loop if generator never yields in range.
        if pos >= capacity:
            continue
        yield pos


def hide(
    image: Union[str, Image.Image],
    message: str,
    generator: Optional[Iterator[int]] = None,
    shift: int = 0,
    encoding: str = "UTF-8",
    auto_convert_rgb: bool = False,
) -> Image.Image:
    img = ensure_image(image)
    img = _embeddable_mode(img, auto_convert_rgb)
    out = img.copy()

    payload = frame_payload(message.encode(encoding))
    bits = list(bytes_to_bits(payload))

    cap = _capacity_bits(out)
    if len(bits) > cap:
        raise ValueError("Message too large to hide in image (insufficient capacity).")

    px = out.load()
    pos_iter = _iter_positions(capacity=cap, generator=generator, shift=shift)

    for bit in bits:
        slot = next(pos_iter)
        x, y, c = _slot_to_xyc(out, slot)
        p = px[x, y]
        if out.mode == "RGB":
            r, g, b = p
            channels = [r, g, b]
            channels[c] = (channels[c] & 0xFE) | bit
            px[x, y] = tuple(channels)
        else:  # RGBA
            r, g, b, a = p
            channels = [r, g, b]
            channels[c] = (channels[c] & 0xFE) | bit
            px[x, y] = (channels[0], channels[1], channels[2], a)

    return out


def reveal(
    image: Union[str, Image.Image],
    generator: Optional[Iterator[int]] = None,
    shift: int = 0,
    encoding: str = "UTF-8",
) -> str:
    img = ensure_image(image)
    if img.mode not in ("RGB", "RGBA"):
        raise ValueError(f"Unsupported image mode {img.mode!r} for reveal().")

    cap_bits = _capacity_bits(img)
    px = img.load()
    pos_iter = _iter_positions(capacity=cap_bits, generator=generator, shift=shift)

    def bit_stream() -> Iterator[int]:
        while True:
            slot = next(pos_iter)
            x, y, c = _slot_to_xyc(img, slot)
            p = px[x, y]
            if img.mode == "RGB":
                bit = (p[c] & 1)
            else:
                bit = ([p[0], p[1], p[2]][c] & 1)
            yield bit

    bits_iter = bit_stream()
    length, length_bits_consumed = parse_length_prefix_from_bits(bits_iter)
    # remaining capacity bits:
    remaining_bits = cap_bits - length_bits_consumed
    validate_length_against_capacity_bytes(length, remaining_bits)

    payload_bits_needed = length * 8
    payload_bits = [next(bits_iter) for _ in range(payload_bits_needed)]
    payload = bits_to_bytes(payload_bits)
    return payload.decode(encoding)
</file>

<file:name=stegano/red/__init__.py>
from __future__ import annotations

from .red import hide, reveal

__all__ = ["hide", "reveal"]
</file>

<file:name=stegano/red/red.py>
from __future__ import annotations

from typing import Union

from PIL import Image

from stegano.tools.bititerator import bytes_to_bits, bits_to_bytes
from stegano.tools.utils import ensure_image, frame_payload, parse_length_prefix_from_bits, validate_length_against_capacity_bytes


def _ensure_rgb_or_rgba(img: Image.Image) -> Image.Image:
    if img.mode in ("RGB", "RGBA"):
        return img
    return img.convert("RGB")


def hide(image: Union[str, Image.Image], message: str) -> Image.Image:
    img = _ensure_rgb_or_rgba(ensure_image(image))
    out = img.copy()
    w, h = out.size

    payload = frame_payload(message.encode("UTF-8"))
    bits = list(bytes_to_bits(payload))
    capacity = w * h  # one bit per pixel (red channel)
    if len(bits) > capacity:
        raise ValueError("Message too large to hide in image (insufficient capacity).")

    px = out.load()
    i = 0
    for y in range(h):
        for x in range(w):
            if i >= len(bits):
                return out
            bit = bits[i]
            i += 1
            p = px[x, y]
            if out.mode == "RGB":
                r, g, b = p
                r = (r & 0xFE) | bit
                px[x, y] = (r, g, b)
            else:
                r, g, b, a = p
                r = (r & 0xFE) | bit
                px[x, y] = (r, g, b, a)
    return out


def reveal(image: Union[str, Image.Image]) -> str:
    img = _ensure_rgb_or_rgba(ensure_image(image))
    w, h = img.size
    px = img.load()

    def bits_iter():
        for y in range(h):
            for x in range(w):
                p = px[x, y]
                r = p[0]
                yield (r & 1)

    it = bits_iter()
    length, length_bits_consumed = parse_length_prefix_from_bits(it)
    remaining_bits = (w * h) - length_bits_consumed
    validate_length_against_capacity_bytes(length, remaining_bits)

    payload_bits = [next(it) for _ in range(length * 8)]
    payload = bits_to_bytes(payload_bits)
    return payload.decode("UTF-8")
</file>

<file:name=stegano/exifHeader/__init__.py>
from __future__ import annotations

from .exifHeader import hide, reveal

__all__ = ["hide", "reveal"]
</file>

<file:name=stegano/exifHeader/exifHeader.py>
from __future__ import annotations

from typing import Any, Union
from pathlib import Path

from PIL import Image

from stegano.tools.utils import ensure_image, uint32be_pack, uint32be_unpack

_USERCOMMENT_TAG = 37510  # EXIF UserComment
_MAGIC = b"STEGANO\x00"


def _normalize_bytes(value: Any) -> bytes:
    if value is None:
        return b""
    if isinstance(value, bytes):
        return value
    if isinstance(value, str):
        return value.encode("latin1", errors="ignore")
    # Pillow may return an Exif "IFDRational" etc; coerce
    try:
        return bytes(value)
    except Exception:
        return b""


def hide(input_image_file: Union[str, Path, Any], output_path: Union[str, Path], secret_message: bytes = b"", **kwargs: Any) -> None:
    """
    Embed secret_message bytes into EXIF UserComment. Writes output_path.
    Extra kwargs are accepted and ignored for compatibility.
    """
    if isinstance(secret_message, str):
        secret_message = secret_message.encode("UTF-8")

    img = Image.open(input_image_file)
    exif = img.getexif()
    payload = _MAGIC + uint32be_pack(len(secret_message)) + secret_message

    # Try bytes first; if Pillow rejects, fall back to latin1 string roundtrip.
    try:
        exif[_USERCOMMENT_TAG] = payload
        exif_bytes = exif.tobytes()
    except Exception:
        exif[_USERCOMMENT_TAG] = payload.decode("latin1", errors="ignore")
        exif_bytes = exif.tobytes()

    img.save(output_path, exif=exif_bytes)


def reveal(image: Union[str, Path, Image.Image, Any]) -> bytes:
    img = ensure_image(image) if isinstance(image, Image.Image) else Image.open(image)
    exif = img.getexif()
    raw = _normalize_bytes(exif.get(_USERCOMMENT_TAG))
    if not raw.startswith(_MAGIC):
        return b""
    if len(raw) < len(_MAGIC) + 4:
        return b""
    length = uint32be_unpack(raw[len(_MAGIC): len(_MAGIC) + 4])
    data = raw[len(_MAGIC) + 4:]
    if length > len(data):
        return b""
    return data[:length]
</file>

<file:name=stegano/wav/__init__.py>
from __future__ import annotations

from .wav import hide, reveal

__all__ = ["hide", "reveal"]
</file>

<file:name=stegano/wav/wav.py>
from __future__ import annotations

from typing import Any, Union
import wave
import struct
from pathlib import Path

from stegano.tools.bititerator import bytes_to_bits, bits_to_bytes
from stegano.tools.utils import frame_payload, parse_length_prefix_from_bits, validate_length_against_capacity_bytes


def _iter_sample_lsbs(frames: bytes, sampwidth: int) -> tuple[list[int], int]:
    """
    Return (samples, count) where samples are integers (already decoded) in
    interleaved channel order.
    """
    if sampwidth == 1:
        # unsigned bytes
        return list(frames), len(frames)
    if sampwidth == 2:
        count = len(frames) // 2
        samples = list(struct.unpack("<" + "h" * count, frames))
        return samples, count
    raise ValueError("Unsupported WAV sample width (only 8-bit or 16-bit PCM supported).")


def _pack_samples(samples: list[int], sampwidth: int) -> bytes:
    if sampwidth == 1:
        return bytes((s & 0xFF) for s in samples)
    if sampwidth == 2:
        return struct.pack("<" + "h" * len(samples), *samples)
    raise ValueError("Unsupported WAV sample width (only 8-bit or 16-bit PCM supported).")


def hide(input_file: Union[str, Path], message: str, output_file: Union[str, Path], **kwargs: Any) -> None:
    payload = frame_payload(message.encode("UTF-8"))
    bits = list(bytes_to_bits(payload))

    with wave.open(str(input_file), "rb") as r:
        params = r.getparams()
        frames = r.readframes(r.getnframes())

    sampwidth = params.sampwidth
    samples, n_samples = _iter_sample_lsbs(frames, sampwidth)

    capacity_bits = n_samples
    if len(bits) > capacity_bits:
        raise ValueError("Message too large to hide in WAV (insufficient capacity).")

    for i, bit in enumerate(bits):
        if sampwidth == 1:
            samples[i] = (samples[i] & 0xFE) | bit
        else:
            samples[i] = (samples[i] & ~1) | bit

    out_frames = _pack_samples(samples, sampwidth)
    with wave.open(str(output_file), "wb") as w:
        w.setparams(params)
        w.writeframes(out_frames)


def reveal(input_file: Union[str, Path], **kwargs: Any) -> str:
    with wave.open(str(input_file), "rb") as r:
        params = r.getparams()
        frames = r.readframes(r.getnframes())

    sampwidth = params.sampwidth
    samples, n_samples = _iter_sample_lsbs(frames, sampwidth)

    def bit_iter():
        for s in samples:
            yield (s & 1)

    it = bit_iter()
    length, length_bits_consumed = parse_length_prefix_from_bits(it)
    remaining_bits = n_samples - length_bits_consumed
    validate_length_against_capacity_bytes(length, remaining_bits)

    payload_bits = [next(it) for _ in range(length * 8)]
    payload = bits_to_bytes(payload_bits)
    return payload.decode("UTF-8")
</file>

<file:name=stegano/tools/__init__.py>
from __future__ import annotations

from .bititerator import bytes_to_bits, bits_to_bytes
from .utils import frame_payload, ensure_image

__all__ = [
    "bytes_to_bits",
    "bits_to_bytes",
    "frame_payload",
    "ensure_image",
]
</file>

<file:name=stegano/tools/bititerator.py>
from __future__ import annotations

from collections.abc import Iterable, Iterator


def bytes_to_bits(data: bytes) -> Iterator[int]:
    """Yield bits MSB-first for each byte."""
    for b in data:
        for i in range(7, -1, -1):
            yield (b >> i) & 1


def bits_to_bytes(bits: Iterable[int]) -> bytes:
    """Pack bits (MSB-first per byte) into bytes. Extra bits are ignored if not multiple of 8."""
    out = bytearray()
    acc = 0
    n = 0
    for bit in bits:
        acc = (acc << 1) | (1 if bit else 0)
        n += 1
        if n == 8:
            out.append(acc & 0xFF)
            acc = 0
            n = 0
    return bytes(out)
</file>

<file:name=stegano/tools/utils.py>
from __future__ import annotations

from typing import Any, Union, Tuple
from pathlib import Path
from PIL import Image


def uint32be_pack(n: int) -> bytes:
    if n < 0 or n > 0xFFFFFFFF:
        raise ValueError("uint32 out of range")
    return bytes(((n >> 24) & 0xFF, (n >> 16) & 0xFF, (n >> 8) & 0xFF, n & 0xFF))


def uint32be_unpack(b4: bytes) -> int:
    if len(b4) != 4:
        raise ValueError("Need exactly 4 bytes for uint32")
    return (b4[0] << 24) | (b4[1] << 16) | (b4[2] << 8) | b4[3]


def frame_payload(payload: bytes) -> bytes:
    """Length-prefix framing: 4-byte big-endian length + payload."""
    return uint32be_pack(len(payload)) + payload


def ensure_image(obj: Union[str, Path, Image.Image]) -> Image.Image:
    if isinstance(obj, Image.Image):
        return obj
    return Image.open(obj)


def parse_length_prefix_from_bits(bits_iter) -> tuple[int, int]:
    """
    Read a 4-byte big-endian length from a bit iterator.
    Returns (length, bits_consumed).
    """
    length_bits = [next(bits_iter) for _ in range(32)]
    # build bytes
    acc = 0
    out = bytearray()
    for i, bit in enumerate(length_bits, start=1):
        acc = (acc << 1) | (1 if bit else 0)
        if i % 8 == 0:
            out.append(acc & 0xFF)
            acc = 0
    length = uint32be_unpack(bytes(out))
    return length, 32


def validate_length_against_capacity_bytes(length: int, remaining_capacity_bits: int) -> None:
    if length < 0:
        raise ValueError("Invalid embedded length.")
    max_bytes = remaining_capacity_bits // 8
    if length > max_bytes:
        raise ValueError("Invalid embedded length (exceeds capacity). Possible wrong key/generator or corrupt data.")
</file>

<file:name=stegano/console/__init__.py>
from __future__ import annotations

__all__ = []
</file>

<file:name=stegano/console/main.py>
from __future__ import annotations

from typing import List, Optional


def main(argv: Optional[List[str]] = None) -> int:
    # Minimal stub for import-compatibility. Not a full CLI.
    return 0
</file>

<file:name=stegano/steganalysis/__init__.py>
from __future__ import annotations

# Import-compatibility stub package.
__all__ = []
</file>

<file:name=_agent_tests/test_agent_basic.py>
import os
import math
import wave
import struct
import pytest
from PIL import Image

from stegano import lsb, red, exifHeader, wav
from stegano.lsb.generators import eratosthenes


def test_imports():
    assert hasattr(lsb, "hide") and hasattr(lsb, "reveal")
    assert hasattr(red, "hide") and hasattr(red, "reveal")
    assert hasattr(exifHeader, "hide") and hasattr(exifHeader, "reveal")
    assert hasattr(wav, "hide") and hasattr(wav, "reveal")


def test_eratosthenes_primes():
    g = eratosthenes()
    primes = [next(g) for _ in range(10)]
    assert primes == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]


def test_lsb_roundtrip_sequential_rgb():
    img = Image.new("RGB", (64, 64), (120, 130, 140))
    out = lsb.hide(img, "hello world")
    assert out.size == img.size
    assert lsb.reveal(out) == "hello world"


def test_lsb_roundtrip_generator_and_shift():
    img = Image.new("RGB", (80, 80), (10, 20, 30))
    msg = "generator message"
    out = lsb.hide(img, msg, generator=eratosthenes(), shift=10)
    assert lsb.reveal(out, generator=eratosthenes(), shift=10) == msg
    with pytest.raises(Exception):
        # wrong shift should not successfully decode
        lsb.reveal(out, generator=eratosthenes(), shift=0)


def test_lsb_auto_convert_rgb_behavior():
    img_l = Image.new("L", (50, 50), 128)
    with pytest.raises(ValueError):
        lsb.hide(img_l, "x", auto_convert_rgb=False)
    out = lsb.hide(img_l, "x", auto_convert_rgb=True)
    assert out.mode == "RGB"
    assert out.size == img_l.size
    assert lsb.reveal(out) == "x"


def test_lsb_rgba_preserves_alpha():
    img = Image.new("RGBA", (40, 40), (1, 2, 3, 200))
    out = lsb.hide(img, "alpha", auto_convert_rgb=False)
    assert out.mode == "RGBA"
    assert out.getchannel("A").tobytes() == img.getchannel("A").tobytes()
    assert lsb.reveal(out) == "alpha"


def test_lsb_capacity_error():
    img = Image.new("RGB", (2, 2), (0, 0, 0))  # capacity 12 bits => 1 byte payload at most after length framing => impossible
    with pytest.raises(ValueError):
        lsb.hide(img, "hi")


def test_red_roundtrip_rgb_and_rgba_alpha_preserved():
    img = Image.new("RGB", (80, 80), (100, 150, 200))
    out = red.hide(img, "red secret")
    assert out.size == img.size
    assert red.reveal(out) == "red secret"

    img_a = Image.new("RGBA", (80, 80), (100, 150, 200, 77))
    out_a = red.hide(img_a, "rgba secret")
    assert out_a.getchannel("A").tobytes() == img_a.getchannel("A").tobytes()
    assert red.reveal(out_a) == "rgba secret"


def test_red_capacity_error():
    img = Image.new("RGB", (4, 4), (0, 0, 0))  # 16 bits, but framing alone is 32 bits
    with pytest.raises(ValueError):
        red.hide(img, "x")


def test_exif_hide_reveal_jpeg(tmp_path):
    # create a simple jpeg
    inp = tmp_path / "in.jpg"
    outp = tmp_path / "out.jpg"
    img = Image.new("RGB", (64, 64), (12, 34, 56))
    img.save(inp, "JPEG")

    exifHeader.hide(str(inp), str(outp), secret_message=b"abc")
    assert outp.exists()
    got = exifHeader.reveal(str(outp))
    assert got == b"abc"

    # no payload case
    blank = tmp_path / "blank.jpg"
    img.save(blank, "JPEG")
    assert exifHeader.reveal(str(blank)) == b""


def _make_wav(path, duration_s=0.25, sr=8000, freq=440.0):
    n = int(duration_s * sr)
    samples = []
    for i in range(n):
        t = i / sr
        v = int(20000 * math.sin(2 * math.pi * freq * t))
        samples.append(v)
    frames = struct.pack("<" + "h" * n, *samples)
    with wave.open(str(path), "wb") as w:
        w.setnchannels(1)
        w.setsampwidth(2)
        w.setframerate(sr)
        w.writeframes(frames)


def test_wav_hide_reveal_roundtrip(tmp_path):
    inp = tmp_path / "in.wav"
    outp = tmp_path / "out.wav"
    _make_wav(inp, duration_s=0.5)

    wav.hide(str(inp), "audio secret", str(outp))
    assert outp.exists()
    assert wav.reveal(str(outp)) == "audio secret"

    # parameters preserved
    with wave.open(str(inp), "rb") as r1, wave.open(str(outp), "rb") as r2:
        assert r1.getparams() == r2.getparams()


def test_wav_capacity_error(tmp_path):
    inp = tmp_path / "short.wav"
    outp = tmp_path / "out.wav"
    _make_wav(inp, duration_s=0.02, sr=8000)  # very short
    with pytest.raises(ValueError):
        wav.hide(str(inp), "this message is too long for the tiny audio", str(outp))
</file>