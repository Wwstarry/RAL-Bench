<file:name=jwt/__init__.py>
"""
Minimal pure-Python JWT implementation compatible with core PyJWT APIs
used by the accompanying tests.
"""

from .api_jwt import encode, decode
from .exceptions import (
    PyJWTError,
    DecodeError,
    InvalidSignatureError,
    ExpiredSignatureError,
)

__all__ = [
    "encode",
    "decode",
    "PyJWTError",
    "DecodeError",
    "InvalidSignatureError",
    "ExpiredSignatureError",
]
</file>

<file:name=jwt/exceptions.py>
class PyJWTError(Exception):
    """Base class for all JWT-related errors."""


class DecodeError(PyJWTError):
    """Raised when a token cannot be decoded or validated."""


class InvalidSignatureError(DecodeError):
    """Raised when signature verification fails."""


class ExpiredSignatureError(DecodeError):
    """Raised when a token has expired (exp claim)."""
</file>

<file:name=jwt/api_jwt.py>
import base64
import datetime as _dt
import hashlib
import hmac
import json
import time
from typing import Any, Dict, Optional, Tuple, Union

from .exceptions import DecodeError, ExpiredSignatureError, InvalidSignatureError


def _force_bytes(data: Union[str, bytes], *, what: str = "data") -> bytes:
    if isinstance(data, bytes):
        return data
    if isinstance(data, str):
        return data.encode("utf-8")
    raise DecodeError(f"Invalid type for {what}")


def _b64url_encode(raw: bytes) -> str:
    return base64.urlsafe_b64encode(raw).decode("ascii").rstrip("=")


def _b64url_decode(seg: Union[str, bytes], *, what: str = "segment") -> bytes:
    try:
        if isinstance(seg, bytes):
            seg_str = seg.decode("ascii")
        elif isinstance(seg, str):
            seg_str = seg
        else:
            raise TypeError("segment must be str or bytes")

        # Restore required padding to multiple of 4
        pad = (-len(seg_str)) % 4
        seg_str_padded = seg_str + ("=" * pad)
        return base64.urlsafe_b64decode(seg_str_padded.encode("ascii"))
    except Exception as e:
        raise DecodeError(f"Invalid base64url {what}") from e


def _json_dumps(obj: Any) -> str:
    # Deterministic output to reduce flakiness in black-box tests.
    return json.dumps(obj, separators=(",", ":"), sort_keys=True, ensure_ascii=False)


def _json_loads(data: Union[str, bytes], *, what: str = "json") -> Any:
    try:
        if isinstance(data, bytes):
            s = data.decode("utf-8")
        else:
            s = data
        return json.loads(s)
    except Exception as e:
        raise DecodeError(f"Invalid {what}") from e


def _sign_hs256(signing_input: bytes, key: Union[str, bytes]) -> bytes:
    key_b = _force_bytes(key, what="key")
    return hmac.new(key_b, signing_input, hashlib.sha256).digest()


def encode(payload: Dict[str, Any], key: Union[str, bytes], algorithm: str = "HS256", **kwargs) -> str:
    headers = kwargs.get("headers") or {}
    if headers is None:
        headers = {}
    if not isinstance(headers, dict):
        raise DecodeError("headers must be a dict")

    if algorithm != "HS256":
        # Minimal implementation: only HS256 supported.
        raise DecodeError("Algorithm not supported")

    if not isinstance(payload, dict):
        raise DecodeError("Payload must be a dict")

    header: Dict[str, Any] = {"typ": "JWT", "alg": algorithm}
    # User headers override defaults except 'alg' which must reflect the chosen algorithm.
    header.update(headers)
    header["alg"] = algorithm

    header_b64 = _b64url_encode(_json_dumps(header).encode("utf-8"))
    payload_b64 = _b64url_encode(_json_dumps(payload).encode("utf-8"))
    signing_input = (header_b64 + "." + payload_b64).encode("ascii")

    sig = _sign_hs256(signing_input, key)
    sig_b64 = _b64url_encode(sig)

    return header_b64 + "." + payload_b64 + "." + sig_b64


def _split_token(token: Union[str, bytes]) -> Tuple[str, str, str]:
    if isinstance(token, bytes):
        try:
            token_str = token.decode("utf-8")
        except Exception as e:
            raise DecodeError("Invalid token encoding") from e
    elif isinstance(token, str):
        token_str = token
    else:
        raise DecodeError("Invalid token type")

    parts = token_str.split(".")
    if len(parts) != 3:
        raise DecodeError("Not enough segments")
    return parts[0], parts[1], parts[2]


def _normalize_options(options: Optional[Dict[str, Any]]) -> Dict[str, Any]:
    if options is None:
        options = {}
    if not isinstance(options, dict):
        raise DecodeError("options must be a dict")
    return options


def _leeway_seconds(leeway: Union[int, float, _dt.timedelta]) -> float:
    if isinstance(leeway, _dt.timedelta):
        return float(leeway.total_seconds())
    try:
        return float(leeway)
    except Exception as e:
        raise DecodeError("Invalid leeway") from e


def _validate_exp(payload: Dict[str, Any], *, leeway: float, verify_exp: bool) -> None:
    if not verify_exp:
        return
    if "exp" not in payload:
        return

    exp = payload.get("exp")
    if isinstance(exp, (int, float)):
        exp_ts = float(exp)
    elif isinstance(exp, _dt.datetime):
        # Treat naive datetimes as system-local timestamp, matching Python's datetime.timestamp().
        exp_ts = float(exp.timestamp())
    else:
        raise DecodeError("Invalid exp claim")

    now = time.time()
    if now > exp_ts + leeway:
        raise ExpiredSignatureError("Signature has expired")


def decode(
    token: Union[str, bytes],
    key: Union[str, bytes, None],
    algorithms: Optional[list] = None,
    options: Optional[Dict[str, Any]] = None,
    leeway: Union[int, float, _dt.timedelta] = 0,
    **kwargs,
) -> Dict[str, Any]:
    # kwargs accepted for API-compatibility (audience, issuer, etc.) but unused here.
    options_n = _normalize_options(options)
    verify_signature = options_n.get("verify_signature", True)
    verify_exp = options_n.get("verify_exp", True)

    header_seg, payload_seg, sig_seg = _split_token(token)

    header_raw = _b64url_decode(header_seg, what="header")
    payload_raw = _b64url_decode(payload_seg, what="payload")
    sig_raw = _b64url_decode(sig_seg, what="signature")

    header = _json_loads(header_raw, what="header")
    payload = _json_loads(payload_raw, what="payload")

    if not isinstance(header, dict) or not isinstance(payload, dict):
        raise DecodeError("Invalid token content")

    alg = header.get("alg")
    if not alg or not isinstance(alg, str):
        raise DecodeError("Missing or invalid alg")

    if verify_signature:
        if key is None:
            raise DecodeError("Key required for verification")

        if not algorithms:
            # Requirement: decoding without specifying algorithms when verification is expected.
            raise DecodeError("algorithms must be specified when verifying")

        if alg not in algorithms:
            raise DecodeError("The specified alg value is not allowed")

        if alg != "HS256":
            raise DecodeError("Algorithm not supported")

        signing_input = (header_seg + "." + payload_seg).encode("ascii")
        expected_sig = _sign_hs256(signing_input, key)
        if not hmac.compare_digest(expected_sig, sig_raw):
            raise InvalidSignatureError("Signature verification failed")

    leeway_s = _leeway_seconds(leeway)
    _validate_exp(payload, leeway=leeway_s, verify_exp=verify_exp)

    return payload
</file>

<file:name=_agent_tests/test_agent_basic.py>
import time
import datetime as dt
import pytest

import jwt


def test_roundtrip_hs256():
    payload = {"a": 1, "b": "x"}
    token = jwt.encode(payload, "secret", algorithm="HS256")
    out = jwt.decode(token, "secret", algorithms=["HS256"])
    assert out == payload


def test_wrong_key_raises_invalid_signature():
    token = jwt.encode({"a": 1}, "secret", algorithm="HS256")
    with pytest.raises(jwt.InvalidSignatureError):
        jwt.decode(token, "wrong", algorithms=["HS256"])


def test_missing_algorithms_when_verifying_raises_decode_error():
    token = jwt.encode({"a": 1}, "secret", algorithm="HS256")
    with pytest.raises(jwt.DecodeError):
        jwt.decode(token, "secret", algorithms=None)
    with pytest.raises(jwt.DecodeError):
        jwt.decode(token, "secret", algorithms=[])


def test_no_algorithms_needed_when_verify_signature_false():
    token = jwt.encode({"a": 1}, "secret", algorithm="HS256")
    out = jwt.decode(token, None, algorithms=None, options={"verify_signature": False})
    assert out["a"] == 1


def test_expired_raises_and_leeway_allows():
    now = int(time.time())
    token = jwt.encode({"sub": "u", "exp": now - 5}, "secret", algorithm="HS256")

    with pytest.raises(jwt.ExpiredSignatureError):
        jwt.decode(token, "secret", algorithms=["HS256"])

    out = jwt.decode(token, "secret", algorithms=["HS256"], leeway=10)
    assert out["sub"] == "u"


def test_verify_exp_can_be_disabled():
    now = int(time.time())
    token = jwt.encode({"exp": now - 100, "a": 1}, "secret", algorithm="HS256")
    out = jwt.decode(token, "secret", algorithms=["HS256"], options={"verify_exp": False})
    assert out["a"] == 1


def test_bad_token_segments_raise_decode_error():
    with pytest.raises(jwt.DecodeError):
        jwt.decode("a.b", "secret", algorithms=["HS256"])


def test_datetime_exp_supported():
    exp = dt.datetime.fromtimestamp(time.time() + 60)
    token = jwt.encode({"exp": exp, "a": 1}, "secret", algorithm="HS256")
    out = jwt.decode(token, "secret", algorithms=["HS256"])
    assert out["a"] == 1
</file>