<plan>
1) Repository layout and import graph
   - markdown/
     - __init__.py
       - Expose public API: markdown(), markdownFromFile(), Markdown
       - Import from markdown.core: Markdown, markdown, markdownFromFile
       - Define __all__ = ["Markdown", "markdown", "markdownFromFile"]
     - core.py
       - Implement Markdown engine and the two convenience functions.
       - No external deps; pure Python.
     - extensions/
       - __init__.py
         - Provide minimal extension-loading surface so tests importing extensions don’t fail.
         - For core-compat: define Extension base class (light stub) and a helper to load extensions by string (can be no-op for unsupported ones unless tests require something).
   - Import graph
     - import markdown  -> markdown/__init__.py -> imports markdown.core
     - markdown.core imports only stdlib: re, io, os, pathlib, html (escape), dataclasses (optional)

2) Public APIs to implement (modules/classes/functions)
   A) markdown/__init__.py
      - from .core import Markdown, markdown, markdownFromFile
      - __version__ (optional; set a plausible string to avoid attribute errors in tests)
      - __all__ as above

   B) markdown/core.py
      - class Markdown:
          - __init__(self, **kwargs)
            - Accept (at least) common kwargs used by tests:
              * extensions=None (ignored or minimally handled)
              * output_format="xhtml" or "html" (we can always output html; keep attribute)
              * tab_length=4
              * enable_attributes / safe_mode (likely not needed; accept and ignore)
              * any unknown kwargs stored but ignored to avoid TypeError
            - Initialize per-instance state; call reset().
          - reset(self):
            - Clear any per-document state (e.g., reference link definitions if later added).
            - Return self (matches common semantics).
          - convert(self, text: str) -> str:
            - Main entry: takes Unicode str, returns Unicode HTML str.
            - Must not print.
            - Pipeline:
              1) Normalize newlines (\r\n, \r -> \n).
              2) Tokenize and parse block structure into HTML lines.
              3) Inline-process non-code text (escape + emphasis/links/etc).
              4) Join with \n (stable whitespace; tests ignore insignificant diffs).
        - def markdown(text: str, **kwargs) -> str:
            - Create Markdown(**kwargs) and return md.convert(text)
        - def markdownFromFile(input=None, output=None, encoding=None, **kwargs):
            - API-compatible shape with Python-Markdown core:
              * input: filename or file-like (if tests pass file object)
              * output: filename or file-like or None (if None, return string)
              * encoding: if None default to "utf-8"
            - Behavior:
              * read markdown text from input (path or stream)
              * convert via markdown(text, **kwargs)
              * if output provided: write html to it and return None (or written html if tests expect; reference returns None when writing to a file, otherwise returns html)
              * if output is None: return html string

   C) markdown/extensions/__init__.py
      - class Extension:
          - extendMarkdown(self, md): placeholder
      - def load_extensions(extensions, configs=None):
          - Return list of instantiated extensions; if given strings, ignore unknown safely.
          - Keep minimal to satisfy import/attribute usage in tests (even if core ignores).

3) Key behaviors & edge cases
   Overall approach: a small block parser with an inline parser. Preserve raw text in code contexts; escape elsewhere. Aim to match Python-Markdown output for features covered by tests, ignoring insignificant whitespace.

   A) Block parsing (core)
      - Split into lines; iterate with index.
      - Maintain an output list and a stack for open blocks:
        * blockquote nesting level (count of leading '>' markers)
        * list stack (ordered/unordered; with current indent)
      - Recognize blocks in precedence order similar to Markdown:
        1) Fenced code blocks: lines starting with ``` or ~~~ (common); capture until matching fence.
           - Output: <pre><code>...escaped raw...</code></pre>
           - Inside code block: do NOT run inline processing; escape HTML special chars (&, <, >) but keep quotes as-is (like typical behavior).
           - Preserve internal newlines; ensure trailing newline inside code is handled similarly (tests typically accept both; be consistent: end content with \n if source ended with newline).
        2) Indented code blocks: line indented >= tab_length spaces (default 4) and not in list item context unless tests require; simpler: if line starts with 4 spaces or a tab, treat as code block until blank line followed by non-indented.
           - Strip one indent level (4 spaces or 1 tab) from each code line.
           - Output same as fenced.
        3) ATX headings: ^(#{1,6})\s+(.*?)(\s+#+\s*)?$
           - Inline-process heading text (escape + emphasis/links/etc).
           - Output: <hN>...</hN>
        4) Blockquotes: lines starting with optional spaces then '>' and optional space.
           - Collect contiguous blockquote lines; strip leading '>' markers.
           - Recursively parse inner content as blocks, then wrap in <blockquote> ... </blockquote>.
           - Important: blank quote lines should create paragraph breaks inside.
        5) Lists:
           - Unordered: ^\s*([-+*])\s+(.*)$
           - Ordered: ^\s*(\d+)\.\s+(.*)$
           - For minimal tests, support single-level lists and simple nested via indentation:
             * Determine indent of marker; items continue while next lines are indented more than marker indent or are blank followed by indented.
             * Wrap: <ul> / <ol>, items as <li> ... </li>
             * If item contains multiple paragraphs or nested blocks, include them inside <li> as block HTML; else inline-process and keep as plain text within <li>.
        6) Paragraphs:
           - Any run of non-blank lines not captured by above becomes a paragraph.
           - Join lines with \n or space? Python-Markdown collapses soft line breaks inside paragraphs into newlines in source but rendered as newline in HTML output text nodes; tests usually accept either. Safer: join with '\n' then inline-process, leaving newlines (HTML collapses whitespace anyway).
           - Output: <p>...</p>
      - Blank lines separate paragraphs and can terminate lists/code blocks depending on next context.

   B) Inline parsing
      Goals: match common Markdown for emphasis/strong, code spans, links, images; escape HTML-sensitive chars in normal text.

      - Strategy:
        1) Extract code spans first:
           - Pattern: `code` (single backtick) and allow multiple backticks as delimiters minimally.
           - Replace with placeholders tokens (e.g., \x00CODE0\x00) storing raw content.
           - For code span content: strip one leading/trailing space if both present (common rule); then HTML-escape &, <, >; wrap later as <code>...</code>.
        2) Escape the remaining text for HTML (&, <, >) using html.escape(text, quote=False).
           - This ensures raw < and & are not interpreted as HTML.
        3) Process images:
           - Pattern: !\[alt\]\(url\)
           - Escape alt text already escaped; URL should be attribute-escaped:
             * Replace & with &amp;, " with &quot;, < with &lt;, > with &gt; (use html.escape(url, quote=True)).
           - Output: <img alt="ALT" src="URL" />
             * Python-Markdown defaults to XHTML-style self-closing depending on output_format. For tests, accept either; but to be safe, emit <img alt="..." src="..." /> when output_format contains 'xhtml', else <img alt="..." src="...">.
        4) Process links:
           - Pattern: \[text\]\(url\)
           - Text: already escaped, but still needs emphasis parsing inside; to keep simple and close to reference, run emphasis parsing on link text before wrapping.
           - URL attribute-escaped as above.
           - Output: <a href="URL">TEXT</a>
        5) Process strong/emphasis:
           - Implement a small, deterministic parser rather than naive regex to avoid common pitfalls, but keep minimal:
             * Strong: **text** or __text__
             * Emphasis: *text* or _text_
           - Order: handle strong first, then emphasis.
           - Do not cross code placeholders.
           - Avoid matching intraword underscores in simple cases if tests cover it; basic rule: require surrounding delimiter not alphanumeric on both sides for underscore emphasis (Python-Markdown has nuanced rules). Minimal mitigation:
             * For '_' and '__', only treat as delimiter if character before is whitespace/punctuation or start, and char after is not whitespace; similarly ensure closing delimiter preceded by not whitespace and followed by whitespace/punctuation/end.
             * For '*' allow more freely.
        6) Restore code span placeholders to <code>...</code> (already escaped).
      - Do not allow raw HTML tags to pass through unescaped in normal text; since we escape < and &, tags become literal.

   C) Escaping rules
      - Outside code: escape &, <, > always.
      - Inside inline code and code blocks: also escape &, <, > (so code displays literally).
      - In attributes (href/src): escape with quote=True.

   D) Markdown instance semantics
      - Markdown.convert should not permanently mutate behavior; allow multiple conversions by either new instance or reset().
      - reset() clears stored state; even if we don’t implement references, tests may call it, so it must exist and be safe.
      - Markdown.__init__ should call reset().

   E) markdownFromFile behavior details
      - Accept:
        * input: path string / PathLike / file-like; if None, raise or default to sys.stdin is NOT desired here—avoid stdin unless tests demand; implement explicit error if input is None.
        * output: path string / PathLike / file-like / None
      - If output is a path: open and write with encoding (default utf-8).
      - If output is file-like: write string.
      - Return value:
        * If output is None: return html string
        * Else: return None

4) Minimal internal test plan (what to test and why)
   - API surface
     - import markdown; assert hasattr(markdown, "markdown"), "markdownFromFile", "Markdown"
     - markdown.markdown returns str for str input; no prints.
     - Markdown().convert same as markdown.markdown for same input.
     - Markdown().reset returns self and doesn’t break subsequent convert.
   - Headings
     - "# Title" -> <h1>Title</h1>
     - "### T ###" trims closing hashes.
   - Paragraphs / blank lines
     - "a\n\nb" -> <p>a</p>\n<p>b</p>
   - Emphasis/strong
     - "*a*" -> <p><em>a</em></p>
     - "**a**" -> <p><strong>a</strong></p>
     - "__a__" strong; "_a_" em; mixed nesting if needed.
   - Inline code and escaping
     - "`<x & y>`" -> <p><code>&lt;x &amp; y&gt;</code></p>
     - "a < b" -> escapes to &lt;
   - Code blocks
     - Fenced:
       - "```\n<x>\n```" -> <pre><code>&lt;x&gt;\n</code></pre> (ensure newline handling consistent)
     - Indented:
       - "    <x>" -> same.
   - Lists
     - "- a\n- b" -> <ul><li>a</li><li>b</li></ul>
     - "1. a\n2. b" -> <ol>...
     - Simple continuation lines in an item (indented).
   - Blockquotes
     - "> a\n>\n> b" -> <blockquote><p>a</p><p>b</p></blockquote>
   - Links and images
     - "[t](u)" -> <a href="u">t</a>
     - "![a](u)" -> img with alt/src.
     - Ensure URL escaping for & and ".
   - markdownFromFile
     - Create temp file with markdown; call markdownFromFile(input=path) returns correct html.
     - With output path: writes file and returns None.

5) Risks (dependencies, tricky behaviors) and mitigations
   - Emphasis parsing edge cases (underscores in words, nested delimiters) can differ from Python-Markdown.
     - Mitigation: implement delimiter boundary checks for '_' and '__'; keep conservative to avoid false positives; add targeted tests mirroring suite failures if they appear.
   - List parsing complexity (multi-paragraph list items, nested lists, interaction with blockquotes/code).
     - Mitigation: implement a simple indentation-aware list item collector; within each <li>, run recursive block parsing on the item’s sub-block text when it contains blank lines or indented sub-blocks. Keep recursion limited and deterministic.
   - Code block newline fidelity and whitespace normalization can cause snapshot mismatches.
     - Mitigation: normalize input newlines; for code blocks, preserve internal newlines exactly; choose a consistent rule (include trailing newline if present between fences/indent block). Tests usually ignore insignificant whitespace; ensure no extra spaces within tags.
   - Output format differences (XHTML vs HTML) especially for <img /> and possibly <br>.
     - Mitigation: honor output_format kwarg minimally for img closing; otherwise output stable HTML. If tests check exact string, adjust to match reference defaults (Python-Markdown default output_format is "xhtml1"). Default to XHTML-style self-closing for img.
   - Extension loading expectations (tests may import markdown.extensions.* or call Markdown(extensions=[...])).
     - Mitigation: accept extensions kwarg; implement markdown.extensions.__init__ with Extension stub and a loader that doesn’t crash; in core, store extensions but no-op apply. If tests need specific built-in extension behavior, implement only those required once failures identify them.
   - markdownFromFile signature/behavior mismatch.
     - Mitigation: implement permissive signature (input=None, output=None, encoding=None, **kwargs) and support both filenames and file-like objects; avoid stdin/stdout unless explicitly requested by tests; return html when output is None, else None.
</plan>