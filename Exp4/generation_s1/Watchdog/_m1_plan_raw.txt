<plan>
1) Repository layout and import graph
   - Required package tree:
     - watchdog/__init__.py
       - Expose high-level imports expected by tests (Observer, event classes, handler).
     - watchdog/events.py
       - Define event model and FileSystemEventHandler.
     - watchdog/observers/__init__.py
       - Re-export Observer from watchdog.observers.api.
     - watchdog/observers/api.py
       - Implement Observer and internal polling emitter/threading.
   - Import graph:
     - watchdog/__init__.py imports from watchdog.events and watchdog.observers
     - watchdog/observers/__init__.py imports Observer from watchdog.observers.api
     - watchdog/observers/api.py imports event classes + handler base from watchdog.events

2) Public APIs to implement (modules/classes/functions)
   - watchdog/events.py
     - Event classes (API-compatible core subset):
       - class FileSystemEvent:
         - attributes: src_path (str), event_type (str), is_directory (bool)
       - class FileCreatedEvent(FileSystemEvent) with event_type="created"
       - class FileModifiedEvent(FileSystemEvent) with event_type="modified"
       - class FileDeletedEvent(FileSystemEvent) with event_type="deleted"
       - (Optionally, for completeness if tests reference them: DirCreatedEvent/DirModifiedEvent/DirDeletedEvent; but core focus is file events.)
     - class FileSystemEventHandler:
       - dispatch(event): calls on_any_event then on_created/on_modified/on_deleted based on event.event_type
       - on_any_event(self, event): default no-op
       - on_created(self, event): default no-op
       - on_modified(self, event): default no-op
       - on_deleted(self, event): default no-op
   - watchdog/observers/api.py
     - class Observer:
       - schedule(event_handler, path, recursive=False): register a watch; returns a lightweight “Watch” object if useful, but tests may ignore return. Must accept path str and recursive bool.
       - start(): start background monitoring thread(s)
       - stop(): request stop
       - join(timeout=None): wait for threads to finish
       - Behavior: dispatch created/modified/deleted events to the scheduled handler(s) matching the path, including recursion handling.
     - Internal (not required to be public but needed):
       - class _Watch: stores handler, path (absolute), recursive
       - class _PollingEmitter(threading.Thread):
         - polls filesystem snapshots periodically and produces events
       - Optional helper functions:
         - _scan_tree(root, recursive) -> dict[path] = (mtime_ns, size, is_dir)
         - _scan_nonrecursive(root) -> same but only direct children (and root itself optionally)
   - watchdog/__init__.py
     - Define __all__ and re-export:
       - from watchdog.observers import Observer
       - from watchdog.events import FileSystemEventHandler and event classes
     - Provide __version__ placeholder if tests read it (safe default).
   - watchdog/observers/__init__.py
     - from .api import Observer
     - __all__ = ["Observer"]

3) Key behaviors & edge cases
   - Monitoring mechanism (pure Python, no OS-specific backends):
     - Use polling with periodic directory scans, computing diffs between successive snapshots.
     - Default polling interval: small (e.g., 0.05–0.2s) to satisfy timing-based tests without excessive CPU; allow override via Observer constructor if desired, but keep a sensible default.
   - Event detection logic:
     - Created: path exists in new snapshot but not old snapshot.
     - Deleted: path exists in old snapshot but not new snapshot.
     - Modified: path exists in both, and (mtime_ns changed OR size changed). Use os.stat().st_mtime_ns when available; fallback to st_mtime * 1e9.
   - File vs directory:
     - Tests requested “created, modified and deleted files” specifically, but directories might appear during recursion.
     - Mark event.is_directory based on stat result (or known deletion of a directory). If tests only care about files, ensure file events are generated at least for files; directory events can be omitted unless referenced.
   - Recursive vs non-recursive:
     - If recursive=False, only watch immediate children of the watched directory (and not deeper descendants).
     - If recursive=True, include all descendants; when new subdirectories are created, ensure their contained files are picked up in subsequent scans.
   - Scheduling semantics:
     - schedule(handler, path, recursive):
       - Normalize path to absolute, expanded user, resolved if possible.
       - Support scheduling before start() (store watches; emitter reads them once running).
       - Support scheduling after start() (thread-safe: lock around watch list; emitter uses snapshot per watch).
     - Multiple watches:
       - If multiple handlers watch overlapping paths, dispatch to all matching watches (or at least those scheduled). Matching rule:
         - event.src_path is under watch.path (same directory prefix with path separator boundary), and:
           - recursive watch: any descendant
           - non-recursive watch: direct child only (dirname(event)==watch.path) or event path equals watch path (if file watch is allowed). Tests likely use directory watch.
   - Dispatch ordering and thread-safety:
     - Dispatch events from background thread; handler methods called in that thread.
     - Keep dispatch simple and deterministic: for each polling tick, compute events and dispatch in stable sorted path order (helps flaky tests).
   - Start/stop/join behavior:
     - start(): idempotent-ish; second call no-op or raise RuntimeError; choose no-op for robustness.
     - stop(): set stop flag; thread exits promptly.
     - join(): waits for thread termination.
     - Ensure stop() can be called even if never started.
   - Path encoding and normalization:
     - Use os.path.normpath and os.path.abspath.
     - Ensure event.src_path is a string path exactly as OS returns; consistent absolute paths avoid mismatches in tests.
   - Handling transient file operations:
     - Creation followed quickly by modification: may emit created then modified in later tick; acceptable.
     - Atomic replace (write temp then rename over): might appear as created+deleted; tests likely accept basic created/modified/deleted on target; mitigate by treating size/mtime change as modified when file persists.
   - Avoid missing events:
     - Initial baseline snapshot should be taken at watch start (or at schedule time). Do not emit “created” for pre-existing files when starting; baseline prevents that.
   - Error handling:
     - If watched directory disappears: treat all previously seen entries as deleted and continue (or stop emitting for that watch until it reappears).
     - Permission errors: ignore that subtree/file for that tick; do not crash emitter thread.
   - Performance:
     - For recursive watches, scanning entire tree each tick can be heavy; but tests are small. Keep code simple.

4) Minimal internal test plan (what to test and why)
   - API/import tests:
     - Import watchdog, watchdog.observers, watchdog.events.
     - from watchdog.observers import Observer; from watchdog.events import FileSystemEventHandler, FileCreatedEvent, FileModifiedEvent, FileDeletedEvent.
   - Basic non-recursive watch:
     - Create temp dir; schedule handler with recursive=False.
     - Create file in root -> expect on_created for that file.
     - Modify file -> expect on_modified.
     - Delete file -> expect on_deleted.
     - Create subdir and file inside subdir -> should NOT trigger when recursive=False.
   - Recursive watch:
     - Same setup with recursive=True.
     - Create subdir and file inside -> expect created for nested file.
     - Modify and delete nested file -> expect modified/deleted.
   - No initial events:
     - Create file before starting observer; schedule then start; ensure no created event for pre-existing file (baseline snapshot).
   - Stop semantics:
     - Start observer, then stop/join; after stop, create file; ensure no further events.
   - Multiple watches:
     - Two handlers on same dir; ensure both receive event.
     - One watch on parent recursive=True and another on child non-recursive; ensure matching logic dispatches appropriately.

5) Risks (dependencies, tricky behaviors) and mitigations
   - Risk: Polling interval too slow causing flaky timing in black-box tests.
     - Mitigation: default interval ~0.05–0.1s; keep scan fast; dispatch promptly; allow quick shutdown.
   - Risk: Modification detection using only mtime might miss rapid edits within same timestamp resolution.
     - Mitigation: use st_mtime_ns when available and also compare size; optionally compare inode/ctime where available.
   - Risk: Overlapping watches and path matching bugs (prefix collisions like /tmp/a vs /tmp/ab).
     - Mitigation: use realpath/abspath normalization and strict boundary checks (commonpath-based or prefix with separator).
   - Risk: Baseline snapshot race (file created between schedule and first scan).
     - Mitigation: take baseline snapshot as close as possible to start; accept that some tests may tolerate occasional extra created; additionally, on start, take snapshot immediately before entering polling loop.
   - Risk: Exceptions in handler methods killing emitter thread.
     - Mitigation: wrap handler dispatch in try/except and continue; optionally store last exception for debugging but don’t crash.
   - Risk: Filesystem traversal errors (permission denied, file disappears mid-stat).
     - Mitigation: handle OSError/FileNotFoundError during scan; skip problematic entries for that tick.
</plan>