<file:name=watchdog/__init__.py>
"""
Pure-Python minimal subset of the watchdog package.

This implementation is intended to be API-compatible with the core parts used by
tests that expect the reference watchdog project's basic interfaces.
"""

from .events import (
    FileSystemEvent,
    FileCreatedEvent,
    FileModifiedEvent,
    FileDeletedEvent,
    DirCreatedEvent,
    DirModifiedEvent,
    DirDeletedEvent,
    FileSystemEventHandler,
)
from .observers import Observer

__all__ = [
    "Observer",
    "FileSystemEventHandler",
    "FileSystemEvent",
    "FileCreatedEvent",
    "FileModifiedEvent",
    "FileDeletedEvent",
    "DirCreatedEvent",
    "DirModifiedEvent",
    "DirDeletedEvent",
]

__version__ = "0.0.0"
</file>

<file:name=watchdog/events.py>
from __future__ import annotations


class FileSystemEvent:
    """
    Minimal event model compatible with the subset commonly used in watchdog.

    Attributes:
      - src_path: str
      - event_type: "created" | "modified" | "deleted"
      - is_directory: bool
    """

    def __init__(self, src_path: str, event_type: str, is_directory: bool = False):
        self.src_path = src_path
        self.event_type = event_type
        self.is_directory = bool(is_directory)

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} src_path={self.src_path!r} event_type={self.event_type!r} is_directory={self.is_directory!r}>"


class FileCreatedEvent(FileSystemEvent):
    def __init__(self, src_path: str, is_directory: bool = False):
        super().__init__(src_path=src_path, event_type="created", is_directory=is_directory)


class FileModifiedEvent(FileSystemEvent):
    def __init__(self, src_path: str, is_directory: bool = False):
        super().__init__(src_path=src_path, event_type="modified", is_directory=is_directory)


class FileDeletedEvent(FileSystemEvent):
    def __init__(self, src_path: str, is_directory: bool = False):
        super().__init__(src_path=src_path, event_type="deleted", is_directory=is_directory)


# Optional directory events (some tests might reference these names)
class DirCreatedEvent(FileCreatedEvent):
    def __init__(self, src_path: str):
        super().__init__(src_path=src_path, is_directory=True)


class DirModifiedEvent(FileModifiedEvent):
    def __init__(self, src_path: str):
        super().__init__(src_path=src_path, is_directory=True)


class DirDeletedEvent(FileDeletedEvent):
    def __init__(self, src_path: str):
        super().__init__(src_path=src_path, is_directory=True)


class FileSystemEventHandler:
    """
    Minimal handler API. Users can override callbacks.

    dispatch(event) calls:
      - on_any_event(event)
      - on_created/on_modified/on_deleted depending on event.event_type
    """

    def dispatch(self, event: FileSystemEvent) -> None:
        self.on_any_event(event)
        et = getattr(event, "event_type", None)
        if et == "created":
            self.on_created(event)
        elif et == "modified":
            self.on_modified(event)
        elif et == "deleted":
            self.on_deleted(event)

    def on_any_event(self, event: FileSystemEvent) -> None:
        pass

    def on_created(self, event: FileSystemEvent) -> None:
        pass

    def on_modified(self, event: FileSystemEvent) -> None:
        pass

    def on_deleted(self, event: FileSystemEvent) -> None:
        pass
</file>

<file:name=watchdog/observers/__init__.py>
from .api import Observer

__all__ = ["Observer"]
</file>

<file:name=watchdog/observers/api.py>
from __future__ import annotations

import os
import threading
import time
from dataclasses import dataclass
from typing import Dict, Iterable, List, Optional, Tuple

from watchdog.events import (
    FileCreatedEvent,
    FileDeletedEvent,
    FileModifiedEvent,
    DirCreatedEvent,
    DirDeletedEvent,
    DirModifiedEvent,
    FileSystemEvent,
    FileSystemEventHandler,
)


def _abspath(path: str) -> str:
    # Keep normalization simple and stable for tests.
    return os.path.abspath(os.path.normpath(os.path.expanduser(path)))


def _is_under(child: str, parent: str) -> bool:
    # Strict boundary check to avoid prefix collisions (/a vs /ab).
    try:
        child_abs = _abspath(child)
        parent_abs = _abspath(parent)
        common = os.path.commonpath([child_abs, parent_abs])
        return common == parent_abs
    except Exception:
        # Fallback to string prefix with separator boundary.
        child_abs = _abspath(child)
        parent_abs = _abspath(parent)
        if child_abs == parent_abs:
            return True
        parent_slash = parent_abs if parent_abs.endswith(os.sep) else parent_abs + os.sep
        return child_abs.startswith(parent_slash)


def _direct_child_of(child: str, parent: str) -> bool:
    child_abs = _abspath(child)
    parent_abs = _abspath(parent)
    if child_abs == parent_abs:
        return True
    if os.path.dirname(child_abs) != parent_abs:
        return False
    return True


def _safe_stat(path: str):
    try:
        return os.stat(path, follow_symlinks=False)
    except (FileNotFoundError, PermissionError, NotADirectoryError, OSError):
        return None


def _sig_from_stat(st) -> Tuple[int, int, int, bool]:
    """
    Signature for change detection.
    Returns (mtime_ns, size, ino, is_dir).
    """
    try:
        mtime_ns = getattr(st, "st_mtime_ns", int(st.st_mtime * 1_000_000_000))
    except Exception:
        mtime_ns = 0
    try:
        size = int(st.st_size)
    except Exception:
        size = 0
    try:
        ino = int(getattr(st, "st_ino", 0))
    except Exception:
        ino = 0
    try:
        is_dir = os.stat.S_ISDIR(st.st_mode) if hasattr(os, "stat") else False
    except Exception:
        is_dir = False
    # os.stat.S_ISDIR isn't available; use stat module.
    import stat as _stat

    is_dir = _stat.S_ISDIR(st.st_mode)
    return (mtime_ns, size, ino, is_dir)


def _iter_entries(root: str, recursive: bool) -> Iterable[str]:
    """
    Yields absolute paths to entries under root.
    Includes root itself if it exists.
    """
    root_abs = _abspath(root)
    yield root_abs
    if not os.path.isdir(root_abs):
        return
    if not recursive:
        try:
            with os.scandir(root_abs) as it:
                for entry in it:
                    yield entry.path
        except (FileNotFoundError, PermissionError, NotADirectoryError, OSError):
            return
    else:
        # os.walk is robust enough for tests; ignore errors.
        for dirpath, dirnames, filenames in os.walk(root_abs, topdown=True, onerror=lambda e: None, followlinks=False):
            # Include directories (as entries) and files
            for d in dirnames:
                yield os.path.join(dirpath, d)
            for f in filenames:
                yield os.path.join(dirpath, f)


def _scan_snapshot(root: str, recursive: bool) -> Dict[str, Tuple[int, int, int, bool]]:
    snap: Dict[str, Tuple[int, int, int, bool]] = {}
    for p in _iter_entries(root, recursive):
        st = _safe_stat(p)
        if st is None:
            continue
        try:
            sig = _sig_from_stat(st)
        except Exception:
            continue
        snap[_abspath(p)] = sig
    return snap


@dataclass(frozen=True)
class _Watch:
    handler: FileSystemEventHandler
    path: str
    recursive: bool


class _PollingEmitter(threading.Thread):
    def __init__(self, observer: "Observer", interval: float):
        super().__init__(name="watchdog-polling-emitter", daemon=True)
        self._observer = observer
        self._interval = float(interval)
        self._stopped = threading.Event()
        self._baseline_taken = False
        self._snapshots: Dict[_Watch, Dict[str, Tuple[int, int, int, bool]]] = {}

    def stop(self) -> None:
        self._stopped.set()

    def _event_for(self, etype: str, path: str, is_dir: bool) -> FileSystemEvent:
        if is_dir:
            if etype == "created":
                return DirCreatedEvent(path)
            if etype == "modified":
                return DirModifiedEvent(path)
            if etype == "deleted":
                return DirDeletedEvent(path)
        else:
            if etype == "created":
                return FileCreatedEvent(path, is_directory=False)
            if etype == "modified":
                return FileModifiedEvent(path, is_directory=False)
            if etype == "deleted":
                return FileDeletedEvent(path, is_directory=False)
        return FileSystemEvent(path, etype, is_directory=is_dir)

    def _dispatch(self, watch: _Watch, event: FileSystemEvent) -> None:
        # Filter by recursion rules (even though scans are done per watch, keep extra guard).
        try:
            if watch.recursive:
                if not _is_under(event.src_path, watch.path):
                    return
            else:
                if not _direct_child_of(event.src_path, watch.path):
                    return
            watch.handler.dispatch(event)
        except Exception:
            # Never crash the emitter because of handler bugs.
            return

    def _tick_for_watch(self, watch: _Watch) -> None:
        new = _scan_snapshot(watch.path, watch.recursive)
        old = self._snapshots.get(watch)
        if old is None:
            # Baseline: do not emit initial creates for pre-existing files.
            self._snapshots[watch] = new
            return

        old_keys = set(old.keys())
        new_keys = set(new.keys())

        created = sorted(new_keys - old_keys)
        deleted = sorted(old_keys - new_keys)

        # Modified: signature changed.
        modified: List[str] = []
        for p in sorted(old_keys & new_keys):
            if old.get(p) != new.get(p):
                modified.append(p)

        # Emit in stable order: deleted, created, modified (reasonable default).
        for p in deleted:
            # For deleted, infer is_dir from old snapshot.
            sig = old.get(p)
            is_dir = bool(sig[3]) if sig else False
            self._dispatch(watch, self._event_for("deleted", p, is_dir))

        for p in created:
            sig = new.get(p)
            is_dir = bool(sig[3]) if sig else os.path.isdir(p)
            self._dispatch(watch, self._event_for("created", p, is_dir))

        for p in modified:
            sig = new.get(p)
            is_dir = bool(sig[3]) if sig else os.path.isdir(p)
            self._dispatch(watch, self._event_for("modified", p, is_dir))

        self._snapshots[watch] = new

    def run(self) -> None:
        # Take baseline ASAP after start for current watches.
        while not self._stopped.is_set():
            watches = self._observer._get_watches_snapshot()
            # Remove snapshots for watches that were unscheduled (not part of minimal API, but keep tidy).
            for w in list(self._snapshots.keys()):
                if w not in watches:
                    self._snapshots.pop(w, None)

            for watch in watches:
                self._tick_for_watch(watch)

            # Wait
            self._stopped.wait(self._interval)


class Observer:
    """
    Minimal Observer compatible with core scheduling and lifecycle methods.

    Pure-python polling implementation.
    """

    def __init__(self, timeout: float = 0.1):
        self._interval = float(timeout)
        if self._interval <= 0:
            self._interval = 0.1
        self._lock = threading.RLock()
        self._watches: List[_Watch] = []
        self._emitter: Optional[_PollingEmitter] = None

    def schedule(self, event_handler: FileSystemEventHandler, path: str, recursive: bool = False):
        watch = _Watch(handler=event_handler, path=_abspath(path), recursive=bool(recursive))
        with self._lock:
            self._watches.append(watch)
        return watch

    def _get_watches_snapshot(self) -> List[_Watch]:
        with self._lock:
            return list(self._watches)

    def start(self) -> None:
        with self._lock:
            if self._emitter is not None and self._emitter.is_alive():
                return
            self._emitter = _PollingEmitter(self, interval=self._interval)
            self._emitter.start()

    def stop(self) -> None:
        with self._lock:
            emitter = self._emitter
        if emitter is not None:
            emitter.stop()

    def join(self, timeout: Optional[float] = None) -> None:
        with self._lock:
            emitter = self._emitter
        if emitter is not None:
            emitter.join(timeout=timeout)
</file>

<file:name=_agent_tests/test_agent_basic.py>
import os
import time
from pathlib import Path

import pytest

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler


class RecordingHandler(FileSystemEventHandler):
    def __init__(self):
        self.events = []

    def on_created(self, event):
        self.events.append(("created", os.path.abspath(event.src_path), event.is_directory))

    def on_modified(self, event):
        self.events.append(("modified", os.path.abspath(event.src_path), event.is_directory))

    def on_deleted(self, event):
        self.events.append(("deleted", os.path.abspath(event.src_path), event.is_directory))


def wait_for(predicate, timeout=3.0, interval=0.02):
    t0 = time.time()
    while time.time() - t0 < timeout:
        if predicate():
            return True
        time.sleep(interval)
    return False


@pytest.fixture
def observer():
    obs = Observer(timeout=0.05)
    try:
        yield obs
    finally:
        obs.stop()
        obs.join(2.0)


def test_imports():
    import watchdog
    import watchdog.events
    import watchdog.observers

    assert hasattr(watchdog, "Observer")
    assert hasattr(watchdog.events, "FileSystemEventHandler")


def test_non_recursive_ignores_subdir(observer, tmp_path: Path):
    h = RecordingHandler()
    observer.schedule(h, str(tmp_path), recursive=False)
    observer.start()

    sub = tmp_path / "sub"
    sub.mkdir()
    f = sub / "a.txt"
    f.write_text("x", encoding="utf-8")

    assert not wait_for(lambda: any(e[1] == str(f.resolve()) and e[0] == "created" for e in h.events), timeout=1.0)


def test_recursive_sees_subdir_file(observer, tmp_path: Path):
    h = RecordingHandler()
    observer.schedule(h, str(tmp_path), recursive=True)
    observer.start()

    sub = tmp_path / "sub"
    sub.mkdir()
    f = sub / "a.txt"
    f.write_text("x", encoding="utf-8")

    assert wait_for(lambda: any(e[0] == "created" and e[1] == str(f.resolve()) for e in h.events), timeout=3.0)

    # Modify
    f.write_text("xy", encoding="utf-8")
    assert wait_for(lambda: any(e[0] == "modified" and e[1] == str(f.resolve()) for e in h.events), timeout=3.0)

    # Delete
    f.unlink()
    assert wait_for(lambda: any(e[0] == "deleted" and e[1] == str(f.resolve()) for e in h.events), timeout=3.0)


def test_no_initial_created_for_existing_file(tmp_path: Path):
    f = tmp_path / "preexist.txt"
    f.write_text("hello", encoding="utf-8")

    h = RecordingHandler()
    obs = Observer(timeout=0.05)
    obs.schedule(h, str(tmp_path), recursive=False)
    obs.start()
    try:
        time.sleep(0.3)
        assert not any(e[0] == "created" and e[1] == str(f.resolve()) for e in h.events)
    finally:
        obs.stop()
        obs.join(2.0)


def test_stop_prevents_more_events(tmp_path: Path):
    h = RecordingHandler()
    obs = Observer(timeout=0.05)
    obs.schedule(h, str(tmp_path), recursive=False)
    obs.start()

    f = tmp_path / "x.txt"
    f.write_text("1", encoding="utf-8")
    assert wait_for(lambda: any(e[0] == "created" and e[1] == str(f.resolve()) for e in h.events), timeout=3.0)

    obs.stop()
    obs.join(2.0)

    # After stop, new changes should not be observed.
    g = tmp_path / "y.txt"
    g.write_text("2", encoding="utf-8")
    time.sleep(0.3)
    assert not any(e[1] == str(g.resolve()) for e in h.events)


def test_multiple_handlers_receive(tmp_path: Path):
    obs = Observer(timeout=0.05)
    h1 = RecordingHandler()
    h2 = RecordingHandler()
    obs.schedule(h1, str(tmp_path), recursive=False)
    obs.schedule(h2, str(tmp_path), recursive=False)
    obs.start()
    try:
        f = tmp_path / "multi.txt"
        f.write_text("x", encoding="utf-8")
        assert wait_for(lambda: any(e[0] == "created" and e[1] == str(f.resolve()) for e in h1.events), timeout=3.0)
        assert wait_for(lambda: any(e[0] == "created" and e[1] == str(f.resolve()) for e in h2.events), timeout=3.0)
    finally:
        obs.stop()
        obs.join(2.0)
</file>