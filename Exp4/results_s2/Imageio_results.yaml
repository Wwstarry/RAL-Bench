project_name: Imageio
task_file: D:\桌面\RealAppCodeBench_generic_eval\tasks\Imageio\imageio.yaml
generated_repo: D:\桌面\RealAppCodeBench_generic_eval\generation_m3\Imageio
timestamp: '2026-01-15 11:30:22'
functional_score: 0.4
non_functional_score: 0.4
non_functional_subscores:
  maintainability: 0.0
  security: 1.0
  robustness: 1.0
  performance: 0.0
  resource: 0.0
non_functional_weights:
  maintainability: 0.36
  security: 0.24
  robustness: 0.16
  performance: 0.12
  resource: 0.12
results:
  functional:
    returncode: 1
    stdout: ".F.F..FFFF                                                          \
      \     [100%]\n================================== FAILURES ===================================\n\
      __________________ test_gif_multiframe_roundtrip_with_imiter __________________\n\
      \ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-545/test_gif_multiframe_roundtrip_0')\n\
      \n    def test_gif_multiframe_roundtrip_with_imiter(tmp_path: Path) -> None:\n\
      \        \"\"\"Write a small animated GIF and iterate frames using imiter.\"\
      \"\"\n        frames = _make_grayscale_frames(num_frames=6, height=24, width=24)\n\
      \        path = tmp_path / \"anim.gif\"\n    \n>       iio.imwrite(path, frames)\n\
      \ntests\\Imageio\\functional_test.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ngeneration_m3\\Imageio\\\
      imageio\\v3.py:239: in imwrite\n    _imwrite_impl(path, arr, **kwargs)\ngeneration_m3\\\
      Imageio\\imageio\\v3.py:96: in imwrite\n    pil_img = _pil_from_frame(image)\n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\n\nframe = array([[[175,  48,   5, ..., 108, 239,  95],\n        [239,\
      \  95,  27, ..., 228,  72, 250],\n        [155, 220,  51, ...,...99, 236, 251],\n\
      \        [120, 166, 247, ..., 100, 131,  54],\n        [ 79, 139,  45, ...,\
      \ 112, 215,  45]]], dtype=uint8)\n\n    def _pil_from_frame(frame: np.ndarray)\
      \ -> Image.Image:\n        frame = np.asarray(frame)\n        if frame.dtype\
      \ != np.uint8:\n            frame = frame.astype(np.uint8, copy=False)\n   \
      \ \n        if frame.ndim == 2:\n            return Image.fromarray(frame, mode=\"\
      L\")\n        if frame.ndim == 3:\n            h, w, c = frame.shape\n     \
      \       if c == 1:\n                return Image.fromarray(frame[:, :, 0], mode=\"\
      L\")\n            if c == 3:\n                return Image.fromarray(frame,\
      \ mode=\"RGB\")\n>           raise ValueError(f\"Unsupported channel count C={c};\
      \ expected 1 or 3\")\nE           ValueError: Unsupported channel count C=24;\
      \ expected 1 or 3\n\ngeneration_m3\\Imageio\\imageio\\v3.py:56: ValueError\n\
      _____________________ test_png_roundtrip_via_bytes_buffer _____________________\n\
      \nself = <PIL.Image.Image image mode=RGB size=31x20 at 0x199FF742B50>\nfp =\
      \ '<bytes>', format = None, params = {}, filename = '<bytes>', open_fp = True\n\
      save_all = False, filename_ext = '', ext = '', msg = 'unknown file extension:\
      \ '\n\n    def save(\n        self, fp: StrOrBytesPath | IO[bytes], format:\
      \ str | None = None, **params: Any\n    ) -> None:\n        \"\"\"\n       \
      \ Saves this image under the given filename.  If no format is\n        specified,\
      \ the format to use is determined from the filename\n        extension, if possible.\n\
      \    \n        Keyword options can be used to provide additional instructions\n\
      \        to the writer. If a writer doesn't recognise an option, it is\n   \
      \     silently ignored. The available options are described in the\n       \
      \ :doc:`image format documentation\n        <../handbook/image-file-formats>`\
      \ for each writer.\n    \n        You can use a file object instead of a filename.\
      \ In this case,\n        you must always specify the format. The file object\
      \ must\n        implement the ``seek``, ``tell``, and ``write``\n        methods,\
      \ and be opened in binary mode.\n    \n        :param fp: A filename (string),\
      \ os.PathLike object or file object.\n        :param format: Optional format\
      \ override.  If omitted, the\n           format to use is determined from the\
      \ filename extension.\n           If a file object was used instead of a filename,\
      \ this\n           parameter should always be used.\n        :param params:\
      \ Extra parameters to the image writer.\n        :returns: None\n        :exception\
      \ ValueError: If the output format could not be determined\n           from\
      \ the file name.  Use the format option to solve this.\n        :exception OSError:\
      \ If the file could not be written.  The file\n           may have been created,\
      \ and may contain partial data.\n        \"\"\"\n    \n        filename: str\
      \ | bytes = \"\"\n        open_fp = False\n        if is_path(fp):\n       \
      \     filename = os.fspath(fp)\n            open_fp = True\n        elif fp\
      \ == sys.stdout:\n            try:\n                fp = sys.stdout.buffer\n\
      \            except AttributeError:\n                pass\n        if not filename\
      \ and hasattr(fp, \"name\") and is_path(fp.name):\n            # only set the\
      \ name for metadata purposes\n            filename = os.fspath(fp.name)\n  \
      \  \n        # may mutate self!\n        self._ensure_mutable()\n    \n    \
      \    save_all = params.pop(\"save_all\", False)\n        self.encoderinfo =\
      \ {**getattr(self, \"encoderinfo\", {}), **params}\n        self.encoderconfig:\
      \ tuple[Any, ...] = ()\n    \n        preinit()\n    \n        filename_ext\
      \ = os.path.splitext(filename)[1].lower()\n        ext = filename_ext.decode()\
      \ if isinstance(filename_ext, bytes) else filename_ext\n    \n        if not\
      \ format:\n            if ext not in EXTENSION:\n                init()\n  \
      \          try:\n>               format = EXTENSION[ext]\nE               KeyError:\
      \ ''\n\nC:\\Users\\86152\\AppData\\Local\\Programs\\Python\\Python39\\lib\\\
      site-packages\\PIL\\Image.py:2571: KeyError\n\nThe above exception was the direct\
      \ cause of the following exception:\n\n    def test_png_roundtrip_via_bytes_buffer()\
      \ -> None:\n        \"\"\"Write PNG to in-memory bytes, then read back using\
      \ extension.\"\"\"\n        img = _make_color_image(height=20, width=31)\n \
      \   \n>       blob = iio.imwrite(\"<bytes>\", img, extension=\".png\")\n\ntests\\\
      Imageio\\functional_test.py:139: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ngeneration_m3\\Imageio\\imageio\\v3.py:239:\
      \ in imwrite\n    _imwrite_impl(path, arr, **kwargs)\ngeneration_m3\\Imageio\\\
      imageio\\v3.py:97: in imwrite\n    pil_img.save(path)\n_ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <PIL.Image.Image\
      \ image mode=RGB size=31x20 at 0x199FF742B50>\nfp = '<bytes>', format = None,\
      \ params = {}, filename = '<bytes>', open_fp = True\nsave_all = False, filename_ext\
      \ = '', ext = '', msg = 'unknown file extension: '\n\n    def save(\n      \
      \  self, fp: StrOrBytesPath | IO[bytes], format: str | None = None, **params:\
      \ Any\n    ) -> None:\n        \"\"\"\n        Saves this image under the given\
      \ filename.  If no format is\n        specified, the format to use is determined\
      \ from the filename\n        extension, if possible.\n    \n        Keyword\
      \ options can be used to provide additional instructions\n        to the writer.\
      \ If a writer doesn't recognise an option, it is\n        silently ignored.\
      \ The available options are described in the\n        :doc:`image format documentation\n\
      \        <../handbook/image-file-formats>` for each writer.\n    \n        You\
      \ can use a file object instead of a filename. In this case,\n        you must\
      \ always specify the format. The file object must\n        implement the ``seek``,\
      \ ``tell``, and ``write``\n        methods, and be opened in binary mode.\n\
      \    \n        :param fp: A filename (string), os.PathLike object or file object.\n\
      \        :param format: Optional format override.  If omitted, the\n       \
      \    format to use is determined from the filename extension.\n           If\
      \ a file object was used instead of a filename, this\n           parameter should\
      \ always be used.\n        :param params: Extra parameters to the image writer.\n\
      \        :returns: None\n        :exception ValueError: If the output format\
      \ could not be determined\n           from the file name.  Use the format option\
      \ to solve this.\n        :exception OSError: If the file could not be written.\
      \  The file\n           may have been created, and may contain partial data.\n\
      \        \"\"\"\n    \n        filename: str | bytes = \"\"\n        open_fp\
      \ = False\n        if is_path(fp):\n            filename = os.fspath(fp)\n \
      \           open_fp = True\n        elif fp == sys.stdout:\n            try:\n\
      \                fp = sys.stdout.buffer\n            except AttributeError:\n\
      \                pass\n        if not filename and hasattr(fp, \"name\") and\
      \ is_path(fp.name):\n            # only set the name for metadata purposes\n\
      \            filename = os.fspath(fp.name)\n    \n        # may mutate self!\n\
      \        self._ensure_mutable()\n    \n        save_all = params.pop(\"save_all\"\
      , False)\n        self.encoderinfo = {**getattr(self, \"encoderinfo\", {}),\
      \ **params}\n        self.encoderconfig: tuple[Any, ...] = ()\n    \n      \
      \  preinit()\n    \n        filename_ext = os.path.splitext(filename)[1].lower()\n\
      \        ext = filename_ext.decode() if isinstance(filename_ext, bytes) else\
      \ filename_ext\n    \n        if not format:\n            if ext not in EXTENSION:\n\
      \                init()\n            try:\n                format = EXTENSION[ext]\n\
      \            except KeyError as e:\n                msg = f\"unknown file extension:\
      \ {ext}\"\n>               raise ValueError(msg) from e\nE               ValueError:\
      \ unknown file extension:\n\nC:\\Users\\86152\\AppData\\Local\\Programs\\Python\\\
      Python39\\lib\\site-packages\\PIL\\Image.py:2574: ValueError\n___________ test_gif_imread_returns_stack_with_expected_frame_count\
      \ ___________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-545/test_gif_imread_returns_stack_0')\n\
      \n    def test_gif_imread_returns_stack_with_expected_frame_count(tmp_path:\
      \ Path) -> None:\n        \"\"\"Reading a GIF via imread should produce a stack/sequence\
      \ with the right number of frames.\"\"\"\n        frames = _make_grayscale_frames(num_frames=5,\
      \ height=20, width=21)\n        path = tmp_path / \"stack.gif\"\n    \n>   \
      \    iio.imwrite(path, frames)\n\ntests\\Imageio\\functional_test.py:189: \n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\ngeneration_m3\\Imageio\\imageio\\v3.py:239: in imwrite\n    _imwrite_impl(path,\
      \ arr, **kwargs)\ngeneration_m3\\Imageio\\imageio\\v3.py:96: in imwrite\n  \
      \  pil_img = _pil_from_frame(image)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nframe = array([[[175,  48,   5,\
      \ ..., 173,  66,  93],\n        [108, 239,  95, ...,  84,  50,  73],\n     \
      \   [  3,  59, 140, ...,...18,  26, 217],\n        [255, 220, 204, ...,  46,\
      \  65,  79],\n        [235, 162, 251, ..., 155,  10, 108]]], dtype=uint8)\n\n\
      \    def _pil_from_frame(frame: np.ndarray) -> Image.Image:\n        frame =\
      \ np.asarray(frame)\n        if frame.dtype != np.uint8:\n            frame\
      \ = frame.astype(np.uint8, copy=False)\n    \n        if frame.ndim == 2:\n\
      \            return Image.fromarray(frame, mode=\"L\")\n        if frame.ndim\
      \ == 3:\n            h, w, c = frame.shape\n            if c == 1:\n       \
      \         return Image.fromarray(frame[:, :, 0], mode=\"L\")\n            if\
      \ c == 3:\n                return Image.fromarray(frame, mode=\"RGB\")\n>  \
      \         raise ValueError(f\"Unsupported channel count C={c}; expected 1 or\
      \ 3\")\nE           ValueError: Unsupported channel count C=21; expected 1 or\
      \ 3\n\ngeneration_m3\\Imageio\\imageio\\v3.py:56: ValueError\n___________ test_gif_imread_index0_matches_first_imiter_frame_shape\
      \ ___________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-545/test_gif_imread_index0_matches0')\n\
      \n    def test_gif_imread_index0_matches_first_imiter_frame_shape(tmp_path:\
      \ Path) -> None:\n        \"\"\"Read first GIF frame using both index=0 and\
      \ imiter; verify consistent spatial shape.\"\"\"\n        frames = _make_grayscale_frames(num_frames=4,\
      \ height=19, width=23)\n        path = tmp_path / \"index0.gif\"\n    \n>  \
      \     iio.imwrite(path, frames)\n\ntests\\Imageio\\functional_test.py:203: \n\
      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _\ngeneration_m3\\Imageio\\imageio\\v3.py:239: in imwrite\n    _imwrite_impl(path,\
      \ arr, **kwargs)\ngeneration_m3\\Imageio\\imageio\\v3.py:96: in imwrite\n  \
      \  pil_img = _pil_from_frame(image)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nframe = array([[[175,  48,   5,\
      \ ...,  93, 108, 239],\n        [ 95, 239,  95, ...,  59, 140, 228],\n     \
      \   [ 72, 250, 155, ...,...57, 165, 255],\n        [ 18,  28,  29, ..., 155,\
      \ 216, 213],\n        [219, 124,  59, ..., 250, 200, 138]]], dtype=uint8)\n\n\
      \    def _pil_from_frame(frame: np.ndarray) -> Image.Image:\n        frame =\
      \ np.asarray(frame)\n        if frame.dtype != np.uint8:\n            frame\
      \ = frame.astype(np.uint8, copy=False)\n    \n        if frame.ndim == 2:\n\
      \            return Image.fromarray(frame, mode=\"L\")\n        if frame.ndim\
      \ == 3:\n            h, w, c = frame.shape\n            if c == 1:\n       \
      \         return Image.fromarray(frame[:, :, 0], mode=\"L\")\n            if\
      \ c == 3:\n                return Image.fromarray(frame, mode=\"RGB\")\n>  \
      \         raise ValueError(f\"Unsupported channel count C={c}; expected 1 or\
      \ 3\")\nE           ValueError: Unsupported channel count C=23; expected 1 or\
      \ 3\n\ngeneration_m3\\Imageio\\imageio\\v3.py:56: ValueError\n_______________________\
      \ test_imopen_write_then_read_png _______________________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-545/test_imopen_write_then_read_pn0')\n\
      \n    def test_imopen_write_then_read_png(tmp_path: Path) -> None:\n       \
      \ \"\"\"Use the v3 imopen context manager to write then read a PNG.\"\"\"\n\
      \        img = _make_color_image(height=16, width=20)\n        path = tmp_path\
      \ / \"imopen.png\"\n    \n>       with iio.imopen(path, \"w\") as f:\nE    \
      \   AttributeError: module 'imageio.v3' has no attribute 'imopen'\n\ntests\\\
      Imageio\\functional_test.py:221: AttributeError\n____________ test_improps_for_gif_has_expected_spatial_dimensions\
      \ _____________\n\ntmp_path = WindowsPath('C:/Users/86152/AppData/Local/Temp/pytest-of-86152/pytest-545/test_improps_for_gif_has_expec0')\n\
      \n    def test_improps_for_gif_has_expected_spatial_dimensions(tmp_path: Path)\
      \ -> None:\n        \"\"\"improps on a GIF should include the written frame\
      \ height/width in its reported shape.\n    \n        In practice, different\
      \ plugins/paths can report shapes like:\n          - (T, H, W)\n          -\
      \ (T, H, W, C)\n          - (H, W, C)\n          - (W, H, C)\n        Therefore\
      \ we validate that the expected H and W appear somewhere in props.shape,\n \
      \       without assuming their exact positions.\n        \"\"\"\n        frames\
      \ = _make_grayscale_frames(num_frames=3, height=17, width=19)\n        path\
      \ = tmp_path / \"props.gif\"\n    \n>       iio.imwrite(path, frames)\n\ntests\\\
      Imageio\\functional_test.py:248: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ngeneration_m3\\Imageio\\imageio\\v3.py:239:\
      \ in imwrite\n    _imwrite_impl(path, arr, **kwargs)\ngeneration_m3\\Imageio\\\
      imageio\\v3.py:96: in imwrite\n    pil_img = _pil_from_frame(image)\n_ _ _ _\
      \ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n\
      frame = array([[[175,  48,   5,  97, 162,  98,  32, 180, 237, 234,  27, 119,\n\
      \         129, 130, 192, 109,  49,  37, 173],\n    ...193, 108,  94, 224, 102,\
      \  31,  61, 217, 175, 231, 194, 199,\n          97, 107,  97,  61, 152,  69,\
      \ 111]]], dtype=uint8)\n\n    def _pil_from_frame(frame: np.ndarray) -> Image.Image:\n\
      \        frame = np.asarray(frame)\n        if frame.dtype != np.uint8:\n  \
      \          frame = frame.astype(np.uint8, copy=False)\n    \n        if frame.ndim\
      \ == 2:\n            return Image.fromarray(frame, mode=\"L\")\n        if frame.ndim\
      \ == 3:\n            h, w, c = frame.shape\n            if c == 1:\n       \
      \         return Image.fromarray(frame[:, :, 0], mode=\"L\")\n            if\
      \ c == 3:\n                return Image.fromarray(frame, mode=\"RGB\")\n>  \
      \         raise ValueError(f\"Unsupported channel count C={c}; expected 1 or\
      \ 3\")\nE           ValueError: Unsupported channel count C=19; expected 1 or\
      \ 3\n\ngeneration_m3\\Imageio\\imageio\\v3.py:56: ValueError\n===========================\
      \ short test summary info ===========================\nFAILED tests/Imageio/functional_test.py::test_gif_multiframe_roundtrip_with_imiter\n\
      FAILED tests/Imageio/functional_test.py::test_png_roundtrip_via_bytes_buffer\n\
      FAILED tests/Imageio/functional_test.py::test_gif_imread_returns_stack_with_expected_frame_count\n\
      FAILED tests/Imageio/functional_test.py::test_gif_imread_index0_matches_first_imiter_frame_shape\n\
      FAILED tests/Imageio/functional_test.py::test_imopen_write_then_read_png - At...\n\
      FAILED tests/Imageio/functional_test.py::test_improps_for_gif_has_expected_spatial_dimensions\n\
      6 failed, 4 passed in 1.60s\n"
    elapsed_time_s: 25.059598
    avg_memory_mb: 51.18
    avg_cpu_percent: 0.76
    passed: 4
    failed: 6
    skipped: 0
    total: 10
    score_inputs_passed: 4
    score_inputs_failed: 6
    score_inputs_total: 10
    score_inputs_returncode: 1
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - functional_suite_time_s
    - functional_tests_total
  performance:
    returncode: 2
    stdout: "\n=================================== ERRORS ====================================\n\
      _____________ ERROR collecting tests/Imageio/performance_test.py ______________\n\
      tests\\Imageio\\performance_test.py:20: in <module>\n    raise RuntimeError(f\"\
      Unsupported IMAGEIO_TARGET value: {TARGET_ENV}\")\nE   RuntimeError: Unsupported\
      \ IMAGEIO_TARGET value: generated\n=========================== short test summary\
      \ info ===========================\nERROR tests/Imageio/performance_test.py\
      \ - RuntimeError: Unsupported IMAGEIO_T...\n!!!!!!!!!!!!!!!!!!! Interrupted:\
      \ 1 error during collection !!!!!!!!!!!!!!!!!!!!\n1 error in 0.72s\n"
    elapsed_time_s: 2.010476
    avg_memory_mb: 43.96
    avg_cpu_percent: 99.2
    passed: 0
    failed: 0
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 2
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - performance_suite_time_s
    - performance_tests_total
    score_inputs_baseline_time_s: 2.827932
    score_inputs_actual_time_s: 2.010476
  resource:
    returncode: 2
    stdout: "\n=================================== ERRORS ====================================\n\
      _______________ ERROR collecting tests/Imageio/resource_test.py _______________\n\
      tests\\Imageio\\resource_test.py:20: in <module>\n    raise RuntimeError(f\"\
      Unsupported IMAGEIO_TARGET value: {TARGET_ENV}\")\nE   RuntimeError: Unsupported\
      \ IMAGEIO_TARGET value: generated\n=========================== short test summary\
      \ info ===========================\nERROR tests/Imageio/resource_test.py - RuntimeError:\
      \ Unsupported IMAGEIO_TARG...\n!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during\
      \ collection !!!!!!!!!!!!!!!!!!!!\n1 error in 0.76s\n"
    elapsed_time_s: 2.054462
    avg_memory_mb: 44.37
    avg_cpu_percent: 98.4
    passed: 0
    failed: 0
    skipped: 0
    total: 1
    score_inputs_passed: 0
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 2
    score_inputs_failed_suite: true
    score_inputs_baseline_keys:
    - avg_cpu_percent
    - avg_memory_mb
    - resource_suite_time_s
    - resource_tests_total
    score_inputs_baseline_mem_mb: 49.3
    score_inputs_baseline_cpu_pct: 100.0
    score_inputs_actual_mem_mb: 44.37
    score_inputs_actual_cpu_pct: 98.4
  robustness:
    returncode: 0
    stdout: '...                                                                      [100%]

      3 passed in 0.39s

      '
    elapsed_time_s: 1.594216
    avg_memory_mb: 41.52
    avg_cpu_percent: 99.0
    passed: 3
    failed: 0
    skipped: 0
    total: 3
    score_inputs_passed: 3
    score_inputs_failed: 0
    score_inputs_total: 3
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - robustness_suite_time_s
    - robustness_tests_total
  security:
    returncode: 0
    stdout: 'SECURITY_METRICS high_risk_count=0.0 files_scanned=2.0 total_loc=193.0

      .

      1 passed in 0.11s

      '
    elapsed_time_s: 1.335529
    avg_memory_mb: 31.98
    avg_cpu_percent: 98.8
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 2.0
      total_loc: 193.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - metrics
    - security_suite_time_s
    - security_tests_total
    score_inputs_baseline_high_risk_count: 0.0
    score_inputs_generated_high_risk_count: 0.0
  maintainability:
    returncode: 0
    stdout: 'MAINT_METRICS mi_min=22.3782 files_scanned=2.0 total_loc=193.0 max_cc=12.0

      .

      1 passed in 0.13s

      '
    elapsed_time_s: 1.270164
    avg_memory_mb: 31.77
    avg_cpu_percent: 100.0
    passed: 1
    failed: 0
    skipped: 0
    total: 1
    metrics:
      mi_min: 22.3782
      files_scanned: 2.0
      total_loc: 193.0
      max_cc: 12.0
    score_inputs_passed: 1
    score_inputs_failed: 0
    score_inputs_total: 1
    score_inputs_returncode: 0
    score_inputs_failed_suite: false
    score_inputs_baseline_keys:
    - maintainability_suite_time_s
    - maintainability_tests_total
    - metrics
    score_inputs_baseline_mi_min: 0.0
    score_inputs_generated_mi_min: 22.3782
baseline_metrics:
  performance:
    performance_suite_time_s: 2.827932
    performance_tests_total: 2
  resource:
    resource_suite_time_s: 5.63166
    resource_tests_total: 2
    avg_memory_mb: 49.3
    avg_cpu_percent: 100.0
  functional:
    functional_suite_time_s: 2.306904
    functional_tests_total: 10
  robustness:
    robustness_suite_time_s: 2.034907
    robustness_tests_total: 3
  security:
    security_suite_time_s: 1.977626
    security_tests_total: 1
    metrics:
      high_risk_count: 0.0
      files_scanned: 49.0
      total_loc: 26366.0
  maintainability:
    maintainability_suite_time_s: 3.158483
    maintainability_tests_total: 1
    metrics:
      mi_min: 0.0
      files_scanned: 49.0
      total_loc: 26366.0
      max_cc: 217.0
pytest_logs_dir: D:\桌面\RealAppCodeBench_generic_eval\results\Imageio\pytest_logs
