<file:name=mutagen/__init__.py>
"""
A tiny, pure-Python subset of the Mutagen API required by the test suite.

This is NOT the real Mutagen project. It implements only:
- mutagen.easyid3.EasyID3
- mutagen.id3.ID3 and a few frame classes (TIT2, TPE1, COMM, APIC)

It persists tags in a simple custom container embedded in files (including
tag-only ".mp3" files), sufficient for roundtripping within this library.
"""

from __future__ import annotations

__all__ = ["easyid3", "id3", "__version__"]
__version__ = "0.0.0"

# Ensure submodules are importable as in the reference project
from . import easyid3 as easyid3  # noqa: F401
from . import id3 as id3  # noqa: F401
</file>

<file:name=mutagen/id3.py>
from __future__ import annotations

import base64
import json
import os
import tempfile
from dataclasses import dataclass
from typing import Any, Dict, List, Optional


# ---- Persistence format -------------------------------------------------------
#
# We store a JSON document in the file, delimited by markers:
#   b"MUTAGENPY1\n" + <json utf-8> + b"\nENDMUTAGENPY1\n"
#
# If extra bytes exist (e.g., audio), we keep them after the tag blob.
# When saving, we replace the entire existing tag blob (if present) and preserve
# the trailing bytes after it. For tag-only files, the file will only contain
# this blob.
#
# JSON schema:
# {
#   "v": 1,
#   "frames": {
#       "TIT2": [ { ...frame dict... }, ... ],
#       "COMM": [ ... ],
#       ...
#   }
# }
#
# APIC.data is stored base64 to keep JSON text-friendly.

_MAGIC = b"MUTAGENPY1\n"
_END = b"\nENDMUTAGENPY1\n"


def _atomic_write(path: str, data: bytes) -> None:
    directory = os.path.dirname(os.path.abspath(path)) or "."
    fd, tmp = tempfile.mkstemp(prefix=".mutagenpy-", dir=directory)
    try:
        with os.fdopen(fd, "wb") as f:
            f.write(data)
            f.flush()
            os.fsync(f.fileno())
        os.replace(tmp, path)
    finally:
        try:
            if os.path.exists(tmp):
                os.remove(tmp)
        except OSError:
            pass


def _split_container(raw: bytes) -> tuple[Optional[bytes], bytes]:
    """
    Returns (json_bytes_or_None, trailing_bytes).
    If no container is found, returns (None, raw).
    """
    start = raw.find(_MAGIC)
    if start < 0:
        return None, raw
    end = raw.find(_END, start + len(_MAGIC))
    if end < 0:
        # Corrupt/partial; treat as no tags and preserve raw
        return None, raw
    json_start = start + len(_MAGIC)
    json_bytes = raw[json_start:end]
    trailing = raw[end + len(_END) :]
    return json_bytes, trailing


def _load_from_file(path: str) -> tuple[Dict[str, List[Dict[str, Any]]], bytes]:
    with open(path, "rb") as f:
        raw = f.read()
    json_bytes, trailing = _split_container(raw)
    if json_bytes is None:
        return {}, raw  # trailing is the whole file in this case
    try:
        obj = json.loads(json_bytes.decode("utf-8"))
        frames = obj.get("frames", {})
        if not isinstance(frames, dict):
            return {}, trailing
        # Normalize: ensure lists
        norm: Dict[str, List[Dict[str, Any]]] = {}
        for k, v in frames.items():
            if isinstance(k, str) and isinstance(v, list):
                norm[k] = [x for x in v if isinstance(x, dict)]
        return norm, trailing
    except Exception:
        # If not our JSON, treat as empty tags but preserve trailing bytes.
        return {}, trailing


def _encode_container(frames: Dict[str, List[Dict[str, Any]]], trailing: bytes) -> bytes:
    obj = {"v": 1, "frames": frames}
    json_bytes = json.dumps(obj, ensure_ascii=False, separators=(",", ":")).encode("utf-8")
    return _MAGIC + json_bytes + _END + (trailing or b"")


# ---- Frames ------------------------------------------------------------------

@dataclass
class Frame:
    """Base class for frames."""
    encoding: int

    @property
    def FrameID(self) -> str:  # for compatibility-ish
        raise NotImplementedError

    def to_dict(self) -> Dict[str, Any]:
        raise NotImplementedError

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "Frame":
        raise NotImplementedError


def _norm_text_list(text: Any) -> List[str]:
    if text is None:
        return []
    if isinstance(text, list):
        return [str(x) for x in text]
    return [str(text)]


@dataclass
class TIT2(Frame):
    text: List[str]

    FrameID = "TIT2"

    def __init__(self, encoding: int, text: Any = None):
        super().__init__(encoding)
        self.text = _norm_text_list(text)

    def to_dict(self) -> Dict[str, Any]:
        return {"id": "TIT2", "encoding": int(self.encoding), "text": list(self.text)}

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "TIT2":
        return cls(int(d.get("encoding", 0)), d.get("text", []))


@dataclass
class TPE1(Frame):
    text: List[str]

    FrameID = "TPE1"

    def __init__(self, encoding: int, text: Any = None):
        super().__init__(encoding)
        self.text = _norm_text_list(text)

    def to_dict(self) -> Dict[str, Any]:
        return {"id": "TPE1", "encoding": int(self.encoding), "text": list(self.text)}

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "TPE1":
        return cls(int(d.get("encoding", 0)), d.get("text", []))


@dataclass
class TRCK(Frame):
    text: List[str]

    FrameID = "TRCK"

    def __init__(self, encoding: int, text: Any = None):
        super().__init__(encoding)
        self.text = _norm_text_list(text)

    def to_dict(self) -> Dict[str, Any]:
        return {"id": "TRCK", "encoding": int(self.encoding), "text": list(self.text)}

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "TRCK":
        return cls(int(d.get("encoding", 0)), d.get("text", []))


@dataclass
class COMM(Frame):
    lang: str
    desc: str
    text: List[str]

    FrameID = "COMM"

    def __init__(self, encoding: int, lang: str, desc: str, text: Any):
        super().__init__(encoding)
        self.lang = str(lang)
        self.desc = str(desc)
        self.text = _norm_text_list(text)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": "COMM",
            "encoding": int(self.encoding),
            "lang": self.lang,
            "desc": self.desc,
            "text": list(self.text),
        }

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "COMM":
        return cls(
            int(d.get("encoding", 0)),
            d.get("lang", "eng"),
            d.get("desc", ""),
            d.get("text", []),
        )


@dataclass
class APIC(Frame):
    mime: str
    type: int
    desc: str
    data: bytes

    FrameID = "APIC"

    def __init__(self, encoding: int, mime: str, type: int, desc: str, data: bytes):
        super().__init__(encoding)
        self.mime = str(mime)
        self.type = int(type)
        self.desc = str(desc)
        if not isinstance(data, (bytes, bytearray, memoryview)):
            raise TypeError("APIC.data must be bytes-like")
        self.data = bytes(data)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": "APIC",
            "encoding": int(self.encoding),
            "mime": self.mime,
            "type": int(self.type),
            "desc": self.desc,
            "data_b64": base64.b64encode(self.data).decode("ascii"),
        }

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "APIC":
        b64 = d.get("data_b64", "")
        try:
            data = base64.b64decode(b64.encode("ascii"), validate=False)
        except Exception:
            data = b""
        return cls(
            int(d.get("encoding", 0)),
            d.get("mime", "image/"),
            int(d.get("type", 0)),
            d.get("desc", ""),
            data,
        )


_FRAME_CLASSES = {
    "TIT2": TIT2,
    "TPE1": TPE1,
    "TRCK": TRCK,
    "COMM": COMM,
    "APIC": APIC,
}


def _frame_from_dict(d: Dict[str, Any]) -> Optional[Frame]:
    fid = d.get("id")
    cls = _FRAME_CLASSES.get(fid)
    if cls is None:
        return None
    try:
        return cls.from_dict(d)  # type: ignore[attr-defined]
    except Exception:
        return None


# ---- ID3 tag container --------------------------------------------------------

class ID3:
    def __init__(self, filename: Optional[str] = None):
        self.filename: Optional[str] = None
        self._frames: Dict[str, List[Frame]] = {}
        self._trailing: bytes = b""

        if filename is not None:
            self.load(filename)

    def load(self, filename: str) -> None:
        frames_dicts, trailing = _load_from_file(filename)
        self.filename = filename
        self._trailing = trailing
        frames: Dict[str, List[Frame]] = {}
        for fid, lst in frames_dicts.items():
            out: List[Frame] = []
            for item in lst:
                fr = _frame_from_dict(item)
                if fr is not None:
                    out.append(fr)
            frames[fid] = out
        self._frames = frames

    def add(self, frame: Frame) -> None:
        fid = getattr(frame, "FrameID", None) or getattr(frame, "id", None)
        if not fid or not isinstance(fid, str):
            raise ValueError("Frame missing FrameID")
        self._frames.setdefault(fid, []).append(frame)

    def __getitem__(self, frame_id: str) -> Frame:
        lst = self._frames.get(frame_id, [])
        if not lst:
            raise KeyError(frame_id)
        return lst[0]

    def getall(self, frame_id: str) -> List[Frame]:
        return list(self._frames.get(frame_id, []))

    def delall(self, frame_id: str) -> None:
        self._frames.pop(frame_id, None)

    def setall(self, frame_id: str, frames: List[Frame]) -> None:
        checked: List[Frame] = []
        for fr in frames:
            fid = getattr(fr, "FrameID", None) or getattr(fr, "id", None)
            if fid != frame_id:
                raise ValueError("Frame ID mismatch in setall")
            checked.append(fr)
        self._frames[frame_id] = checked

    def save(self, path: Optional[str] = None) -> None:
        out_path = path or self.filename
        if not out_path:
            raise ValueError("No filename specified for save()")

        # If saving to an existing file and it has our container, preserve trailing.
        trailing = b""
        if path is None:
            trailing = self._trailing
        else:
            try:
                _, trailing = _load_from_file(out_path)
            except FileNotFoundError:
                trailing = b""

        frames_dicts: Dict[str, List[Dict[str, Any]]] = {}
        for fid, lst in self._frames.items():
            frames_dicts[fid] = [fr.to_dict() for fr in lst]

        data = _encode_container(frames_dicts, trailing)
        _atomic_write(out_path, data)

        self.filename = out_path
        self._trailing = trailing
</file>

<file:name=mutagen/easyid3.py>
from __future__ import annotations

from collections.abc import MutableMapping, Iterator
from typing import Dict, List, Optional, Tuple, Any

from .id3 import ID3, TIT2, TPE1, TRCK


_EASY_TO_FRAME = {
    "title": "TIT2",
    "artist": "TPE1",
    "tracknumber": "TRCK",
}

_FRAME_TO_EASY = {v: k for k, v in _EASY_TO_FRAME.items()}


class EasyID3(MutableMapping[str, List[str]]):
    """
    Minimal EasyID3 implementation compatible with core behaviors used in tests.
    Acts like a mapping of easy keys -> list[str], persisted via our ID3 container.
    """

    def __init__(self, filename: Optional[str] = None):
        self.filename: Optional[str] = None
        self._data: Dict[str, List[str]] = {}
        if filename is not None:
            self.load(filename)

    def load(self, filename: str) -> None:
        id3 = ID3(filename)
        self.filename = filename
        data: Dict[str, List[str]] = {}
        # Pull mapped frames
        for fid, easy in _FRAME_TO_EASY.items():
            try:
                fr = id3[fid]
            except KeyError:
                continue
            txt = getattr(fr, "text", None)
            if isinstance(txt, list):
                data[easy] = [str(x) for x in txt]
            elif txt is None:
                continue
            else:
                data[easy] = [str(txt)]
        self._data = data

    def __getitem__(self, key: str) -> List[str]:
        if key not in self._data:
            raise KeyError(key)
        return self._data[key]

    def __setitem__(self, key: str, value: List[str]) -> None:
        if not isinstance(key, str):
            raise TypeError("EasyID3 keys must be str")
        if isinstance(value, (str, bytes)):
            raise TypeError("EasyID3 values must be list[str]")
        if not isinstance(value, list):
            raise TypeError("EasyID3 values must be list[str]")
        self._data[key] = [str(x) for x in value]

    def __delitem__(self, key: str) -> None:
        if key not in self._data:
            raise KeyError(key)
        del self._data[key]

    def __iter__(self) -> Iterator[str]:
        return iter(self._data)

    def __len__(self) -> int:
        return len(self._data)

    def _to_id3(self, base: Optional[ID3] = None) -> ID3:
        id3 = base if base is not None else ID3()
        # Update mapped frames; ensure deletions propagate by removing mapped frames
        for easy_key, fid in _EASY_TO_FRAME.items():
            if easy_key in self._data:
                vals = self._data[easy_key]
                if fid == "TIT2":
                    id3.setall("TIT2", [TIT2(3, text=vals)])
                elif fid == "TPE1":
                    id3.setall("TPE1", [TPE1(3, text=vals)])
                elif fid == "TRCK":
                    id3.setall("TRCK", [TRCK(3, text=vals)])
            else:
                id3.delall(fid)
        return id3

    def save(self, path: Optional[str] = None) -> None:
        out_path = path or self.filename
        if not out_path:
            raise ValueError("No filename specified for save()")

        # If saving to existing file, load it to preserve non-easy frames (COMM/APIC)
        base: Optional[ID3] = None
        if path is None:
            # We were loaded from a file; preserve all other frames.
            base = ID3(self.filename) if self.filename else ID3()
        else:
            try:
                base = ID3(out_path)
            except FileNotFoundError:
                base = ID3()

        id3 = self._to_id3(base)
        id3.save(out_path)
        self.filename = out_path
</file>