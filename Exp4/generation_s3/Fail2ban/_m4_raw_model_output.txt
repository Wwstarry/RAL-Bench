<file:name=fail2ban/__init__.py>
"""
Minimal, safe-to-evaluate subset of Fail2Ban.

This repository intentionally omits any daemon, firewall, or privileged behavior.
"""

__version__ = "0.1.0"
</file>

<file:name=fail2ban/server/__init__.py>
"""Server-side minimal API surface for the benchmark."""
</file>

<file:name=fail2ban/server/filter.py>
from __future__ import annotations

import ipaddress
import re
from typing import List, Optional


# Conservative candidate extractors; final validation uses ipaddress.
_IPV4_CANDIDATE_RE = re.compile(r"(?<![\w.])(?:\d{1,3}\.){3}\d{1,3}(?![\w.])")
# IPv6 is tricky; accept reasonably broad tokens containing ":" and hex, then validate.
_IPV6_CANDIDATE_RE = re.compile(r"(?<![\w:])(?:[0-9A-Fa-f]{0,4}:){2,7}[0-9A-Fa-f]{0,4}(?![\w:])")


def _coerce_str(value) -> str:
    try:
        return value if isinstance(value, str) else str(value)
    except Exception:
        return ""


def _strip_brackets(token: str) -> str:
    # Support "[::1]" style by stripping single surrounding brackets.
    if len(token) >= 2 and token[0] == "[" and token[-1] == "]":
        return token[1:-1]
    return token


def isValidIP(ip: str) -> bool:
    """
    Return True if ip is a valid textual IPv4 or IPv6 address, else False.
    Never raises for weird inputs.
    """
    s = _coerce_str(ip).strip()
    if not s:
        return False

    s = _strip_brackets(s)

    # Reject common port suffixes explicitly; ipaddress doesn't accept them anyway
    # but this keeps behavior predictable.
    if s.count(":") == 1 and "." in s and s.rsplit(":", 1)[-1].isdigit():
        # e.g. "1.2.3.4:22"
        return False

    try:
        ipaddress.ip_address(s)
        return True
    except Exception:
        return False


def findAllIP(text: str) -> List[str]:
    """
    Return all valid IPs found in text (IPv4 and IPv6), in order of appearance.
    May include duplicates.
    """
    s = _coerce_str(text)
    if not s:
        return []

    candidates: List[tuple[int, str]] = []

    for m in _IPV4_CANDIDATE_RE.finditer(s):
        candidates.append((m.start(), m.group(0)))

    for m in _IPV6_CANDIDATE_RE.finditer(s):
        tok = m.group(0)
        # Avoid treating a pure "::::" style junk as candidate; still validate.
        candidates.append((m.start(), tok))

    candidates.sort(key=lambda t: t[0])

    out: List[str] = []
    for _, tok in candidates:
        tok2 = _strip_brackets(tok)
        if isValidIP(tok2):
            out.append(tok2)
    return out


def searchIP(text: str) -> Optional[str]:
    """Return the first valid IP found in text, else None."""
    ips = findAllIP(text)
    return ips[0] if ips else None


class RegexFilter:
    """
    Minimal regex-based filter.

    - failregex: list of patterns that indicate a failure line.
    - ignoreregex: list of patterns that suppress matches.
    - use_dns is accepted for compatibility but never used (no DNS/network).
    """

    def __init__(
        self,
        failregex: Optional[List[str]] = None,
        ignoreregex: Optional[List[str]] = None,
        *,
        use_dns: bool = False,
    ):
        self._use_dns = bool(use_dns)
        self._fail_patterns: List[re.Pattern] = []
        self._ignore_patterns: List[re.Pattern] = []
        self._fail_sources: List[str] = []
        self._ignore_sources: List[str] = []

        if failregex:
            for p in failregex:
                self.addFailRegex(p)
        if ignoreregex:
            for p in ignoreregex:
                self.addIgnoreRegex(p)

    def addFailRegex(self, pattern: str) -> None:
        try:
            c = re.compile(pattern)
        except re.error as e:
            raise ValueError(f"Invalid failregex pattern: {pattern!r}: {e}") from e
        self._fail_patterns.append(c)
        self._fail_sources.append(pattern)

    def addIgnoreRegex(self, pattern: str) -> None:
        try:
            c = re.compile(pattern)
        except re.error as e:
            raise ValueError(f"Invalid ignoreregex pattern: {pattern!r}: {e}") from e
        self._ignore_patterns.append(c)
        self._ignore_sources.append(pattern)

    def getFailRegex(self) -> List[str]:
        return list(self._fail_sources)

    def getIgnoreRegex(self) -> List[str]:
        return list(self._ignore_sources)

    def matchLine(self, line: str) -> List[str]:
        """
        Returns offending IPs extracted from the line if:
          - no ignore regex matches; and
          - at least one failregex matches.

        IP extraction is performed by scanning the line for valid IPs (no capture group required).
        """
        s = _coerce_str(line)

        if not self._fail_patterns:
            return []

        for ign in self._ignore_patterns:
            if ign.search(s):
                return []

        for fr in self._fail_patterns:
            if fr.search(s):
                return findAllIP(s)

        return []
</file>

<file:name=fail2ban/server/jail.py>
from __future__ import annotations

from typing import List, Optional, Any


class Jail:
    """
    Minimal jail that coordinates a filter and actions.
    No banning, no daemon behavior; just offline matching.
    """

    def __init__(self, name: str, *, filter=None, actions=None, backend: str | None = None):
        self._name = str(name)
        self._filter = None
        self._actions: List[Any] = []
        self._backend = backend  # accepted for compatibility; ignored

        if filter is not None:
            self.setFilter(filter)
        if actions:
            for a in list(actions):
                self.addAction(a)

    def getName(self) -> str:
        return self._name

    def setFilter(self, filter_obj) -> None:
        self._filter = filter_obj

    def getFilter(self):
        return self._filter

    def addAction(self, action_obj) -> None:
        self._actions.append(action_obj)

    def getActions(self) -> list:
        return list(self._actions)

    def processLine(self, line: str) -> List[str]:
        """
        Return list of IP strings that the filter considers a failure for this line.
        No banning performed.
        """
        if self._filter is None:
            return []

        match_fn = getattr(self._filter, "matchLine", None)
        if callable(match_fn):
            try:
                res = match_fn(line)
            except Exception:
                # Keep deterministic, safe behavior: filter errors mean "no match".
                return []
            if res is None:
                return []
            return list(res)

        return []

    def findFailure(self, line: str) -> List[str]:
        return self.processLine(line)

    def __repr__(self) -> str:
        f = self._filter.__class__.__name__ if self._filter is not None else None
        return f"Jail(name={self._name!r}, filter={f!r}, actions={len(self._actions)}, backend={self._backend!r})"
</file>

<file:name=bin/fail2ban-client>
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import sys


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="fail2ban-client",
        description="Offline, safe stub of fail2ban-client (no IPC/network/daemon).",
    )
    p.add_argument(
        "command",
        nargs="*",
        help="Command to simulate (e.g., status, ping). This stub does not connect to a server.",
    )
    return p


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    ns = parser.parse_args(argv)

    if not ns.command:
        # Mirror typical CLI behavior: show help if no args.
        parser.print_help(sys.stdout)
        return 0

    cmd = " ".join(ns.command)
    sys.stdout.write(
        "fail2ban-client (offline stub): no server connection is performed.\n"
        f"Received command: {cmd}\n"
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file:name=bin/fail2ban-server>
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import sys


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="fail2ban-server",
        description="Offline, safe stub of fail2ban-server (does not daemonize or listen).",
    )
    p.add_argument(
        "--version",
        action="store_true",
        help="Print version information (stub).",
    )
    p.add_argument(
        "--foreground",
        action="store_true",
        help="Accepted for compatibility; no effect in stub.",
    )
    p.add_argument(
        "--conf",
        help="Accepted for compatibility; not used by stub.",
    )
    return p


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    ns = parser.parse_args(argv)

    if ns.version:
        sys.stdout.write("fail2ban-server (offline stub) 0.1.0\n")
        return 0

    sys.stdout.write(
        "fail2ban-server (offline stub): no daemon is started, no sockets are opened.\n"
        "Use fail2ban-regex for offline log/regex checks.\n"
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file:name=bin/fail2ban-regex>
#!/usr/bin/env python3
from __future__ import annotations

import argparse
import sys
from pathlib import Path

from fail2ban.server.filter import RegexFilter


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="fail2ban-regex",
        description="Offline regex checker (safe subset). Matches regex(es) against a log file and extracts IPs.",
    )
    p.add_argument("logfile", help="Path to a log file to read (text).")
    p.add_argument("regex", nargs="+", help="One or more regex patterns (failregex).")
    p.add_argument(
        "-i",
        "--ignore",
        action="append",
        default=[],
        help="Ignore regex (may be supplied multiple times). If any matches a line, that line is ignored.",
    )
    return p


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    ns = parser.parse_args(argv)

    path = Path(ns.logfile)
    if not path.exists() or not path.is_file():
        sys.stderr.write(f"fail2ban-regex: error: logfile not found: {ns.logfile}\n")
        return 2

    try:
        rf = RegexFilter(failregex=[], ignoreregex=ns.ignore or [])
        for pat in ns.regex:
            rf.addFailRegex(pat)
    except ValueError as e:
        sys.stderr.write(f"fail2ban-regex: error: {e}\n")
        return 2

    total_lines = 0
    matched_lines = 0
    all_ips: list[str] = []

    with path.open("r", encoding="utf-8", errors="replace") as f:
        for line in f:
            total_lines += 1
            ips = rf.matchLine(line.rstrip("\n"))
            if ips:
                matched_lines += 1
                all_ips.extend(ips)

    unique_ips = []
    seen = set()
    for ip in all_ips:
        if ip not in seen:
            seen.add(ip)
            unique_ips.append(ip)

    sys.stdout.write(f"Lines: {total_lines}\n")
    sys.stdout.write(f"Matched lines: {matched_lines}\n")
    sys.stdout.write(f"Total IP matches: {len(all_ips)}\n")
    sys.stdout.write(f"Unique IPs: {len(unique_ips)}\n")
    if unique_ips:
        sys.stdout.write("IPs:\n")
        for ip in unique_ips:
            sys.stdout.write(f"  {ip}\n")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file:name=config/jail.conf>
[DEFAULT]
# Minimal, parseable configuration placeholder for tests.
# This file is not used to control any real system services in this benchmark.
bantime = 600
findtime = 600
maxretry = 5
backend = auto

[sshd]
enabled = false
port = ssh
logpath = ./example-auth.log
filter = sshd
action = dummy
</file>

<file:name=pyproject.toml>
[build-system]
requires = ["setuptools>=61"]
build-backend = "setuptools.build_meta"

[project]
name = "fail2ban-minimal"
version = "0.1.0"
description = "Minimal, safe-to-evaluate subset of Fail2Ban for offline regex matching."
requires-python = ">=3.10"
dependencies = []

[tool.setuptools]
include-package-data = true

[tool.setuptools.packages.find]
include = ["fail2ban*"]
</file>