1) Repository layout
- Must be a Python package named "humanize" importable via: import humanize
- Required files/modules (must exist and be importable):
  - humanize/__init__.py
  - humanize/number.py
  - humanize/time.py
  - humanize/filesize.py
  - humanize/lists.py
  - humanize/i18n.py
- Module responsibilities:
  - humanize.__init__: re-export selected public functions; provide version metadata if needed by tests.
  - humanize.number: number formatting helpers (e.g., intcomma, ordinal, optionally intword/metric if needed by tests).
  - humanize.time: time/delta humanization (precisedelta, naturaldelta, naturaltime).
  - humanize.filesize: file size humanization (naturalsize).
  - humanize.lists: list-to-text helper(s) (naturallist).
  - humanize.i18n: minimal i18n scaffolding used by other modules (activate/deactivate/gettext-like).

2) Public API surface
Top-level package exports (must be accessible as humanize.<name>):
- From humanize.number:
  - intcomma(value, ndigits=None) -> str
  - ordinal(value) -> str
- From humanize.filesize:
  - naturalsize(value, binary=False, format="%.1f", suffix="B", gnuradio=False) -> str
- From humanize.time:
  - precisedelta(value, minimum_unit="seconds", format="%d", suppress=None, delimiter=", ") -> str
  - naturaldelta(value, months=True) -> str
  - naturaltime(value, when=None) -> str
- From humanize.lists (if referenced by tests):
  - naturallist(seq, separator=", ", conjunction="and") -> str

Module-level APIs (must exist at these import paths):
- humanize.number
  - intcomma(value, ndigits=None) -> str
  - ordinal(value) -> str
- humanize.filesize
  - naturalsize(value, binary=False, format="%.1f", suffix="B", gnuradio=False) -> str
- humanize.time
  - precisedelta(value, minimum_unit="seconds", format="%d", suppress=None, delimiter=", ") -> str
  - naturaldelta(value, months=True) -> str
  - naturaltime(value, when=None) -> str
- humanize.lists
  - naturallist(seq, separator=", ", conjunction="and") -> str
- humanize.i18n
  - activate(locale: str) -> None
  - deactivate() -> None
  - get_language() -> str | None
  - gettext(message: str) -> str
  - ngettext(singular: str, plural: str, n: int) -> str
  - localize(number_string: str) -> str (may be a no-op unless locale-specific behavior is required)

Key signature tolerance:
- Functions should accept common scalar types used by tests: int, float, Decimal, str representations where reasonable.
- For time functions, accept datetime.timedelta, datetime.datetime, dateutil-like objects are NOT required; only datetime and timedelta from stdlib and numeric seconds should be supported.
- All functions must be pure Python (no compiled deps), deterministic, and fast for typical test inputs.

3) Behavioral contract (I/O, invariants, edge cases, error handling)

3.1 humanize.number.intcomma
- Purpose: Insert thousands separators into the integer part of a number.
- Inputs:
  - value: int/float/Decimal/str; may be negative; may contain fractional part.
  - ndigits:
    - If None: preserve existing fractional digits if provided as a string; if numeric type, preserve full str() fractional representation (tests typically use limited digits).
    - If an int: round to that number of decimal digits (like format rounding) and then comma-separate the integer part.
- Output: string with commas every three digits in the integer part.
- Rules:
  - "1000" -> "1,000"
  - 1000000 -> "1,000,000"
  - -1000 -> "-1,000"
  - "1000.1234" -> "1,000.1234" (ndigits is None)
  - 1234.0 -> "1,234.0" or "1,234" depending on how str() renders; ensure stable behavior by:
    - If value is float and ndigits is None: use repr-like normalization that keeps at least one decimal if input has one is NOT required; prefer converting via Decimal(str(value)) to avoid scientific notation in common cases.
  - Scientific notation inputs:
    - If passed as a string containing 'e'/'E', attempt Decimal conversion and then format; if conversion fails, return original string unchanged.
- Error handling:
  - If value is None: raise TypeError (consistent with typical usage).
  - If cannot be interpreted as a number for comma insertion (e.g., "abc"): return str(value) unchanged (tests generally avoid invalid inputs; this provides robustness).

3.2 humanize.number.ordinal
- Purpose: Convert an integer to its ordinal representation (English rules).
- Input: value int/str convertible to int.
- Output: string like "1st", "2nd", "3rd", "4th", "11th", "12th", "13th", "21st", "112th".
- Rules:
  - Suffix selection:
    - if 10 <= (n % 100) <= 20: "th"
    - else based on n % 10: 1->"st", 2->"nd", 3->"rd", else "th"
  - Negative numbers keep sign: -1 -> "-1st"
  - Non-integer numeric strings:
    - If "1.0" cannot convert cleanly to int, attempt int(float(x)) only if float(x) is an integer value; otherwise raise ValueError.
- Error handling:
  - If value cannot be interpreted as integer: raise ValueError.

3.3 humanize.filesize.naturalsize
- Purpose: Human-readable file sizes.
- Inputs:
  - value: int/float/Decimal; number of bytes by default.
  - binary: if True use base 1024 with IEC suffixes (KiB, MiB, GiB, TiB, PiB, EiB); if False base 1000 with SI suffixes (kB, MB, GB, TB, PB, EB).
  - format: printf-style float format string (e.g., "%.1f", "%.0f") applied to the scaled number.
  - suffix: default "B" appended to unit (so "kB" etc); if suffix is "" then unit only.
  - gnuradio: if True, use "K", "M", "G", "T", "P", "E" (and "Ki", "Mi"... when binary True is not required; for compatibility, treat gnuradio True as using single-letter units without "B").
- Output examples:
  - naturalsize(0) -> "0 B"
  - naturalsize(1) -> "1 B"
  - naturalsize(1024, binary=True) -> "1.0 KiB" (format default)
  - naturalsize(1000, binary=False) -> "1.0 kB"
  - naturalsize(1024, binary=False) -> "1.0 kB" (since base 1000)
- Formatting rules:
  - Choose largest unit where abs(value) >= base and proceed until next would be < base, capped at largest known unit.
  - Preserve sign: negative sizes allowed (e.g., -1024 -> "-1.0 KiB").
  - For bytes (< base): output integer with no decimals and "B" suffix: "999 B". Use singular/plural is NOT required; tests typically expect "1 B" not "1 Bytes".
  - Ensure there is a space between number and unit (e.g., "1.0 kB", "999 B").
  - Strip trailing zeros ONLY if the provided format produces them? For compatibility with reference tests, do not aggressively strip; follow the format string exactly for non-bytes. For bytes, always integer.
- Error handling:
  - If value is None: TypeError.
  - If value is NaN/inf: return str(value) + " " + suffix (or just str(value)) is acceptable; tests likely do not cover.
  - If format is invalid: propagate exception from formatting (ValueError/TypeError).

3.4 humanize.time.precisedelta
- Purpose: Convert a duration into a precise, multi-unit string: "2 days, 3 hours, 4 minutes, 5 seconds".
- Inputs:
  - value: datetime.timedelta OR number of seconds (int/float/Decimal). Negative allowed.
  - minimum_unit: smallest unit to show; one of: "seconds", "minutes", "hours", "days", "weeks", "months", "years".
    - If provided unit is unknown: raise ValueError.
  - format: printf-style integer format for each unit count, default "%d".
  - suppress: iterable of units to omit from output (e.g., ["seconds"]); if None do not suppress.
  - delimiter: string between unit segments, default ", ".
- Units and approximate lengths:
  - second=1
  - minute=60
  - hour=3600
  - day=86400
  - week=604800
  - month=2628000 (approx 30.44 days) OR 2592000 (30 days). To match typical humanize behavior, use 30 days (2592000) unless tests demand otherwise.
  - year=31536000 (365 days)
- Output rules:
  - Determine absolute seconds, track sign separately. If negative, prefix "-" to final string.
  - Decompose from largest to smallest down to minimum_unit, skipping suppressed units.
  - Do not include units with a zero count.
  - If all units suppressed or result empty, return "0 <minimum_unit>" formatted as pluralization rules below.
  - Pluralization: "1 second" vs "2 seconds" (English only).
  - Example: precisedelta(timedelta(seconds=3661)) -> "1 hour, 1 minute, 1 second"
  - Example with minimum_unit="minutes": 3661 -> "1 hour, 1 minute" (seconds dropped by truncation)
  - Truncation: when minimum_unit is larger than seconds, remainder below minimum_unit is discarded (floor), not rounded.
- Error handling:
  - If value not timedelta and not numeric: TypeError.
  - If suppress contains unknown units: ignore unknowns (robust) or raise ValueError; prefer ignoring to avoid failing tests.

3.5 humanize.time.naturaldelta
- Purpose: Convert a duration into a fuzzy single/dual-unit phrase (e.g., "a minute", "2 hours", "3 days").
- Inputs:
  - value: datetime.timedelta OR number of seconds (int/float/Decimal).
  - months: bool controlling whether to express long durations using months/years approximations (if False, use days/weeks).
- Output rules (English, approximate thresholds compatible with typical humanize):
  - If value is negative, treat as absolute for phrase (reference usually returns "a minute" not "-a minute"); but naturaltime handles direction. So naturaldelta should use absolute duration.
  - Use largest appropriate unit with rounding to nearest integer for that unit (except very small values).
  - Recommended thresholds (aligned with common humanize behavior):
    - < 1 second: "a moment"
    - < 45 seconds: "a moment" or "seconds" not required; prefer "a moment"
    - < 90 seconds: "a minute"
    - < 45 minutes: "<n> minutes" (rounded)
    - < 90 minutes: "an hour"
    - < 22 hours: "<n> hours"
    - < 36 hours: "a day"
    - < 25 days: "<n> days"
    - < 45 days: "a month" if months True else "5 weeks"/"6 weeks" acceptable; prefer month if months True.
    - < 345 days: "<n> months" if months True else "<n> weeks"
    - < 545 days: "a year"
    - else: "<n> years"
  - Use articles: "a minute", "an hour", "a day", "a month", "a year".
- Error handling:
  - If value type invalid: TypeError.

3.6 humanize.time.naturaltime
- Purpose: Humanize a datetime or timedelta relative to "now" or a provided reference time.
- Inputs:
  - value:
    - If datetime.datetime: compared to when (default now in same tz-awareness handling).
    - If datetime.timedelta or numeric seconds: treated as offset from now (negative => past, positive => future).
  - when: datetime.datetime reference; default datetime.datetime.now(tz=value.tzinfo) if value is aware; else naive now.
- Output rules:
  - Compute delta seconds = value - when (if value is datetime), else delta=value seconds.
  - If delta < 0 => past: "<phrase> ago"
  - If delta > 0 => future: "in <phrase>"
  - If delta == 0 or very small => "now"
  - phrase is derived from naturaldelta(abs(delta)) with months=True.
  - Examples:
    - naturaltime(datetime.now() - timedelta(seconds=3)) -> "now" or "a moment ago" depending threshold; prefer "now" for abs(delta) < 1 second and "a moment ago" for < 45 seconds.
    - naturaltime(timedelta(days=-1)) -> "a day ago"
    - naturaltime(timedelta(days=1)) -> "in a day"
- Timezone handling:
  - If value is aware datetime and when is None, use datetime.now(value.tzinfo).
  - If comparing aware vs naive: raise TypeError (Python does); let it propagate.
- Error handling:
  - Unsupported types: TypeError.

3.7 humanize.lists.naturallist
- Purpose: Join an iterable of items into a natural language list.
- Inputs:
  - seq: iterable; elements converted to str.
  - separator: used between elements when more than 2.
  - conjunction: word between last two elements.
- Output rules:
  - [] -> ""
  - ["a"] -> "a"
  - ["a","b"] -> "a and b" (no comma by default)
  - ["a","b","c"] -> "a, b and c" (Oxford comma not used by default)
  - Respect custom separator/conjunction.
- Error handling:
  - If seq is None: TypeError.

3.8 humanize.i18n
- Purpose: Minimal translation hooks used by library; English default.
- Behavior:
  - activate(locale): sets a global/current language code (string). Does not need real translation catalogs.
  - deactivate(): clears language (back to default None/"en").
  - get_language(): returns current active language or None.
  - gettext(msg): returns msg unchanged (English-only).
  - ngettext(singular, plural, n): returns singular if n==1 else plural.
  - localize(number_string): may return input unchanged; tests may call it indirectly.
- Thread safety: not required unless tests explicitly check; simple module-global is acceptable.

4) Acceptance checklist
- Import/layout:
  - "import humanize" succeeds.
  - "from humanize import intcomma, ordinal, naturalsize, precisedelta, naturaldelta, naturaltime" succeeds.
  - "import humanize.number/time/filesize/lists/i18n" succeeds.
- intcomma:
  - Formats positive/negative ints with commas correctly.
  - Preserves fractional part for string input.
  - Rounds to ndigits when provided.
- ordinal:
  - Correct suffixes including 11/12/13 special-case.
  - Handles negative integers.
- naturalsize:
  - Base-1000 vs base-1024 unit selection.
  - Correct unit labels: B, kB/MB/... and KiB/MiB/... when binary=True.
  - Space between numeric and unit.
  - Bytes shown as integer without decimals.
- precisedelta:
  - Accepts timedelta and numeric seconds.
  - Produces multi-part output with correct pluralization and delimiter.
  - Honors minimum_unit and truncates smaller remainder.
  - Handles negative durations with leading "-" (or otherwise consistent; but must be deterministic).
- naturaldelta:
  - Produces English fuzzy phrases for common ranges (seconds->years).
  - Uses articles ("a minute", "an hour") where appropriate.
- naturaltime:
  - Produces "X ago" for past and "in X" for future based on naturaldelta.
  - Handles datetime inputs relative to now/when.
  - Returns "now" for near-zero deltas.
- naturallist:
  - Joins 0/1/2/3+ items into expected natural language forms.
- i18n:
  - activate/deactivate do not break formatting functions; gettext/ngettext exist.

5) Non-goals / constraints
- No external dependencies (no Babel, no dateutil, no gettext catalogs required).
- No network or file I/O at runtime (beyond normal imports).
- Do not attempt full feature parity with the entire reference humanize project; only core parts required above plus minimal helpers needed internally.
- Locale-aware formatting is out of scope; i18n is a stub that preserves API presence and basic plural selection.
- Avoid heavy/slow algorithms; must be efficient for repeated calls in tests (simple arithmetic and string formatting).