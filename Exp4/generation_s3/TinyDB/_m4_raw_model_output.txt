<file:name=tinydb/__init__.py>
"""A tiny, file-based JSON document database.

This repository provides a minimal subset of the TinyDB-like API tailored to the
contract in the task description.
"""

from .database import TinyDB
from .storages import JSONStorage
from .queries import Query, where
from .table import Document

__all__ = ["TinyDB", "JSONStorage", "Query", "where", "Document"]
</file>

<file:name=tinydb/storages.py>
from __future__ import annotations

import json
import os
from typing import Optional


class Storage:
    """Minimal storage interface."""

    def read(self) -> dict | None:  # pragma: no cover
        raise NotImplementedError

    def write(self, data: dict) -> None:  # pragma: no cover
        raise NotImplementedError

    def close(self) -> None:  # pragma: no cover
        raise NotImplementedError


class JSONStorage(Storage):
    """File-based JSON document store."""

    def __init__(
        self,
        path: str,
        *,
        create_dirs: bool = True,
        encoding: str = "utf-8",
    ) -> None:
        self.path = path
        self._encoding = encoding
        self._create_dirs = create_dirs
        self._closed = False

        if self._create_dirs:
            parent = os.path.dirname(os.path.abspath(self.path))
            if parent:
                os.makedirs(parent, exist_ok=True)

    def read(self) -> Optional[dict]:
        if self._closed:
            raise ValueError("Storage is closed")

        if not os.path.exists(self.path):
            return None

        # Consider empty file as no data
        try:
            if os.path.getsize(self.path) == 0:
                return None
        except OSError:
            return None

        with open(self.path, "r", encoding=self._encoding) as f:
            raw = f.read()
            if raw.strip() == "":
                return None
            data = json.loads(raw)  # may raise JSONDecodeError
            if not isinstance(data, dict):
                raise ValueError("Database file must contain a JSON object (dict).")
            return data

    def write(self, data: dict) -> None:
        if self._closed:
            raise ValueError("Storage is closed")
        if not isinstance(data, dict):
            raise TypeError("Storage.write expects a dict")

        if self._create_dirs:
            parent = os.path.dirname(os.path.abspath(self.path))
            if parent:
                os.makedirs(parent, exist_ok=True)

        # Simple overwrite is acceptable per contract.
        tmp_path = f"{self.path}.tmp"
        payload = json.dumps(data, ensure_ascii=False, indent=2, sort_keys=True)
        with open(tmp_path, "w", encoding=self._encoding) as f:
            f.write(payload)
            f.flush()
            os.fsync(f.fileno())
        os.replace(tmp_path, self.path)

    def close(self) -> None:
        self._closed = True
</file>

<file:name=tinydb/queries.py>
from __future__ import annotations

import re
from typing import Any, Callable, Iterable


_MISSING = object()


class Query:
    """
    Query objects are both:
      - path builders (where("a").b.c), and
      - predicates (callable) once an operation is applied.
    """

    def __init__(self, path: tuple[str, ...] = (), _predicate: Callable[[dict], bool] | None = None) -> None:
        self._path = tuple(path)
        self._predicate = _predicate

    # ----- Path building -----

    def __getattr__(self, item: str) -> "Query":
        if item.startswith("_"):
            raise AttributeError(item)
        return Query(self._path + (item,), None)

    def __getitem__(self, item: str) -> "Query":
        if not isinstance(item, str):
            raise TypeError("Query keys must be strings")
        if item.startswith("_"):
            raise AttributeError(item)
        return Query(self._path + (item,), None)

    # ----- Helpers -----

    def _resolve(self, document: dict) -> Any:
        cur: Any = document
        for key in self._path:
            if not isinstance(cur, dict) or key not in cur:
                return _MISSING
            cur = cur[key]
        return cur

    def _exists(self, document: dict) -> bool:
        cur: Any = document
        for key in self._path:
            if not isinstance(cur, dict) or key not in cur:
                return False
            cur = cur[key]
        return True

    def _with_predicate(self, pred: Callable[[dict], bool]) -> "Query":
        return Query(self._path, pred)

    # ----- Evaluation -----

    def __call__(self, document: dict) -> bool:
        if self._predicate is None:
            # A plain path builder is not a valid predicate.
            raise TypeError("Incomplete query: no operation specified")
        return bool(self._predicate(document))

    # ----- Comparisons -----

    def __eq__(self, other: Any) -> "Query":  # type: ignore[override]
        def pred(doc: dict) -> bool:
            v = self._resolve(doc)
            if v is _MISSING:
                return False
            return v == other

        return self._with_predicate(pred)

    def __ne__(self, other: Any) -> "Query":  # type: ignore[override]
        def pred(doc: dict) -> bool:
            v = self._resolve(doc)
            if v is _MISSING:
                return False
            return v != other

        return self._with_predicate(pred)

    def __lt__(self, other: Any) -> "Query":
        def pred(doc: dict) -> bool:
            v = self._resolve(doc)
            if v is _MISSING:
                return False
            try:
                return v < other
            except Exception:
                return False

        return self._with_predicate(pred)

    def __le__(self, other: Any) -> "Query":
        def pred(doc: dict) -> bool:
            v = self._resolve(doc)
            if v is _MISSING:
                return False
            try:
                return v <= other
            except Exception:
                return False

        return self._with_predicate(pred)

    def __gt__(self, other: Any) -> "Query":
        def pred(doc: dict) -> bool:
            v = self._resolve(doc)
            if v is _MISSING:
                return False
            try:
                return v > other
            except Exception:
                return False

        return self._with_predicate(pred)

    def __ge__(self, other: Any) -> "Query":
        def pred(doc: dict) -> bool:
            v = self._resolve(doc)
            if v is _MISSING:
                return False
            try:
                return v >= other
            except Exception:
                return False

        return self._with_predicate(pred)

    # ----- Additional operators -----

    def exists(self) -> "Query":
        def pred(doc: dict) -> bool:
            return self._exists(doc)

        return self._with_predicate(pred)

    def one_of(self, values: Iterable[Any]) -> "Query":
        # values can be list/set/tuple; we'll use "in"
        def pred(doc: dict) -> bool:
            v = self._resolve(doc)
            if v is _MISSING:
                return False
            return v in values

        return self._with_predicate(pred)

    def matches(self, pattern: str) -> "Query":
        rx = re.compile(pattern)

        def pred(doc: dict) -> bool:
            v = self._resolve(doc)
            if v is _MISSING or not isinstance(v, str):
                return False
            return rx.search(v) is not None

        return self._with_predicate(pred)

    def test(self, func: Callable[[Any], bool]) -> "Query":
        def pred(doc: dict) -> bool:
            v = self._resolve(doc)
            if v is _MISSING:
                # Contract allows passing None, but simplest is to call with None.
                v2 = None
            else:
                v2 = v
            try:
                return bool(func(v2))
            except Exception:
                return False

        return self._with_predicate(pred)

    # ----- Boolean composition -----

    def __and__(self, other: "Query") -> "Query":
        if not isinstance(other, Query):
            return NotImplemented  # type: ignore[return-value]

        def pred(doc: dict) -> bool:
            return bool(self(doc)) and bool(other(doc))

        return Query((), pred)

    def __or__(self, other: "Query") -> "Query":
        if not isinstance(other, Query):
            return NotImplemented  # type: ignore[return-value]

        def pred(doc: dict) -> bool:
            return bool(self(doc)) or bool(other(doc))

        return Query((), pred)

    def __invert__(self) -> "Query":
        def pred(doc: dict) -> bool:
            return not bool(self(doc))

        return Query((), pred)


def where(key: str) -> Query:
    if not isinstance(key, str):
        raise TypeError("where(key) expects a string key")
    if key.startswith("_"):
        raise AttributeError(key)
    return Query((key,), None)
</file>

<file:name=tinydb/database.py>
from __future__ import annotations

from typing import Any

from .storages import JSONStorage, Storage
from .table import Table


class TinyDB:
    def __init__(
        self,
        path: str,
        *,
        storage: type[Storage] = JSONStorage,
        default_table: str = "_default",
        **storage_kwargs: Any,
    ) -> None:
        self.storage: Storage = storage(path, **storage_kwargs)
        self.default_table_name: str = default_table
        self._closed = False
        self._tables: dict[str, Table] = {}

    def table(self, name: str) -> Table:
        if self._closed:
            raise ValueError("Database is closed")
        if not isinstance(name, str) or name == "":
            raise TypeError("Table name must be a non-empty string")
        t = self._tables.get(name)
        if t is None:
            t = Table(self, name)
            self._tables[name] = t
        return t

    def tables(self) -> set[str]:
        if self._closed:
            raise ValueError("Database is closed")
        data = self.storage.read() or {}
        return {k for k in data.keys() if k != "_meta"}

    def drop_tables(self) -> None:
        if self._closed:
            raise ValueError("Database is closed")
        self.storage.write({})
        self._tables.clear()

    def drop_table(self, name: str) -> None:
        if self._closed:
            raise ValueError("Database is closed")
        data = self.storage.read() or {}
        data.pop(name, None)
        meta = data.get("_meta")
        if isinstance(meta, dict):
            meta.pop(name, None)
            if meta == {}:
                # Keep empty meta if present; either is acceptable.
                data["_meta"] = meta
        self.storage.write(data)
        self._tables.pop(name, None)

    def close(self) -> None:
        if not self._closed:
            self.storage.close()
            self._closed = True

    def __enter__(self) -> "TinyDB":
        return self

    def __exit__(self, exc_type, exc, tb) -> None:
        self.close()
</file>

<file:name=tinydb/table.py>
from __future__ import annotations

from copy import deepcopy
from typing import Any, Callable, Iterable

from .queries import Query


class Document(dict):
    def __init__(self, value: dict, doc_id: int) -> None:
        if not isinstance(value, dict):
            raise TypeError("Document value must be a dict")
        super().__init__(value)
        self._doc_id = int(doc_id)

    @property
    def doc_id(self) -> int:
        return self._doc_id


class Table:
    def __init__(self, db: Any, name: str) -> None:
        self._db = db
        self._name = name

    @property
    def name(self) -> str:
        return self._name

    # ----- Internal helpers -----

    def _read_db(self) -> dict:
        data = self._db.storage.read()
        return data or {}

    def _write_db(self, data: dict) -> None:
        self._db.storage.write(data)

    def _ensure_table_structures(self, data: dict) -> tuple[dict, dict]:
        table = data.get(self._name)
        if not isinstance(table, dict):
            table = {}
            data[self._name] = table

        meta = data.get("_meta")
        if not isinstance(meta, dict):
            meta = {}
            data["_meta"] = meta
        tmeta = meta.get(self._name)
        if not isinstance(tmeta, dict):
            tmeta = {"last_id": 0}
            meta[self._name] = tmeta
        if "last_id" not in tmeta or not isinstance(tmeta.get("last_id"), int):
            tmeta["last_id"] = int(tmeta.get("last_id") or 0)

        return table, tmeta

    def _iter_docs_sorted(self, table: dict) -> Iterable[tuple[int, dict]]:
        items: list[tuple[int, dict]] = []
        for k, v in table.items():
            try:
                doc_id = int(k)
            except Exception:
                continue
            if isinstance(v, dict):
                items.append((doc_id, v))
        items.sort(key=lambda x: x[0])
        return items

    def _select_doc_ids(self, data: dict, cond: Query | None, doc_ids: list[int] | None) -> list[int]:
        if cond is None and doc_ids is None:
            raise ValueError("Either cond or doc_ids must be provided")
        if cond is not None and doc_ids is not None:
            raise ValueError("Provide either cond or doc_ids, not both")

        table, _tmeta = self._ensure_table_structures(data)

        if doc_ids is not None:
            # Keep order stable (ascending) and ignore missing later.
            wanted = sorted({int(i) for i in doc_ids})
            return wanted

        # cond selection
        selected: list[int] = []
        for doc_id, doc in self._iter_docs_sorted(table):
            if cond(doc):
                selected.append(doc_id)
        return selected

    # ----- CRUD -----

    def insert(self, document: dict) -> int:
        if not isinstance(document, dict):
            raise TypeError("insert expects a dict")

        data = self._read_db()
        table, tmeta = self._ensure_table_structures(data)

        next_id = int(tmeta.get("last_id", 0)) + 1
        tmeta["last_id"] = next_id
        table[str(next_id)] = deepcopy(document)

        self._write_db(data)
        return next_id

    def insert_multiple(self, documents: list[dict]) -> list[int]:
        if not isinstance(documents, list):
            raise TypeError("insert_multiple expects a list of dicts")
        for d in documents:
            if not isinstance(d, dict):
                raise TypeError("insert_multiple expects a list of dicts")

        data = self._read_db()
        table, tmeta = self._ensure_table_structures(data)

        last = int(tmeta.get("last_id", 0))
        ids: list[int] = []
        for d in documents:
            last += 1
            table[str(last)] = deepcopy(d)
            ids.append(last)
        tmeta["last_id"] = last

        self._write_db(data)
        return ids

    def get(self, *, doc_id: int | None = None, cond: Query | None = None) -> Document | None:
        if doc_id is not None and cond is not None:
            raise ValueError("Provide either doc_id or cond, not both")
        if doc_id is None and cond is None:
            raise ValueError("Either doc_id or cond must be provided")

        data = self._read_db()
        table = data.get(self._name)
        if not isinstance(table, dict):
            return None

        if doc_id is not None:
            raw = table.get(str(int(doc_id)))
            if isinstance(raw, dict):
                return Document(deepcopy(raw), int(doc_id))
            return None

        # cond
        for did, raw in self._iter_docs_sorted(table):
            if cond(raw):
                return Document(deepcopy(raw), did)
        return None

    def all(self) -> list[Document]:
        data = self._read_db()
        table = data.get(self._name)
        if not isinstance(table, dict):
            return []
        return [Document(deepcopy(doc), doc_id) for doc_id, doc in self._iter_docs_sorted(table)]

    def search(self, cond: Query) -> list[Document]:
        data = self._read_db()
        table = data.get(self._name)
        if not isinstance(table, dict):
            return []
        out: list[Document] = []
        for doc_id, doc in self._iter_docs_sorted(table):
            if cond(doc):
                out.append(Document(deepcopy(doc), doc_id))
        return out

    def contains(self, *, doc_id: int | None = None, cond: Query | None = None) -> bool:
        if doc_id is None and cond is None:
            raise ValueError("Either doc_id or cond must be provided")
        return self.get(doc_id=doc_id, cond=cond) is not None

    def update(
        self,
        fields: dict | Callable[[dict], Any],
        cond: Query | None = None,
        *,
        doc_ids: list[int] | None = None,
    ) -> list[int]:
        data = self._read_db()
        table, _tmeta = self._ensure_table_structures(data)

        selected = self._select_doc_ids(data, cond, doc_ids)
        updated: list[int] = []

        for did in selected:
            key = str(int(did))
            if key not in table or not isinstance(table.get(key), dict):
                continue
            current = table[key]
            new_doc = deepcopy(current)

            if isinstance(fields, dict):
                new_doc.update(fields)
            elif callable(fields):
                # Allow in-place mutation and/or return dict of updates.
                maybe_updates = fields(new_doc)
                if isinstance(maybe_updates, dict):
                    new_doc.update(maybe_updates)
            else:
                raise TypeError("update fields must be a dict or callable")

            table[key] = new_doc
            updated.append(int(did))

        self._write_db(data)
        return sorted(updated)

    def remove(
        self,
        cond: Query | None = None,
        *,
        doc_ids: list[int] | None = None,
    ) -> list[int]:
        data = self._read_db()
        table, _tmeta = self._ensure_table_structures(data)

        selected = self._select_doc_ids(data, cond, doc_ids)
        removed: list[int] = []

        for did in selected:
            key = str(int(did))
            if key in table:
                del table[key]
                removed.append(int(did))

        self._write_db(data)
        return sorted(removed)

    def truncate(self) -> None:
        data = self._read_db()
        table, tmeta = self._ensure_table_structures(data)
        table.clear()
        tmeta["last_id"] = 0
        self._write_db(data)

    def count(self, cond: Query) -> int:
        return len(self.search(cond))
</file>