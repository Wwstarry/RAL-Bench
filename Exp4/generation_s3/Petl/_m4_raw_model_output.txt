<file:name=petl/__init__.py>
"""
A lightweight, pure-Python subset of the petl API.

This package provides lazy table semantics: all transformation functions return
iterables that only evaluate their inputs when iterated.

Only a small set of functions are implemented to satisfy the accompanying test
suite; this is not the full petl project.
"""

from .io.csv import fromcsv, tocsv
from .transform.conversions import convert
from .transform.selects import select, selectge, selectgt, addfield
from .transform.sort import sort
from .transform.joins import join

__all__ = [
    "fromcsv",
    "tocsv",
    "fromdicts",
    "convert",
    "select",
    "selectge",
    "selectgt",
    "sort",
    "addfield",
    "join",
]


class DictsView:
    """Lazy table view over an iterable of dict-like records."""

    def __init__(self, records, header=None):
        self._records = records
        self._header = list(header) if header is not None else None

    def __iter__(self):
        it = iter(self._records)

        if self._header is None:
            # Derive header deterministically from first record encountered.
            try:
                first = next(it)
            except StopIteration:
                return
                yield  # pragma: no cover
            header = list(getattr(first, "keys")())
            yield tuple(header)
            yield tuple(first.get(f) for f in header)
            for rec in it:
                yield tuple(rec.get(f) for f in header)
        else:
            header = list(self._header)
            yield tuple(header)
            for rec in it:
                yield tuple(rec.get(f) for f in header)


def fromdicts(records, header=None):
    """Create a lazy table from an iterable of dict-like objects."""
    return DictsView(records, header=header)
</file>

<file:name=petl/io/csv.py>
import csv


class CSVView:
    """Lazy table reading from a CSV file; re-iterable by reopening the file."""

    def __init__(self, path, reader_kwargs=None):
        self.path = path
        self.reader_kwargs = dict(reader_kwargs or {})

    def __iter__(self):
        # Lazily open/read on iteration.
        with open(self.path, "r", newline="") as f:
            rdr = csv.reader(f, **self.reader_kwargs)
            for row in rdr:
                # Return tuples for immutability and predictable behavior.
                yield tuple(row)


def fromcsv(path, **kwargs):
    """
    Read a CSV file lazily and return a table (iterable of rows).
    kwargs are forwarded to csv.reader.
    """
    return CSVView(path, reader_kwargs=kwargs)


def tocsv(table, path, **kwargs):
    """
    Write a table to a CSV file.
    kwargs are forwarded to csv.writer.
    """
    with open(path, "w", newline="") as f:
        w = csv.writer(f, **kwargs)
        for row in table:
            w.writerow(list(row) if not isinstance(row, (list, tuple)) else row)
</file>

<file:name=petl/transform/conversions.py>
def _resolve_field_index(header, field):
    if isinstance(field, int):
        if field < 0 or field >= len(header):
            raise IndexError(field)
        return field
    try:
        return header.index(field)
    except ValueError:
        raise KeyError(field)


class ConvertView:
    def __init__(self, table, field, func):
        self.table = table
        self.field = field
        self.func = func

    def __iter__(self):
        it = iter(self.table)
        try:
            header = next(it)
        except StopIteration:
            return
            yield  # pragma: no cover

        header = tuple(header)
        yield header

        idx = _resolve_field_index(header, self.field)

        for row in it:
            row = list(row)
            row[idx] = self.func(row[idx])
            yield tuple(row)


def convert(table, field, func):
    """Apply func(value) to every data cell in the specified field."""
    return ConvertView(table, field, func)
</file>

<file:name=petl/transform/selects.py>
def _resolve_field_index(header, field):
    if isinstance(field, int):
        if field < 0 or field >= len(header):
            raise IndexError(field)
        return field
    try:
        return header.index(field)
    except ValueError:
        raise KeyError(field)


class SelectView:
    def __init__(self, table, predicate):
        self.table = table
        self.predicate = predicate

    def __iter__(self):
        it = iter(self.table)
        try:
            header = next(it)
        except StopIteration:
            return
            yield  # pragma: no cover

        yield tuple(header)

        for row in it:
            row_t = tuple(row)
            if self.predicate(row_t):
                yield row_t


def select(table, predicate):
    """Filter rows using predicate(row) applied to data rows."""
    return SelectView(table, predicate)


class SelectCompareView:
    def __init__(self, table, field, threshold, op):
        self.table = table
        self.field = field
        self.threshold = threshold
        self.op = op

    def __iter__(self):
        it = iter(self.table)
        try:
            header = next(it)
        except StopIteration:
            return
            yield  # pragma: no cover

        header = tuple(header)
        yield header

        idx = _resolve_field_index(header, self.field)
        thr = self.threshold
        op = self.op

        for row in it:
            row_t = tuple(row)
            if op(row_t[idx], thr):
                yield row_t


def selectge(table, field, threshold):
    """Keep rows where row[field] >= threshold."""
    return SelectCompareView(table, field, threshold, op=lambda a, b: a >= b)


def selectgt(table, field, threshold):
    """Keep rows where row[field] > threshold."""
    return SelectCompareView(table, field, threshold, op=lambda a, b: a > b)


class AddFieldView:
    def __init__(self, table, fieldname, func):
        self.table = table
        self.fieldname = fieldname
        self.func = func

    def __iter__(self):
        it = iter(self.table)
        try:
            header = next(it)
        except StopIteration:
            return
            yield  # pragma: no cover

        header = list(header)
        header.append(self.fieldname)
        yield tuple(header)

        for row in it:
            row_t = tuple(row)
            newval = self.func(row_t)
            yield tuple(list(row_t) + [newval])


def addfield(table, fieldname, func):
    """Append a new field computed as func(row) for each data row."""
    return AddFieldView(table, fieldname, func)
</file>

<file:name=petl/transform/sort.py>
def _resolve_field_index(header, field):
    if isinstance(field, int):
        if field < 0 or field >= len(header):
            raise IndexError(field)
        return field
    try:
        return header.index(field)
    except ValueError:
        raise KeyError(field)


class SortView:
    def __init__(self, table, field):
        self.table = table
        self.field = field

    def __iter__(self):
        it = iter(self.table)
        try:
            header = next(it)
        except StopIteration:
            return
            yield  # pragma: no cover

        header = tuple(header)
        yield header

        idx = _resolve_field_index(header, self.field)
        rows = [tuple(r) for r in it]
        rows.sort(key=lambda r: r[idx])
        for r in rows:
            yield r


def sort(table, field):
    """Sort data rows by a given field (name or index)."""
    return SortView(table, field)
</file>

<file:name=petl/transform/joins.py>
def _resolve_field_index(header, field):
    if isinstance(field, int):
        if field < 0 or field >= len(header):
            raise IndexError(field)
        return field
    try:
        return header.index(field)
    except ValueError:
        raise KeyError(field)


class JoinView:
    """
    Inner equi-join on a single key field.

    Indexes the right table (materialized) and streams the left table.
    """

    def __init__(self, left, right, key="id"):
        self.left = left
        self.right = right
        self.key = key

    def __iter__(self):
        lit = iter(self.left)
        rit = iter(self.right)

        try:
            lhdr = next(lit)
        except StopIteration:
            return
            yield  # pragma: no cover
        try:
            rhdr = next(rit)
        except StopIteration:
            return
            yield  # pragma: no cover

        lhdr = tuple(lhdr)
        rhdr = tuple(rhdr)

        lk = _resolve_field_index(lhdr, self.key)
        rk = _resolve_field_index(rhdr, self.key)

        # Build output header: left header + right header excluding right key.
        out_hdr = list(lhdr) + [f for i, f in enumerate(rhdr) if i != rk]
        yield tuple(out_hdr)

        # Index right side by key value -> list of right rows
        r_index = {}
        for r in rit:
            rt = tuple(r)
            k = rt[rk]
            r_index.setdefault(k, []).append(rt)

        # Stream left; for each match on right, emit combined row.
        for l in lit:
            lt = tuple(l)
            k = lt[lk]
            matches = r_index.get(k)
            if not matches:
                continue
            for rt in matches:
                combined = list(lt) + [v for i, v in enumerate(rt) if i != rk]
                yield tuple(combined)


def join(left, right, key="id"):
    """Inner join left and right tables on key (name or index)."""
    return JoinView(left, right, key=key)
</file>