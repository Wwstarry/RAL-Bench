<file:name=cmd2/__init__.py>
"""
Lightweight, pure-Python subset of the cmd2 project.

This package provides enough API compatibility for educational use and for
black-box tests expecting core cmd2 behaviors.
"""

from .cmd2 import Cmd2, Cmd2ArgumentParser, Statement, Cmd2Error
from . import parsing, utils

__all__ = [
    "Cmd2",
    "Cmd2ArgumentParser",
    "Statement",
    "Cmd2Error",
    "parsing",
    "utils",
]
</file>

<file:name=cmd2/utils.py>
import contextlib
import io
import os
import re
import sys
from dataclasses import dataclass
from typing import Iterable, List, Optional, TextIO


ANSI_RE = re.compile(r"\x1b\[[0-9;]*m")


def strip_ansi(text: str) -> str:
    return ANSI_RE.sub("", text)


def normalize_line_endings(text: str) -> str:
    return text.replace("\r\n", "\n").replace("\r", "\n")


def splitlines_preserve_trailing(text: str) -> List[str]:
    text = normalize_line_endings(text)
    if text == "":
        return []
    if text.endswith("\n"):
        return text[:-1].split("\n") + [""]
    return text.split("\n")


@contextlib.contextmanager
def redirect_stdout(target: TextIO):
    old = sys.stdout
    sys.stdout = target
    try:
        yield target
    finally:
        sys.stdout = old


@contextlib.contextmanager
def redirect_stderr(target: TextIO):
    old = sys.stderr
    sys.stderr = target
    try:
        yield target
    finally:
        sys.stderr = old


@contextlib.contextmanager
def capture_output(merge_stderr: bool = False):
    buf = io.StringIO()
    if merge_stderr:
        with redirect_stdout(buf), redirect_stderr(buf):
            yield buf
    else:
        with redirect_stdout(buf):
            yield buf


def is_blank_line(line: str) -> bool:
    return strip_ansi(line).strip() == ""


@dataclass
class TranscriptResult:
    matched: bool
    expected: List[str]
    got: List[str]
    message: str = ""


def _read_text_file(path: str, encoding: str = "utf-8") -> str:
    with open(path, "r", encoding=encoding) as f:
        return f.read()


def _write_text_file(path: str, text: str, encoding: str = "utf-8") -> None:
    os.makedirs(os.path.dirname(os.path.abspath(path)), exist_ok=True)
    with open(path, "w", encoding=encoding) as f:
        f.write(text)


def compare_transcript(expected_text: str, got_text: str, *, strip_colors: bool = True) -> TranscriptResult:
    exp = normalize_line_endings(expected_text)
    got = normalize_line_endings(got_text)

    if strip_colors:
        exp = strip_ansi(exp)
        got = strip_ansi(got)

    exp_lines = exp.splitlines()
    got_lines = got.splitlines()

    if exp_lines == got_lines:
        return TranscriptResult(True, exp_lines, got_lines, "")

    # Find first mismatch for a useful message
    max_len = max(len(exp_lines), len(got_lines))
    idx = 0
    for i in range(max_len):
        e = exp_lines[i] if i < len(exp_lines) else None
        g = got_lines[i] if i < len(got_lines) else None
        if e != g:
            idx = i
            break

    message = f"Transcript mismatch at line {idx+1}: expected={exp_lines[idx] if idx < len(exp_lines) else '<EOF>'!r}, got={got_lines[idx] if idx < len(got_lines) else '<EOF>'!r}"
    return TranscriptResult(False, exp_lines, got_lines, message)


def parse_transcript(transcript_text: str, *, prompt: str = "(Cmd) ") -> List[str]:
    """
    Parse a transcript into a list of input command lines.

    Expected transcript format is compatible with a common cmd2 transcript style:
      (Cmd) command args
      output...
      (Cmd) another_command

    Only lines beginning with the prompt are treated as command lines; the prompt
    itself is stripped.
    """
    transcript_text = normalize_line_endings(transcript_text)
    cmds: List[str] = []
    for line in transcript_text.splitlines():
        if line.startswith(prompt):
            cmds.append(line[len(prompt) :])
    return cmds


def run_transcript(
    app,
    transcript_text: str,
    *,
    prompt: Optional[str] = None,
    strip_colors: bool = True,
    raise_on_failure: bool = True,
):
    """
    Run commands from transcript_text through app and compare against transcript_text.

    This uses the same prompt string used by app (or an override).
    """
    use_prompt = prompt if prompt is not None else getattr(app, "prompt", "(Cmd) ")
    commands = parse_transcript(transcript_text, prompt=use_prompt)

    out_buf = io.StringIO()
    # Simulate transcript: echo prompts + commands, then capture output lines in between.
    for cmd in commands:
        out_buf.write(f"{use_prompt}{cmd}\n")
        # Run and capture output of the command.
        with capture_output(merge_stderr=True) as buf:
            app.onecmd_plus_hooks(cmd)
        out = buf.getvalue()
        if out:
            out_buf.write(out)
            if not out.endswith("\n"):
                out_buf.write("\n")

    got_text = out_buf.getvalue().rstrip("\n") + "\n"
    exp_text = transcript_text.rstrip("\n") + "\n"

    res = compare_transcript(exp_text, got_text, strip_colors=strip_colors)
    if (not res.matched) and raise_on_failure:
        raise AssertionError(res.message)
    return res


__all__ = [
    "strip_ansi",
    "normalize_line_endings",
    "capture_output",
    "compare_transcript",
    "parse_transcript",
    "run_transcript",
    "TranscriptResult",
]
</file>

<file:name=cmd2/parsing.py>
import argparse
import shlex
from dataclasses import dataclass
from typing import Any, List, Optional, Sequence, Tuple


@dataclass
class Statement:
    raw: str
    command: str = ""
    args: str = ""
    arg_list: List[str] = None

    def __post_init__(self):
        if self.arg_list is None:
            self.arg_list = []


class Cmd2ArgumentParser(argparse.ArgumentParser):
    """
    Minimal compatibility wrapper around argparse.ArgumentParser used by cmd2.

    Differences from argparse:
    - Raises ValueError (or Cmd2ArgumentError) instead of exiting on error.
    """

    def __init__(self, *args, **kwargs):
        self._cmd2_silent = kwargs.pop("silent", False)
        super().__init__(*args, **kwargs)

    def error(self, message):
        # argparse normally prints usage and exits; cmd2 typically reports error.
        raise ValueError(message)

    def exit(self, status=0, message=None):
        if message:
            raise ValueError(message)
        raise ValueError(f"Parser exited with status {status}")


def tokenize(line: str) -> List[str]:
    """
    Tokenize an input line similar to cmd2's parsing with shlex.
    """
    if line is None:
        return []
    line = line.strip()
    if line == "":
        return []
    return shlex.split(line, posix=True)


def parse_statement(line: str) -> Statement:
    raw = line if line is not None else ""
    s = Statement(raw=raw)
    toks = tokenize(raw)
    if not toks:
        s.command = ""
        s.args = ""
        s.arg_list = []
        return s
    s.command = toks[0]
    s.arg_list = toks[1:]
    # Reconstruct args string faithfully enough for tests
    s.args = raw[len(raw.split(None, 1)[0]) :].lstrip() if raw.strip() else ""
    return s


def split_command_and_args(line: str) -> Tuple[str, str]:
    st = parse_statement(line)
    return st.command, st.args


def argparse_parse(parser: argparse.ArgumentParser, arg_list: Sequence[str]) -> Any:
    """
    Parse args via argparse without exiting; convert argparse's SystemExit into ValueError.
    """
    try:
        return parser.parse_args(list(arg_list))
    except SystemExit as e:
        raise ValueError(str(e)) from None


__all__ = [
    "Statement",
    "Cmd2ArgumentParser",
    "tokenize",
    "parse_statement",
    "split_command_and_args",
    "argparse_parse",
]
</file>

<file:name=cmd2/cmd2.py>
import cmd
import inspect
import io
import os
import traceback
from typing import Any, Callable, Dict, List, Optional, Tuple

from .parsing import Cmd2ArgumentParser, Statement, parse_statement
from . import utils


class Cmd2Error(Exception):
    pass


class Cmd2(cmd.Cmd):
    """
    A small, API-compatible subset of the cmd2.Cmd class.

    Core supported behaviors:
    - do_<command> methods, help_<command> methods, complete_<command> methods
    - improved parsing (Statement) and onecmd_plus_hooks
    - output helpers: poutput, perror, ppaged
    - transcript running via utils.run_transcript (external helper)
    """

    prompt = "(Cmd) "
    intro = None
    ruler = "="

    def __init__(
        self,
        *,
        stdin=None,
        stdout=None,
        stderr=None,
        persistent_history_file: Optional[str] = None,
        allow_cli_args: bool = False,
        **kwargs,
    ):
        super().__init__(stdin=stdin, stdout=stdout, **kwargs)
        self.stderr = stderr if stderr is not None else io.StringIO()
        self.persistent_history_file = persistent_history_file
        self.allow_cli_args = allow_cli_args
        self.last_result: Any = None
        self._last_statement: Optional[Statement] = None

    # ---------- Output helpers ----------
    def poutput(self, msg: Any = "", end: str = "\n") -> None:
        if msg is None:
            msg = ""
        self.stdout.write(str(msg) + end)
        try:
            self.stdout.flush()
        except Exception:
            pass

    def perror(self, msg: Any = "", end: str = "\n") -> None:
        if msg is None:
            msg = ""
        # Match common cmd2 behavior: errors go to stderr if present, else stdout
        target = self.stderr if self.stderr is not None else self.stdout
        target.write(str(msg) + end)
        try:
            target.flush()
        except Exception:
            pass

    def ppaged(self, msg: Any, end: str = "\n") -> None:
        # Minimal: no pager, just output.
        self.poutput(msg, end=end)

    # ---------- Parsing ----------
    def parse_statement(self, line: str) -> Statement:
        st = parse_statement(line)
        return st

    def preparse(self, line: str) -> str:
        return line

    def postparse(self, statement: Statement) -> Statement:
        return statement

    # ---------- Command loop integration ----------
    def onecmd_plus_hooks(self, line: str) -> bool:
        """
        cmd2-style entry point: parse into Statement and run pre/post hooks.
        """
        line = "" if line is None else line
        line = self.preparse(line)

        statement = self.parse_statement(line)
        statement = self.postparse(statement)
        self._last_statement = statement

        stop = False
        try:
            stop = self.onecmd(statement.raw)
        except Exception:
            # cmd2 normally reports errors and continues unless configured otherwise.
            self._report_exception()
            stop = False
        return stop

    def onecmd(self, line: str) -> bool:
        # Override to support empty lines and default cmd.Cmd behavior
        if isinstance(line, Statement):
            line = line.raw
        return super().onecmd(line)

    def default(self, line: str) -> None:
        self.perror(f"*** Unknown syntax: {line}")

    def emptyline(self) -> bool:
        # cmd2 defaults to doing nothing on empty line
        return False

    # ---------- Help ----------
    def get_visible_commands(self) -> List[str]:
        names = []
        for name, _ in inspect.getmembers(self, predicate=callable):
            if name.startswith("do_"):
                cmdname = name[3:]
                if cmdname:
                    names.append(cmdname)
        names.sort()
        return names

    def do_help(self, arg: str) -> None:
        arg = (arg or "").strip()
        if not arg:
            cmds = self.get_visible_commands()
            if cmds:
                self.poutput("Commands:")
                for c in cmds:
                    self.poutput(f"  {c}")
            else:
                self.poutput("No commands.")
            self.poutput('Type "help <command>" for detailed help.')
            return

        func = getattr(self, "help_" + arg, None)
        if callable(func):
            func()
            return

        doc = ""
        do_func = getattr(self, "do_" + arg, None)
        if callable(do_func):
            doc = inspect.getdoc(do_func) or ""
        if doc:
            self.poutput(doc)
        else:
            self.perror(f"No help on {arg}")

    # ---------- Completion ----------
    # cmd.Cmd calls complete_<command> if present, otherwise complete().
    # We'll rely on base cmd implementation.

    # ---------- Built-in commands ----------
    def do_quit(self, arg: str) -> bool:
        """Quit the application."""
        return True

    def do_exit(self, arg: str) -> bool:
        """Exit the application."""
        return True

    def do_EOF(self, arg: str) -> bool:
        return True

    # ---------- Transcript support ----------
    def run_transcript(self, transcript_path: str, *, encoding: str = "utf-8", strip_colors: bool = True):
        text = utils._read_text_file(transcript_path, encoding=encoding)
        return utils.run_transcript(self, text, prompt=self.prompt, strip_colors=strip_colors)

    # ---------- Error reporting ----------
    def _report_exception(self) -> None:
        # Print traceback to stderr in a deterministic way
        tb = traceback.format_exc()
        self.perror(tb.rstrip("\n"))

    # ---------- Convenience for tests ----------
    @property
    def last_statement(self) -> Optional[Statement]:
        return self._last_statement


__all__ = [
    "Cmd2",
    "Cmd2ArgumentParser",
    "Statement",
    "Cmd2Error",
]
</file>