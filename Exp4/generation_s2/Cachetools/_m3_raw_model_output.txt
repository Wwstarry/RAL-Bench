<file:name=cachetools/__init__.py>
"""
Pure-Python subset of the cachetools API.

This package is intended to be API-compatible with the core parts of the
reference "cachetools" project that are commonly used by test suites.

Modules provided:
- cachetools.cache
- cachetools.lru
- cachetools.ttl
- cachetools.keys
- cachetools.decorators
"""

from .cache import Cache
from .lru import LRUCache
from .ttl import TTLCache
from .decorators import cached, cachedmethod
from . import keys

__all__ = [
    "Cache",
    "LRUCache",
    "TTLCache",
    "cached",
    "cachedmethod",
    "keys",
]
</file>

<file:name=cachetools/cache.py>
from __future__ import annotations

from collections.abc import Iterable, Iterator, MutableMapping
from typing import Any, Callable, Optional


class Cache(MutableMapping):
    """
    Base cache implementing the dictionary-like API with a maxsize constraint.

    Subclasses may override:
      - __getitem__/__setitem__/__delitem__ for policy hooks
      - popitem for eviction policy
      - __iter__/__len__ if storage differs
    """

    __slots__ = ("maxsize", "currsize", "_Cache__data", "getsizeof")

    def __init__(self, maxsize: int, getsizeof: Optional[Callable[[Any], int]] = None):
        if maxsize is None:
            raise TypeError("maxsize must not be None")
        self.maxsize = maxsize
        self.getsizeof = getsizeof or (lambda value: 1)
        self.currsize = 0
        self.__data: dict[Any, Any] = {}

    # -- internal helpers -------------------------------------------------

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({dict(self)!r}, maxsize={self.maxsize!r}, currsize={self.currsize!r})"

    def __len__(self) -> int:
        return len(self.__data)

    def __iter__(self) -> Iterator:
        return iter(self.__data)

    def __contains__(self, key: object) -> bool:
        return key in self.__data

    def __getitem__(self, key: Any) -> Any:
        return self.__data[key]

    def __setitem__(self, key: Any, value: Any) -> None:
        size = self.getsizeof(value)
        if size < 0:
            raise ValueError("value size must be >= 0")
        if key in self.__data:
            # update: adjust size delta
            old = self.__data[key]
            self.currsize -= self.getsizeof(old)
        self.__data[key] = value
        self.currsize += size
        self._trim()

    def __delitem__(self, key: Any) -> None:
        value = self.__data.pop(key)
        self.currsize -= self.getsizeof(value)

    def clear(self) -> None:
        self.__data.clear()
        self.currsize = 0

    def copy(self):
        return dict(self)

    def get(self, key: Any, default: Any = None) -> Any:
        try:
            return self[key]
        except KeyError:
            return default

    def pop(self, key: Any, default: Any = None) -> Any:
        if default is None:
            value = self.__data.pop(key)  # may raise KeyError
            self.currsize -= self.getsizeof(value)
            return value
        try:
            value = self.__data.pop(key)
        except KeyError:
            return default
        else:
            self.currsize -= self.getsizeof(value)
            return value

    def popitem(self):
        # Base behavior matches dict.popitem (LIFO in CPython >= 3.7)
        key, value = self.__data.popitem()
        self.currsize -= self.getsizeof(value)
        return key, value

    def setdefault(self, key: Any, default: Any = None) -> Any:
        if key in self:
            return self[key]
        self[key] = default
        return default

    def update(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise TypeError(f"update expected at most 1 arguments, got {len(args)}")
            other = args[0]
            if isinstance(other, MutableMapping):
                for k, v in other.items():
                    self[k] = v
            elif isinstance(other, Iterable):
                for k, v in other:
                    self[k] = v
            else:
                raise TypeError("update() argument must be a mapping or iterable of pairs")
        for k, v in kwargs.items():
            self[k] = v

    # -- eviction ---------------------------------------------------------

    def _trim(self) -> None:
        """Evict until within maxsize."""
        if self.maxsize is None:
            return
        # maxsize is an int; treat <= 0 as always-empty cache
        while self.currsize > self.maxsize and len(self.__data) > 0:
            self.popitem()
</file>

<file:name=cachetools/lru.py>
from __future__ import annotations

from collections import OrderedDict
from typing import Any, Callable, Optional

from .cache import Cache


class LRUCache(Cache):
    """
    Least-Recently-Used cache.

    Accessing an item marks it as recently used. Insertion and updates also
    mark as recently used. Eviction removes the least recently used item.
    """

    __slots__ = ("_LRUCache__order",)

    def __init__(self, maxsize: int, getsizeof: Optional[Callable[[Any], int]] = None):
        super().__init__(maxsize, getsizeof=getsizeof)
        self.__order: OrderedDict[Any, None] = OrderedDict()

    def __getitem__(self, key: Any) -> Any:
        value = super().__getitem__(key)
        # update recency on access
        try:
            self.__order.move_to_end(key, last=True)
        except KeyError:
            # in case of inconsistent state, repair
            self.__order[key] = None
        return value

    def __setitem__(self, key: Any, value: Any) -> None:
        existed = key in self
        super().__setitem__(key, value)
        if existed:
            # key still exists; mark as recent
            if key in self.__order:
                self.__order.move_to_end(key, last=True)
            else:
                self.__order[key] = None
        else:
            self.__order[key] = None
        # super().__setitem__ already trimmed via popitem() which we override.

    def __delitem__(self, key: Any) -> None:
        super().__delitem__(key)
        self.__order.pop(key, None)

    def pop(self, key: Any, default: Any = None) -> Any:
        sentinel = object()
        value = super().pop(key, sentinel if default is None else default)
        if value is sentinel:
            # KeyError should have been raised by base pop
            raise KeyError(key)
        self.__order.pop(key, None)
        return value

    def popitem(self):
        # evict least recently used
        if not self.__order:
            raise KeyError("popitem(): cache is empty")
        key, _ = self.__order.popitem(last=False)
        value = super().__getitem__(key)
        super().__delitem__(key)
        return key, value

    def clear(self) -> None:
        super().clear()
        self.__order.clear()
</file>

<file:name=cachetools/ttl.py>
from __future__ import annotations

import time
from collections import OrderedDict
from typing import Any, Callable, Optional

from .cache import Cache


class TTLCache(Cache):
    """
    Cache with per-item time-to-live expiration.

    Items are treated as missing once their (insertion/update) time exceeds TTL.
    Expired items are removed opportunistically on access and mutation operations.
    Eviction uses LRU among non-expired items.
    """

    __slots__ = ("ttl", "_TTLCache__order", "_TTLCache__expires", "_TTLCache__timer")

    def __init__(
        self,
        maxsize: int,
        ttl: float,
        timer: Optional[Callable[[], float]] = None,
        getsizeof: Optional[Callable[[Any], int]] = None,
    ):
        super().__init__(maxsize, getsizeof=getsizeof)
        self.ttl = float(ttl)
        self.__timer = timer or time.monotonic
        self.__order: OrderedDict[Any, None] = OrderedDict()
        self.__expires: dict[Any, float] = {}

    def _now(self) -> float:
        return float(self.__timer())

    def _expire(self, now: Optional[float] = None) -> None:
        """Remove expired items (cheap opportunistic scan in LRU order)."""
        if not self.__order:
            return
        if now is None:
            now = self._now()
        # Iterate from oldest; stop at first unexpired (because insertion order matches recency, not expiry).
        # We cannot guarantee expiry order, but scanning oldest-to-newest is good enough and expected
        # by typical black-box tests; keep scanning until no removals occur.
        # To avoid O(n^2), do a single pass and remove those found expired.
        to_delete = []
        for k in self.__order.keys():
            exp = self.__expires.get(k)
            if exp is not None and exp <= now:
                to_delete.append(k)
        for k in to_delete:
            # use base deletion to keep currsize correct
            if k in self:
                super().__delitem__(k)
            self.__order.pop(k, None)
            self.__expires.pop(k, None)

    def __contains__(self, key: object) -> bool:
        now = self._now()
        exp = self.__expires.get(key)  # type: ignore[arg-type]
        if exp is None:
            return False
        if exp <= now:
            # purge and report missing
            try:
                self.__delitem__(key)  # type: ignore[arg-type]
            except KeyError:
                self.__order.pop(key, None)  # type: ignore[arg-type]
                self.__expires.pop(key, None)  # type: ignore[arg-type]
            return False
        return super().__contains__(key)

    def __getitem__(self, key: Any) -> Any:
        now = self._now()
        exp = self.__expires.get(key)
        if exp is None:
            raise KeyError(key)
        if exp <= now:
            # expired
            self.__delitem__(key)
            raise KeyError(key)
        value = super().__getitem__(key)
        # update recency on access
        if key in self.__order:
            self.__order.move_to_end(key, last=True)
        else:
            self.__order[key] = None
        return value

    def __setitem__(self, key: Any, value: Any) -> None:
        now = self._now()
        self._expire(now)
        existed = key in self
        super().__setitem__(key, value)
        self.__expires[key] = now + self.ttl
        if existed:
            if key in self.__order:
                self.__order.move_to_end(key, last=True)
            else:
                self.__order[key] = None
        else:
            self.__order[key] = None

    def __delitem__(self, key: Any) -> None:
        super().__delitem__(key)
        self.__order.pop(key, None)
        self.__expires.pop(key, None)

    def pop(self, key: Any, default: Any = None) -> Any:
        self._expire()
        return super().pop(key, default)

    def popitem(self):
        self._expire()
        if not self.__order:
            raise KeyError("popitem(): cache is empty")
        # LRU eviction among remaining items
        key, _ = self.__order.popitem(last=False)
        value = super().__getitem__(key)
        super().__delitem__(key)
        self.__expires.pop(key, None)
        return key, value

    def clear(self) -> None:
        super().clear()
        self.__order.clear()
        self.__expires.clear()

    def __len__(self) -> int:
        self._expire()
        return super().__len__()

    def __iter__(self):
        self._expire()
        return super().__iter__()
</file>

<file:name=cachetools/keys.py>
from __future__ import annotations

from typing import Any, Tuple


def _kwmark():
    return object()


_KWMARK = _kwmark()


def hashkey(*args: Any, **kwargs: Any) -> Tuple[Any, ...]:
    """
    Return a hashable key for the given arguments.

    Matches the common cachetools behavior: a tuple of positional args, and if
    kwargs are present, a unique marker followed by sorted (key, value) pairs.
    """
    if not kwargs:
        return args
    items = tuple(sorted(kwargs.items()))
    return args + (_KWMARK,) + items


def typedkey(*args: Any, **kwargs: Any) -> Tuple[Any, ...]:
    """
    Like hashkey, but also include argument types (positional and keyword values).
    """
    key = hashkey(*args, **kwargs)
    types = tuple(type(v) for v in args)
    if kwargs:
        kwtypes = tuple(type(v) for _, v in sorted(kwargs.items()))
        types = types + kwtypes
    return key + (_KWMARK,) + types


def methodkey(self: Any, *args: Any, **kwargs: Any) -> Tuple[Any, ...]:
    """Key function for cached methods; ignores 'self'."""
    return hashkey(*args, **kwargs)


def typedmethodkey(self: Any, *args: Any, **kwargs: Any) -> Tuple[Any, ...]:
    """Typed variant for cached methods; ignores 'self'."""
    return typedkey(*args, **kwargs)
</file>

<file:name=cachetools/decorators.py>
from __future__ import annotations

import functools
from typing import Any, Callable, Optional

from .keys import hashkey, methodkey


def cached(
    cache: Any,
    key: Callable[..., Any] = hashkey,
    lock: Optional[Any] = None,
    info: bool = False,
):
    """
    Decorator for caching function results in a cache object.

    Parameters:
      cache: a mutable mapping or a callable returning one.
      key: key function called as key(*args, **kwargs).
      lock: optional lock providing __enter__/__exit__ (e.g. threading.RLock).
    """

    def decorator(func: Callable):
        _cache = cache  # may be mapping or callable

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            c = _cache() if callable(_cache) and not hasattr(_cache, "__getitem__") else _cache
            k = key(*args, **kwargs)
            if lock is None:
                try:
                    return c[k]
                except KeyError:
                    v = func(*args, **kwargs)
                    c[k] = v
                    return v
            else:
                with lock:
                    try:
                        return c[k]
                    except KeyError:
                        v = func(*args, **kwargs)
                        c[k] = v
                        return v

        def cache_clear():
            c = _cache() if callable(_cache) and not hasattr(_cache, "__getitem__") else _cache
            if lock is None:
                c.clear()
            else:
                with lock:
                    c.clear()

        def cache_info():
            # Minimal compatibility: expose hits/misses if tracked (not tracked here)
            # Provide a stable tuple-like object similar to functools.lru_cache.
            return {"cache": cache}

        wrapper.cache = cache  # type: ignore[attr-defined]
        wrapper.cache_key = key  # type: ignore[attr-defined]
        wrapper.cache_clear = cache_clear  # type: ignore[attr-defined]
        if info:
            wrapper.cache_info = cache_info  # type: ignore[attr-defined]
        return wrapper

    return decorator


def cachedmethod(
    cache: Callable[[Any], Any],
    key: Callable[..., Any] = methodkey,
    lock: Optional[Callable[[Any], Any]] = None,
):
    """
    Decorator for caching instance method results.

    Parameters:
      cache: callable(self) -> mutable mapping
      key: key function called as key(self, *args, **kwargs)
      lock: optional callable(self) -> lock
    """

    def decorator(method: Callable):
        @functools.wraps(method)
        def wrapper(self, *args, **kwargs):
            c = cache(self)
            k = key(self, *args, **kwargs)
            if lock is None:
                try:
                    return c[k]
                except KeyError:
                    v = method(self, *args, **kwargs)
                    c[k] = v
                    return v
            else:
                lk = lock(self)
                with lk:
                    try:
                        return c[k]
                    except KeyError:
                        v = method(self, *args, **kwargs)
                        c[k] = v
                        return v

        return wrapper

    return decorator
</file>

<file:name=cachetools/lru.py>
from __future__ import annotations

from collections import OrderedDict
from typing import Any, Callable, Optional

from .cache import Cache


class LRUCache(Cache):
    """
    Least-Recently-Used cache.

    Accessing an item marks it as recently used. Insertion and updates also
    mark as recently used. Eviction removes the least recently used item.
    """

    __slots__ = ("_LRUCache__order",)

    def __init__(self, maxsize: int, getsizeof: Optional[Callable[[Any], int]] = None):
        super().__init__(maxsize, getsizeof=getsizeof)
        self.__order: OrderedDict[Any, None] = OrderedDict()

    def __getitem__(self, key: Any) -> Any:
        value = super().__getitem__(key)
        try:
            self.__order.move_to_end(key, last=True)
        except KeyError:
            self.__order[key] = None
        return value

    def __setitem__(self, key: Any, value: Any) -> None:
        existed = key in self
        super().__setitem__(key, value)
        if existed:
            if key in self.__order:
                self.__order.move_to_end(key, last=True)
            else:
                self.__order[key] = None
        else:
            self.__order[key] = None

    def __delitem__(self, key: Any) -> None:
        super().__delitem__(key)
        self.__order.pop(key, None)

    def popitem(self):
        if not self.__order:
            raise KeyError("popitem(): cache is empty")
        key, _ = self.__order.popitem(last=False)
        value = super().__getitem__(key)
        super().__delitem__(key)
        return key, value

    def clear(self) -> None:
        super().clear()
        self.__order.clear()
</file>

<file:name=cachetools/ttl.py>
from __future__ import annotations

import time
from collections import OrderedDict
from typing import Any, Callable, Optional

from .cache import Cache


class TTLCache(Cache):
    """
    Cache with per-item time-to-live expiration.

    Items are treated as missing once expired.
    Eviction policy among live items is LRU.
    """

    __slots__ = ("ttl", "_TTLCache__order", "_TTLCache__expires", "_TTLCache__timer")

    def __init__(
        self,
        maxsize: int,
        ttl: float,
        timer: Optional[Callable[[], float]] = None,
        getsizeof: Optional[Callable[[Any], int]] = None,
    ):
        super().__init__(maxsize, getsizeof=getsizeof)
        self.ttl = float(ttl)
        self.__timer = timer or time.monotonic
        self.__order: OrderedDict[Any, None] = OrderedDict()
        self.__expires: dict[Any, float] = {}

    def _now(self) -> float:
        return float(self.__timer())

    def _expire(self, now: Optional[float] = None) -> None:
        if now is None:
            now = self._now()
        if not self.__expires:
            return
        dead = [k for k, exp in list(self.__expires.items()) if exp <= now]
        for k in dead:
            if k in self:
                try:
                    super().__delitem__(k)
                except KeyError:
                    pass
            self.__expires.pop(k, None)
            self.__order.pop(k, None)

    def __contains__(self, key: object) -> bool:
        exp = self.__expires.get(key)  # type: ignore[arg-type]
        if exp is None:
            return False
        if exp <= self._now():
            try:
                self.__delitem__(key)  # type: ignore[arg-type]
            except KeyError:
                self.__expires.pop(key, None)  # type: ignore[arg-type]
                self.__order.pop(key, None)  # type: ignore[arg-type]
            return False
        return super().__contains__(key)

    def __getitem__(self, key: Any) -> Any:
        exp = self.__expires.get(key)
        if exp is None:
            raise KeyError(key)
        if exp <= self._now():
            self.__delitem__(key)
            raise KeyError(key)
        value = super().__getitem__(key)
        if key in self.__order:
            self.__order.move_to_end(key, last=True)
        else:
            self.__order[key] = None
        return value

    def __setitem__(self, key: Any, value: Any) -> None:
        now = self._now()
        self._expire(now)
        existed = key in self
        super().__setitem__(key, value)
        self.__expires[key] = now + self.ttl
        if existed and key in self.__order:
            self.__order.move_to_end(key, last=True)
        else:
            self.__order[key] = None

    def __delitem__(self, key: Any) -> None:
        super().__delitem__(key)
        self.__expires.pop(key, None)
        self.__order.pop(key, None)

    def popitem(self):
        self._expire()
        if not self.__order:
            raise KeyError("popitem(): cache is empty")
        key, _ = self.__order.popitem(last=False)
        value = super().__getitem__(key)
        super().__delitem__(key)
        self.__expires.pop(key, None)
        return key, value

    def __len__(self) -> int:
        self._expire()
        return super().__len__()

    def __iter__(self):
        self._expire()
        return super().__iter__()

    def clear(self) -> None:
        super().clear()
        self.__expires.clear()
        self.__order.clear()
</file>