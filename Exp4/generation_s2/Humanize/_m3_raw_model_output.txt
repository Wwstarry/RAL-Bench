<file:name=humanize/__init__.py>
"""
A small, pure-Python subset of the `humanize` project.

This repository implements the core APIs used by typical black-box tests:
- number helpers: intcomma, ordinal
- filesize: naturalsize
- time helpers: precisedelta, naturaldelta, naturaltime
- lists: natural_list
- i18n: basic activation/deactivation hooks (no external deps)
"""

from __future__ import annotations

from .number import intcomma, ordinal
from .filesize import naturalsize
from .time import precisedelta, naturaldelta, naturaltime

__all__ = [
    "intcomma",
    "ordinal",
    "naturalsize",
    "precisedelta",
    "naturaldelta",
    "naturaltime",
]

# Convenience re-export for compatibility with some callers.
from .lists import natural_list  # noqa: E402

__all__.append("natural_list")

# i18n module is importable as humanize.i18n
from . import i18n  # noqa: E402

__all__.append("i18n")

# Version is not mandated, but some environments introspect it.
__version__ = "0.0.0"
</file>

<file:name=humanize/i18n.py>
"""
Minimal i18n stubs compatible with a subset of the reference humanize project.

The upstream project integrates with gettext and supports multiple locales.
For this kata we provide:
- activate(locale): set the active locale identifier
- deactivate(): clear locale (back to default)
- get_translation(): returns a translation function (identity)
- gettext alias '_': translation function

This is sufficient for code paths that call humanize.i18n.activate() or '_()'.
"""

from __future__ import annotations

from contextlib import contextmanager
from typing import Callable, Optional

_ACTIVE_LOCALE: Optional[str] = None


def activate(locale: str) -> None:
    global _ACTIVE_LOCALE
    _ACTIVE_LOCALE = locale


def deactivate() -> None:
    global _ACTIVE_LOCALE
    _ACTIVE_LOCALE = None


def get_active() -> Optional[str]:
    return _ACTIVE_LOCALE


def get_translation() -> Callable[[str], str]:
    # No real translations shipped in this kata; identity is enough for tests
    return lambda s: s


def gettext(message: str) -> str:
    return message


_ = gettext


@contextmanager
def activated(locale: str):
    prev = _ACTIVE_LOCALE
    activate(locale)
    try:
        yield
    finally:
        global _ACTIVE_LOCALE
        _ACTIVE_LOCALE = prev
</file>

<file:name=humanize/number.py>
from __future__ import annotations

import math
from decimal import Decimal
from typing import Any, Optional


def intcomma(value: Any) -> str:
    """
    Convert an integer/float/Decimal/string into a string with commas.

    Compatible with core behavior from the reference humanize project:
    - preserves sign
    - preserves fractional part if provided
    - does not round
    """
    if value is None:
        return "0"

    # Convert to string while preserving given precision when possible.
    if isinstance(value, Decimal):
        s = format(value, "f")
    else:
        s = str(value)

    s = s.strip()
    if not s:
        return "0"

    sign = ""
    if s[0] in "+-":
        sign, s = s[0], s[1:]

    # Handle scientific notation by converting to Decimal.
    if "e" in s.lower():
        try:
            d = Decimal(sign + s)
            s = format(d, "f")
            sign = ""
            if s and s[0] in "+-":
                sign, s = s[0], s[1:]
        except Exception:
            # Fall back to raw string if it can't be parsed.
            s = s

    if "." in s:
        int_part, frac_part = s.split(".", 1)
        frac = "." + frac_part
    else:
        int_part, frac = s, ""

    if int_part == "":
        int_part = "0"

    # If the integer part is not numeric (e.g., "NaN"), return original.
    if not int_part.isdigit():
        return sign + int_part + frac

    n = int_part
    # Insert commas from the right.
    parts = []
    while len(n) > 3:
        parts.append(n[-3:])
        n = n[:-3]
    parts.append(n)
    out_int = ",".join(reversed(parts))
    return f"{sign}{out_int}{frac}"


def ordinal(value: Any) -> str:
    """
    Convert an integer to its ordinal representation: 1 -> 1st, 2 -> 2nd, etc.
    """
    try:
        n = int(value)
    except Exception:
        return str(value)

    abs_n = abs(n)
    if 10 <= (abs_n % 100) <= 20:
        suffix = "th"
    else:
        suffix = {1: "st", 2: "nd", 3: "rd"}.get(abs_n % 10, "th")
    return f"{n}{suffix}"


def _format_number(value: float, digits: int) -> str:
    # Helper used by other modules (kept internal).
    if digits < 0:
        digits = 0
    fmt = f"{{:.{digits}f}}"
    s = fmt.format(value)
    if "." in s:
        s = s.rstrip("0").rstrip(".")
    return s


def _to_number(value: Any) -> Optional[float]:
    if value is None:
        return None
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, Decimal):
        return float(value)
    try:
        return float(str(value).strip())
    except Exception:
        return None


def _isfinite(x: float) -> bool:
    return math.isfinite(x)
</file>

<file:name=humanize/filesize.py>
from __future__ import annotations

from typing import Any, Iterable, Optional, Sequence, Tuple

from .number import _format_number, _to_number


# Common unit sets in humanize-like APIs
_DECIMAL_SUFFIXES = ("B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
_BINARY_SUFFIXES = ("B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB")


def naturalsize(
    value: Any,
    binary: bool = False,
    format: str = "%.1f",
    locale: str | None = None,  # accepted for compatibility
    *,  # keyword-only (matches many versions)
    gnu: bool = False,
) -> str:
    """
    Format a bytes value as a human-readable size.

    Parameters
    - value: bytes (int/float/str)
    - binary: base 1024 (KiB, MiB) if True, else base 1000 (kB, MB)
    - format: printf-style format for the mantissa (default '%.1f')
    - gnu: if True use GNU style:
        * base 1024
        * suffixes: K, M, G, T, P, E, Z, Y (with 'B' for bytes)
        * bytes shown as 'B' (not '1B' for 1)
    """
    n = _to_number(value)
    if n is None:
        return str(value)
    try:
        n_float = float(n)
    except Exception:
        return str(value)

    # Preserve sign; scale absolute value.
    sign = "-" if n_float < 0 else ""
    n_abs = abs(n_float)

    if gnu:
        # GNU style is binary with single-letter suffixes.
        base = 1024.0
        if n_abs < base:
            # For bytes, GNU tends to return "123B"
            return f"{sign}{int(n_abs)}B"
        suffixes = ("K", "M", "G", "T", "P", "E", "Z", "Y")
        i = 0
        v = n_abs
        while v >= base and i < len(suffixes) - 1:
            v /= base
            i += 1
        # For GNU, no 'iB', just letter; often no space.
        # Use provided format for mantissa.
        try:
            mantissa = (format % v).rstrip("0").rstrip(".")
        except Exception:
            # Fallback to a sane default
            mantissa = _format_number(v, 1)
        return f"{sign}{mantissa}{suffixes[i-1]}" if i > 0 else f"{sign}{int(n_abs)}B"

    base = 1024.0 if binary else 1000.0
    suffixes = _BINARY_SUFFIXES if binary else _DECIMAL_SUFFIXES

    if n_abs < base:
        return f"{sign}{int(n_abs)} {suffixes[0]}"

    i = 0
    v = n_abs
    while v >= base and i < len(suffixes) - 1:
        v /= base
        i += 1

    try:
        mantissa = format % v
    except Exception:
        # If given a format like "%.1f", mimic it.
        mantissa = _format_number(v, 1)

    # Common expectation: strip trailing zeros for formats that allow it.
    if "." in mantissa:
        mantissa = mantissa.rstrip("0").rstrip(".")

    return f"{sign}{mantissa} {suffixes[i]}"
</file>

<file:name=humanize/lists.py>
from __future__ import annotations

from typing import Iterable, List, Sequence


def natural_list(
    items: Iterable[object],
    separator: str = ", ",
    conjunction: str = "and",
) -> str:
    """
    Join items into a natural-language list:
    - [] -> ''
    - ['a'] -> 'a'
    - ['a','b'] -> 'a and b'
    - ['a','b','c'] -> 'a, b and c'
    """
    seq = [str(x) for x in items]
    if not seq:
        return ""
    if len(seq) == 1:
        return seq[0]
    if len(seq) == 2:
        return f"{seq[0]} {conjunction} {seq[1]}"
    return f"{separator.join(seq[:-1])} {conjunction} {seq[-1]}"
</file>

<file:name=humanize/time.py>
from __future__ import annotations

import datetime as _dt
from typing import Any, Dict, Iterable, Optional, Tuple, Union

TimeLike = Union[int, float, _dt.timedelta]


_UNITS: Tuple[Tuple[str, int], ...] = (
    ("year", 365 * 24 * 60 * 60),
    ("month", 30 * 24 * 60 * 60),
    ("day", 24 * 60 * 60),
    ("hour", 60 * 60),
    ("minute", 60),
    ("second", 1),
)


def _as_timedelta(value: Any) -> Optional[_dt.timedelta]:
    if value is None:
        return None
    if isinstance(value, _dt.timedelta):
        return value
    if isinstance(value, (int, float)):
        return _dt.timedelta(seconds=float(value))
    return None


def _plural(n: int, word: str) -> str:
    return word if n == 1 else word + "s"


def precisedelta(
    value: Any,
    minimum_unit: str = "seconds",
    format: str = "%0.0f",
    suppress: Iterable[str] = (),
    locale: str | None = None,  # compatibility
) -> str:
    """
    Render a timedelta into a precise, multi-unit string.

    This is a pragmatic subset compatible with common expectations of humanize:
    - breaks down into years/months/days/hours/minutes/seconds
    - supports suppressing units (e.g. ('seconds',))
    - minimum_unit controls the smallest unit included
    """
    td = _as_timedelta(value)
    if td is None:
        return str(value)

    total_seconds = int(round(abs(td.total_seconds())))
    if total_seconds == 0:
        return "0 seconds"

    suppress_set = {s.rstrip("s") for s in suppress}
    min_unit = minimum_unit.rstrip("s")

    # Determine where to stop
    unit_names = [u for (u, _) in _UNITS]
    if min_unit not in unit_names:
        min_unit = "second"
    stop_index = unit_names.index(min_unit)

    parts = []
    remaining = total_seconds
    for idx, (name, seconds_per) in enumerate(_UNITS):
        if idx < stop_index:
            # bigger units
            count = remaining // seconds_per
            remaining = remaining % seconds_per
        elif idx == stop_index:
            count = remaining // seconds_per
            remaining = remaining % seconds_per
        else:
            # smaller than minimum_unit: ignore
            count = 0

        if name in suppress_set:
            continue
        if idx > stop_index:
            continue
        if count:
            parts.append(f"{count} {_plural(int(count), name)}")

    if not parts:
        # everything suppressed; fall back to minimum unit
        return f"0 {_plural(0, min_unit)}"

    # restore sign by prefixing '-' (reference often doesn't include sign here, but safe)
    if td.total_seconds() < 0:
        return "-" + ", ".join(parts)
    return ", ".join(parts)


def naturaldelta(
    value: Any,
    months: bool = True,
    minimum_unit: str = "seconds",
    locale: str | None = None,
) -> str:
    """
    Like precisedelta but more compact (single largest unit), e.g. "3 days".
    """
    td = _as_timedelta(value)
    if td is None:
        return str(value)

    seconds = abs(td.total_seconds())
    if seconds < 1:
        return "a moment"

    # Pick units; optionally remove months/years approximations.
    units = list(_UNITS)
    if not months:
        units = [u for u in units if u[0] not in ("month", "year")]

    min_unit = minimum_unit.rstrip("s")
    names = [u for (u, _) in units]
    if min_unit not in names:
        min_unit = "second"
    # don't return smaller than minimum unit
    min_idx = names.index(min_unit)

    for idx, (name, secs) in enumerate(units):
        if idx < min_idx:
            continue
        count = int(seconds // secs)
        if count >= 1:
            return f"{count} {_plural(count, name)}"

    # If none matched above min unit (e.g. seconds < 60 and min_unit=minute)
    return f"0 {_plural(0, min_unit)}"


def naturaltime(
    value: Any,
    when: Optional[_dt.datetime] = None,
    locale: str | None = None,
) -> str:
    """
    Convert a datetime/timedelta/seconds offset into a human readable relative string.

    Examples:
    - timedelta(seconds=3) -> "3 seconds ago"
    - timedelta(seconds=-3) -> "3 seconds from now"
    - datetime in past -> "... ago"
    """
    now = when or _dt.datetime.now(_dt.timezone.utc).astimezone().replace(tzinfo=None)

    if isinstance(value, _dt.datetime):
        dt = value
        if dt.tzinfo is not None:
            dt = dt.astimezone().replace(tzinfo=None)
        delta = dt - now
    elif isinstance(value, _dt.date) and not isinstance(value, _dt.datetime):
        dt = _dt.datetime.combine(value, _dt.time.min)
        delta = dt - now
    else:
        td = _as_timedelta(value)
        if td is None:
            # maybe seconds in a string
            try:
                td = _dt.timedelta(seconds=float(value))
            except Exception:
                return str(value)
        delta = td

    seconds = delta.total_seconds()
    if abs(seconds) < 1:
        return "now"

    tense = "from now" if seconds > 0 else "ago"
    human = naturaldelta(_dt.timedelta(seconds=abs(seconds)))
    return f"{human} {tense}"
</file>