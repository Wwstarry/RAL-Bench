<file:name=stegano/__init__.py>
"""
Minimal pure-Python steganography library with a subset of the public API of the
reference "Stegano" project.

Exports:
- stegano.lsb
- stegano.red
- stegano.exifHeader
- stegano.wav
"""

from . import lsb, red, exifHeader, wav  # noqa: F401

__all__ = ["lsb", "red", "exifHeader", "wav"]
</file>

<file:name=stegano/lsb/__init__.py>
from .lsb import hide, reveal  # noqa: F401
from . import generators  # noqa: F401

__all__ = ["hide", "reveal", "generators"]
</file>

<file:name=stegano/lsb/generators.py>
from __future__ import annotations

from typing import Iterator


def eratosthenes() -> Iterator[int]:
    """
    Prime-number generator (Sieve of Eratosthenes style), returning an infinite
    sequence of primes: 2, 3, 5, 7, 11, ...

    This is used by the LSB backend as an index generator for pixel positions.
    """
    # Incremental sieve
    composites = {}
    n = 2
    while True:
        step = composites.pop(n, None)
        if step is None:
            # n is prime
            yield n
            composites[n * n] = n
        else:
            nxt = n + step
            while nxt in composites:
                nxt += step
            composites[nxt] = step
        n += 1
</file>

<file:name=stegano/lsb/lsb.py>
from __future__ import annotations

from typing import Callable, Iterator, Optional, Union

from PIL import Image

from stegano.tools.bititerator import (
    bits_from_bytes,
    bytes_from_bits,
    int_to_bits,
)
from stegano.tools.utils import (
    ensure_image,
    image_to_rgb_if_needed,
    iter_channel_values,
    set_channel_lsb,
)


_SENTINEL = b"\x00\xff\x00\xff\x00\xff"  # unlikely marker
_LEN_BITS = 32  # payload length in bytes, unsigned 32-bit


def _iter_positions(
    capacity: int,
    generator: Optional[Iterator[int]],
    shift: int,
) -> Iterator[int]:
    if generator is None:
        # Sequential indices
        for i in range(shift, capacity):
            yield i
        return

    # Use generator values as indices; apply shift; filter within capacity.
    # Ensure we eventually terminate by only yielding indices < capacity.
    for idx in generator:
        pos = idx + shift
        if 0 <= pos < capacity:
            yield pos
        # if >= capacity, skip; generator may produce more, keep going.


def hide(
    image,
    message,
    generator: Optional[Iterator[int]] = None,
    shift: int = 0,
    encoding: str = "UTF-8",
    auto_convert_rgb: bool = False,
) -> Image.Image:
    """
    Hide a text message in the least significant bits of an image.

    Parameters match the reference project core API.
    """
    img = ensure_image(image)
    if auto_convert_rgb:
        img = image_to_rgb_if_needed(img)

    if isinstance(message, str):
        payload = message.encode(encoding)
    else:
        # allow bytes-like
        payload = bytes(message)

    header = int.to_bytes(len(payload), 4, "big") + _SENTINEL
    data = header + payload

    bits = list(bits_from_bytes(data))

    # Capacity: number of writable channels (we use all channels except alpha)
    channels = list(iter_channel_values(img))
    capacity = len(channels)
    if len(bits) > capacity:
        raise ValueError("Message too large to hide in this image.")

    out = img.copy()
    out_pixels = out.load()

    positions = _iter_positions(capacity=capacity, generator=generator, shift=shift)

    # We need a mapping from linear channel index -> (x,y,channel_index_within_pixel)
    # Build a lightweight index of coordinates and channel ids.
    width, height = out.size
    mode = out.mode
    # Determine channels per pixel excluding alpha
    if mode in ("RGB", "RGBA"):
        usable_channels = 3
    elif mode in ("L", "P"):
        usable_channels = 1
    elif mode in ("LA",):
        usable_channels = 1
    else:
        # fallback: convert to RGB to proceed if supported
        if auto_convert_rgb:
            out = out.convert("RGB")
            out_pixels = out.load()
            width, height = out.size
            mode = out.mode
            usable_channels = 3
        else:
            raise ValueError(f"Unsupported image mode for LSB steganography: {mode}")

    def get_loc_from_linear(n: int):
        pixel_index, chan = divmod(n, usable_channels)
        x = pixel_index % width
        y = pixel_index // width
        return x, y, chan

    for bit in bits:
        pos = next(positions)
        x, y, chan = get_loc_from_linear(pos)
        px = out_pixels[x, y]
        # Normalize to tuple
        if usable_channels == 1:
            new_val = set_channel_lsb(int(px if not isinstance(px, tuple) else px[0]), bit)
            if isinstance(px, tuple):
                # Preserve other channels (e.g., alpha)
                if len(px) == 2:  # LA
                    out_pixels[x, y] = (new_val, px[1])
                else:
                    out_pixels[x, y] = (new_val,)
            else:
                out_pixels[x, y] = new_val
        else:
            if not isinstance(px, tuple):
                # should not happen for RGB/RGBA
                px = (px, px, px)
            px_list = list(px)
            px_list[chan] = set_channel_lsb(px_list[chan], bit)
            out_pixels[x, y] = tuple(px_list)

    return out


def reveal(
    image,
    generator: Optional[Iterator[int]] = None,
    shift: int = 0,
    encoding: str = "UTF-8",
) -> str:
    """
    Reveal a text message hidden by stegano.lsb.hide.
    """
    img = ensure_image(image)

    # Build a list of all usable channel values in deterministic order
    channels = list(iter_channel_values(img))
    capacity = len(channels)

    positions = _iter_positions(capacity=capacity, generator=generator, shift=shift)

    # Read header: 4 bytes length + sentinel
    header_len = 4 + len(_SENTINEL)
    header_bits_len = header_len * 8

    header_bits = []
    for _ in range(header_bits_len):
        pos = next(positions)
        header_bits.append(channels[pos] & 1)

    header_bytes = bytes(bytes_from_bits(header_bits))
    msg_len = int.from_bytes(header_bytes[:4], "big", signed=False)
    sentinel = header_bytes[4:]
    if sentinel != _SENTINEL:
        raise ValueError("No hidden message found (invalid sentinel).")

    # Read message bits
    msg_bits_len = msg_len * 8
    if header_bits_len + msg_bits_len > capacity:
        raise ValueError("Corrupted hidden message (declared size too large).")

    msg_bits = []
    for _ in range(msg_bits_len):
        pos = next(positions)
        msg_bits.append(channels[pos] & 1)

    msg_bytes = bytes(bytes_from_bits(msg_bits))
    return msg_bytes.decode(encoding, errors="strict")
</file>

<file:name=stegano/red/__init__.py>
from .red import hide, reveal  # noqa: F401

__all__ = ["hide", "reveal"]
</file>

<file:name=stegano/red/red.py>
from __future__ import annotations

from PIL import Image

from stegano.tools.bititerator import bits_from_bytes, bytes_from_bits
from stegano.tools.utils import ensure_image, image_to_rgb_if_needed, set_channel_lsb

_SENTINEL = b"\x00\xff\x00\xff"
_LEN_BITS = 32


def hide(image, message) -> Image.Image:
    img = ensure_image(image)
    img = image_to_rgb_if_needed(img)

    if isinstance(message, str):
        payload = message.encode("utf-8")
    else:
        payload = bytes(message)

    header = int.to_bytes(len(payload), 4, "big") + _SENTINEL
    data = header + payload
    bits = list(bits_from_bytes(data))

    width, height = img.size
    capacity = width * height  # 1 bit per pixel (red channel)
    if len(bits) > capacity:
        raise ValueError("Message too large to hide in red channel.")

    out = img.copy()
    px = out.load()

    i = 0
    for y in range(height):
        for x in range(width):
            if i >= len(bits):
                return out
            r, g, b = px[x, y]
            r2 = set_channel_lsb(r, bits[i])
            px[x, y] = (r2, g, b)
            i += 1

    return out


def reveal(image) -> str:
    img = ensure_image(image)
    img = image_to_rgb_if_needed(img)

    width, height = img.size
    px = img.load()

    def red_lsb_stream():
        for y in range(height):
            for x in range(width):
                r = px[x, y][0]
                yield (r & 1)

    stream = red_lsb_stream()

    header_len = 4 + len(_SENTINEL)
    header_bits = [next(stream) for _ in range(header_len * 8)]
    header = bytes(bytes_from_bits(header_bits))

    msg_len = int.from_bytes(header[:4], "big", signed=False)
    if header[4:] != _SENTINEL:
        raise ValueError("No hidden message found (invalid sentinel).")

    msg_bits = [next(stream) for _ in range(msg_len * 8)]
    msg = bytes(bytes_from_bits(msg_bits))
    return msg.decode("utf-8", errors="strict")
</file>

<file:name=stegano/exifHeader/__init__.py>
from .exifHeader import hide, reveal  # noqa: F401

__all__ = ["hide", "reveal"]
</file>

<file:name=stegano/exifHeader/exifHeader.py>
from __future__ import annotations

from typing import Optional, Union

import piexif
from PIL import Image

from stegano.tools.utils import ensure_image

_USER_COMMENT = piexif.ExifIFD.UserComment
_MAGIC_PREFIX = b"STEGANO_EXIF\0"


def hide(
    input_image_file,
    output_path,
    secret_message: Union[bytes, bytearray] = b"",
    encoding: str = "utf-8",
    **kwargs,
):
    """
    Embed bytes into EXIF UserComment for JPEG/TIFF-like formats.
    Writes the modified image to output_path.

    Signature is intentionally permissive with **kwargs for compatibility.
    """
    # input_image_file can be a path or a PIL image.
    if isinstance(input_image_file, Image.Image):
        img = input_image_file
        src_path = None
    else:
        src_path = input_image_file
        img = Image.open(input_image_file)

    msg = bytes(secret_message) if not isinstance(secret_message, bytes) else secret_message

    # Load existing exif (if any)
    exif_bytes = img.info.get("exif", b"")
    try:
        exif_dict = piexif.load(exif_bytes) if exif_bytes else {"0th": {}, "Exif": {}, "GPS": {}, "Interop": {}, "1st": {}, "thumbnail": None}
    except Exception:
        exif_dict = {"0th": {}, "Exif": {}, "GPS": {}, "Interop": {}, "1st": {}, "thumbnail": None}

    exif_dict.setdefault("Exif", {})
    exif_dict["Exif"][_USER_COMMENT] = _MAGIC_PREFIX + msg
    new_exif = piexif.dump(exif_dict)

    # Preserve format if possible; default to JPEG if unknown
    fmt = img.format or (Image.open(src_path).format if src_path else None) or "JPEG"
    save_kwargs = {}
    if fmt.upper() in ("JPEG", "JPG", "TIFF"):
        save_kwargs["exif"] = new_exif
    else:
        # Pillow supports EXIF mostly for JPEG/TIFF. Still attempt to save with exif.
        save_kwargs["exif"] = new_exif

    img.save(output_path, format=fmt, **save_kwargs)


def reveal(image) -> bytes:
    """
    Extract bytes from EXIF UserComment.
    Accepts a path or PIL.Image.Image.
    """
    img = ensure_image(image)
    exif_bytes = img.info.get("exif", b"")
    if not exif_bytes:
        raise ValueError("No EXIF data found.")

    exif_dict = piexif.load(exif_bytes)
    exif = exif_dict.get("Exif", {})
    raw = exif.get(_USER_COMMENT, None)
    if raw is None:
        raise ValueError("No hidden message found in EXIF UserComment.")

    if isinstance(raw, tuple):
        raw = bytes(raw)
    if not isinstance(raw, (bytes, bytearray)):
        raw = bytes(raw)

    raw = bytes(raw)
    if not raw.startswith(_MAGIC_PREFIX):
        raise ValueError("No hidden message found (missing magic prefix).")

    return raw[len(_MAGIC_PREFIX) :]
</file>

<file:name=stegano/wav/__init__.py>
from .wav import hide, reveal  # noqa: F401

__all__ = ["hide", "reveal"]
</file>

<file:name=stegano/wav/wav.py>
from __future__ import annotations

import wave
from typing import Optional, Union

from stegano.tools.bititerator import bits_from_bytes, bytes_from_bits

_SENTINEL = b"\x00\xff\x00\xff\x00"
_HEADER_LEN = 4 + len(_SENTINEL)


def hide(
    input_file,
    message,
    output_file,
    encoding: str = "utf-8",
    **kwargs,
):
    """
    Hide a message in a PCM WAV file by replacing the LSB of each audio byte.

    Writes the modified audio to output_file.
    """
    if isinstance(message, str):
        payload = message.encode(encoding)
    else:
        payload = bytes(message)

    header = int.to_bytes(len(payload), 4, "big") + _SENTINEL
    data = header + payload
    bits = list(bits_from_bytes(data))

    with wave.open(input_file, "rb") as w:
        params = w.getparams()
        frames = w.readframes(w.getnframes())

    frame_bytes = bytearray(frames)
    capacity = len(frame_bytes)  # 1 bit per byte
    if len(bits) > capacity:
        raise ValueError("Message too large to hide in WAV file.")

    for i, bit in enumerate(bits):
        frame_bytes[i] = (frame_bytes[i] & 0xFE) | (1 if bit else 0)

    with wave.open(output_file, "wb") as wout:
        wout.setparams(params)
        wout.writeframes(bytes(frame_bytes))


def reveal(
    input_file,
    encoding: str = "utf-8",
    **kwargs,
) -> str:
    """
    Reveal a message hidden by stegano.wav.hide.
    """
    with wave.open(input_file, "rb") as w:
        frames = w.readframes(w.getnframes())

    frame_bytes = frames  # bytes
    bits_iter = ((b & 1) for b in frame_bytes)

    header_bits = [next(bits_iter) for _ in range(_HEADER_LEN * 8)]
    header = bytes(bytes_from_bits(header_bits))

    msg_len = int.from_bytes(header[:4], "big", signed=False)
    if header[4:] != _SENTINEL:
        raise ValueError("No hidden message found (invalid sentinel).")

    msg_bits = [next(bits_iter) for _ in range(msg_len * 8)]
    msg = bytes(bytes_from_bits(msg_bits))
    return msg.decode(encoding, errors="strict")
</file>

<file:name=stegano/tools/__init__.py>
from .bititerator import bits_from_bytes, bytes_from_bits  # noqa: F401
from .utils import ensure_image  # noqa: F401

__all__ = ["bits_from_bytes", "bytes_from_bits", "ensure_image"]
</file>

<file:name=stegano/tools/bititerator.py>
from __future__ import annotations

from typing import Iterable, Iterator, List


def bits_from_bytes(data: bytes) -> Iterator[int]:
    """Yield bits (0/1) MSB-first for each byte in data."""
    for b in data:
        for i in range(7, -1, -1):
            yield (b >> i) & 1


def bytes_from_bits(bits: Iterable[int]) -> Iterator[int]:
    """Group bits (MSB-first) into bytes, yielding ints 0..255."""
    acc = 0
    n = 0
    for bit in bits:
        acc = (acc << 1) | (1 if bit else 0)
        n += 1
        if n == 8:
            yield acc
            acc = 0
            n = 0
    if n != 0:
        # ignore trailing incomplete byte (should not happen in this library)
        return


def int_to_bits(value: int, width: int) -> List[int]:
    """Return a list of bits (MSB-first) for an integer."""
    if width <= 0:
        return []
    return [((value >> (width - 1 - i)) & 1) for i in range(width)]
</file>

<file:name=stegano/tools/utils.py>
from __future__ import annotations

from typing import Iterator, Union

from PIL import Image


def ensure_image(image) -> Image.Image:
    """Accept a PIL.Image.Image or a path-like and return an opened image."""
    if isinstance(image, Image.Image):
        return image
    return Image.open(image)


def image_to_rgb_if_needed(img: Image.Image) -> Image.Image:
    """Convert paletted/LA/etc to RGB while preserving size."""
    if img.mode == "RGB":
        return img
    if img.mode == "RGBA":
        # keep alpha if present; LSB backend can handle RGBA but red backend expects RGB
        return img.convert("RGB")
    if img.mode in ("P", "L", "LA"):
        return img.convert("RGB")
    return img.convert("RGB")


def set_channel_lsb(value: int, bit: int) -> int:
    """Replace the least significant bit of an 8-bit channel value."""
    return (int(value) & 0xFE) | (1 if bit else 0)


def iter_channel_values(img: Image.Image) -> Iterator[int]:
    """
    Iterate over usable channel values (integers) in deterministic order for LSB.
    Excludes alpha channel when present.
    """
    mode = img.mode
    px = img.load()
    width, height = img.size

    if mode == "RGB":
        for y in range(height):
            for x in range(width):
                r, g, b = px[x, y]
                yield r
                yield g
                yield b
        return

    if mode == "RGBA":
        for y in range(height):
            for x in range(width):
                r, g, b, a = px[x, y]
                yield r
                yield g
                yield b
        return

    if mode == "L":
        for y in range(height):
            for x in range(width):
                v = px[x, y]
                yield int(v)
        return

    if mode == "LA":
        for y in range(height):
            for x in range(width):
                v, a = px[x, y]
                yield int(v)
        return

    if mode == "P":
        # Convert palette index stream as indices (not RGB-expanded). This keeps size.
        # For robustness, caller may convert to RGB via auto_convert_rgb.
        for y in range(height):
            for x in range(width):
                yield int(px[x, y])
        return

    # Unknown: iterate after conversion to RGB to guarantee functionality
    rgb = img.convert("RGB")
    yield from iter_channel_values(rgb)
</file>

<file:name=stegano/console/__init__.py>
# Console entrypoints are not required for core functionality in tests.
</file>

<file:name=stegano/console/main.py>
def main(argv=None):
    """
    Minimal placeholder CLI entrypoint for compatibility with the package layout.
    The reference project offers a full CLI; tests typically only require imports.
    """
    raise SystemExit("Console interface not implemented in this minimal library.")
</file>

<file:name=stegano/steganalysis/__init__.py>
# Placeholder package for compatibility with the reference project layout.
</file>