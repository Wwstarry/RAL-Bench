<file:name=termgraph/__init__.py>
"""
Pure-Python, minimal terminal charting library compatible with core pieces of
the reference 'termgraph' project.

Public API:
- Data (termgraph.data)
- Args (termgraph.args)
- BarChart, StackedChart (termgraph.charts)
"""
from .data import Data
from .args import Args
from .charts import BarChart, StackedChart

__all__ = ["Data", "Args", "BarChart", "StackedChart"]
</file>

<file:name=termgraph/data.py>
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, List, Optional, Sequence


def _is_number(x) -> bool:
    try:
        float(x)
        return True
    except Exception:
        return False


@dataclass
class Data:
    """
    Container for chart data.

    Attributes:
        labels: sequence of label strings (one per row)
        data: list of numeric series, where each series is a list of numbers
              aligned with labels (shape: [n_series][n_rows])
    """
    labels: List[str]
    data: List[List[float]]

    def __init__(
        self,
        labels: Optional[Sequence[str]] = None,
        data: Optional[Sequence[Sequence[float]]] = None,
    ):
        self.labels = list(labels) if labels is not None else []
        self.data = [list(map(float, s)) for s in (data or [])]
        self._validate()

    def _validate(self) -> None:
        if not self.data:
            return
        n = len(self.labels) if self.labels else len(self.data[0])
        for s in self.data:
            if len(s) != n:
                raise ValueError("All series must have the same length as labels")

        if self.labels and len(self.labels) != n:
            raise ValueError("labels length must match series length")

    @property
    def n_rows(self) -> int:
        if self.labels:
            return len(self.labels)
        if self.data:
            return len(self.data[0])
        return 0

    @property
    def n_series(self) -> int:
        return len(self.data)

    def values_for_row(self, idx: int) -> List[float]:
        return [series[idx] for series in self.data]

    def max_value(self) -> float:
        m = 0.0
        for s in self.data:
            for v in s:
                if v > m:
                    m = float(v)
        return m

    def max_value_per_series(self) -> List[float]:
        return [max(map(float, s)) if s else 0.0 for s in self.data]

    def sums_per_row(self) -> List[float]:
        sums = []
        for i in range(self.n_rows):
            sums.append(sum(self.values_for_row(i)))
        return sums

    @classmethod
    def from_dict(cls, mapping) -> "Data":
        """
        Convenience: accept {label: value} or {label: [v1,v2,...]}.
        """
        labels = []
        series = []
        if not mapping:
            return cls([], [])
        first = next(iter(mapping.values()))
        multi = isinstance(first, (list, tuple))
        if multi:
            k = len(first)
            series = [[] for _ in range(k)]
            for lab, vals in mapping.items():
                labels.append(str(lab))
                if len(vals) != k:
                    raise ValueError("All rows must have same number of values")
                for j in range(k):
                    if not _is_number(vals[j]):
                        raise ValueError("Non-numeric data")
                    series[j].append(float(vals[j]))
        else:
            series = [[]]
            for lab, v in mapping.items():
                labels.append(str(lab))
                if not _is_number(v):
                    raise ValueError("Non-numeric data")
                series[0].append(float(v))
        return cls(labels, series)
</file>

<file:name=termgraph/args.py>
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Sequence


@dataclass
class Args:
    """
    Options container resembling the core args used by termgraph.

    Only a subset is implemented, but attributes exist to match the reference
    API used in tests.
    """
    width: int = 50
    stacked: bool = False
    different_scale: bool = False
    no_labels: bool = False
    format: str = "{:<5.2f}"
    suffix: str = ""
    vertical: bool = False
    histogram: bool = False
    no_values: bool = False
    color: Optional[str] = None
    labels: Optional[Sequence[str]] = None
    title: Optional[str] = None

    # Some termgraph variants support these; keep for compatibility.
    start: int = 0
    end: int = -1

    def __post_init__(self) -> None:
        try:
            self.width = int(self.width)
        except Exception:
            self.width = 50
        if self.width <= 0:
            self.width = 50
        if self.format is None:
            self.format = "{:<5.2f}"
        if self.suffix is None:
            self.suffix = ""
</file>

<file:name=termgraph/charts.py>
from __future__ import annotations

import sys
from typing import List, Optional, Sequence

from .args import Args
from .data import Data


_DEFAULT_SYMBOLS = ["#", "=", "-", "+", "*", "o", "x", "%", "@"]


def _fmt_value(fmt: str, v: float) -> str:
    # The reference uses old-style formatting sometimes; accept both.
    try:
        return fmt.format(v)
    except Exception:
        try:
            return fmt % v
        except Exception:
            # Fallback
            return str(v)


def _safe_label(label: str) -> str:
    return "" if label is None else str(label)


def _label_width(labels: Sequence[str]) -> int:
    if not labels:
        return 0
    return max(len(_safe_label(l)) for l in labels)


def _scale(value: float, max_value: float, width: int) -> int:
    if width <= 0:
        return 0
    if max_value <= 0:
        return 0
    # keep at least 0; round to nearest int, similar to reference feel
    n = int(round((float(value) / float(max_value)) * width))
    if n < 0:
        n = 0
    return n


class BaseChart:
    def __init__(self, data: Data, args: Args, symbols: Optional[Sequence[str]] = None, out=None):
        self.data = data
        self.args = args
        self.symbols = list(symbols) if symbols is not None else list(_DEFAULT_SYMBOLS)
        self.out = out if out is not None else sys.stdout

    def draw(self) -> None:
        raise NotImplementedError


class BarChart(BaseChart):
    """
    Horizontal bar chart. Supports multiple series (grouped) by printing one line per series per label.
    """
    def draw(self) -> None:
        if self.args.title:
            self.out.write(str(self.args.title).rstrip("\n") + "\n")

        labels = self.data.labels
        if self.args.labels is not None:
            labels = list(map(str, self.args.labels))
        if not labels:
            labels = ["" for _ in range(self.data.n_rows)]

        lw = 0 if self.args.no_labels else _label_width(labels)
        # Normalize scaling
        if self.args.different_scale:
            series_max = self.data.max_value_per_series()
        else:
            global_max = self.data.max_value()
            series_max = [global_max for _ in range(self.data.n_series)]

        for i in range(self.data.n_rows):
            label = _safe_label(labels[i]) if i < len(labels) else ""
            prefix = ""
            if not self.args.no_labels:
                prefix = f"{label:<{lw}}: "
            row_vals = self.data.values_for_row(i) if self.data.n_series else []
            if not row_vals:
                self.out.write(prefix.rstrip() + "\n")
                continue

            for s_idx, v in enumerate(row_vals):
                sym = self.symbols[s_idx % len(self.symbols)]
                maxv = series_max[s_idx] if s_idx < len(series_max) else (self.data.max_value() or 1.0)
                bar_len = _scale(v, maxv, self.args.width)
                bar = sym * bar_len

                line = prefix + bar
                if not self.args.no_values:
                    val_txt = _fmt_value(self.args.format, v) + (self.args.suffix or "")
                    # Separate with a space if there's a bar, else still show value
                    if bar:
                        line += " " + val_txt
                    else:
                        line += val_txt
                self.out.write(line.rstrip() + "\n")

                # Only print label prefix on first series line for that label in typical termgraph,
                # but many tests just check presence/shape. We'll match common behavior:
                prefix = " " * (lw + 2) if (not self.args.no_labels) else ""


class StackedChart(BaseChart):
    """
    Horizontal stacked bar chart. For each label, prints one line with segments for each series.
    """
    def draw(self) -> None:
        if self.args.title:
            self.out.write(str(self.args.title).rstrip("\n") + "\n")

        labels = self.data.labels
        if self.args.labels is not None:
            labels = list(map(str, self.args.labels))
        if not labels:
            labels = ["" for _ in range(self.data.n_rows)]

        lw = 0 if self.args.no_labels else _label_width(labels)

        sums = self.data.sums_per_row()
        max_sum = max(sums) if sums else 0.0
        if max_sum <= 0:
            max_sum = 1.0

        for i in range(self.data.n_rows):
            label = _safe_label(labels[i]) if i < len(labels) else ""
            prefix = ""
            if not self.args.no_labels:
                prefix = f"{label:<{lw}}: "

            row_vals = self.data.values_for_row(i) if self.data.n_series else []
            # Determine segment lengths, adjusting to fit width exactly-ish
            seg_lens: List[int] = []
            for v in row_vals:
                seg_lens.append(_scale(v, max_sum, self.args.width))

            # Clamp/adjust total to not exceed width too much
            total = sum(seg_lens)
            if total > self.args.width and total > 0:
                # Reduce from the largest segments until fits
                while total > self.args.width:
                    j = max(range(len(seg_lens)), key=lambda k: seg_lens[k])
                    if seg_lens[j] <= 0:
                        break
                    seg_lens[j] -= 1
                    total -= 1

            bar_parts = []
            for s_idx, seg in enumerate(seg_lens):
                sym = self.symbols[s_idx % len(self.symbols)]
                if seg > 0:
                    bar_parts.append(sym * seg)
            bar = "".join(bar_parts)

            line = prefix + bar
            if not self.args.no_values:
                # In stacked chart, often show sum
                total_value = sum(row_vals) if row_vals else 0.0
                val_txt = _fmt_value(self.args.format, total_value) + (self.args.suffix or "")
                if bar:
                    line += " " + val_txt
                else:
                    line += val_txt

            self.out.write(line.rstrip() + "\n")
</file>

<file:name=termgraph/cli.py>
from __future__ import annotations

import argparse
import sys
from typing import List

from .args import Args
from .charts import BarChart, StackedChart
from .data import Data


def _parse_csv_numbers(s: str) -> List[float]:
    if not s.strip():
        return []
    parts = [p.strip() for p in s.split(",")]
    return [float(p) for p in parts if p != ""]


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(prog="termgraph", add_help=True)
    p.add_argument("--width", type=int, default=50)
    p.add_argument("--stacked", action="store_true")
    p.add_argument("--different-scale", dest="different_scale", action="store_true")
    p.add_argument("--no-labels", dest="no_labels", action="store_true")
    p.add_argument("--format", dest="format", default="{:<5.2f}")
    p.add_argument("--suffix", default="")
    p.add_argument("--no-values", dest="no_values", action="store_true")
    p.add_argument("--title", default=None)

    # Minimal input: labels and one or more series passed as repeated --series "1,2,3"
    p.add_argument("--labels", default=None, help="Comma-separated labels")
    p.add_argument("--series", action="append", default=None, help="Comma-separated numeric series")
    return p


def main(argv=None) -> int:
    argv = sys.argv[1:] if argv is None else argv
    parser = build_parser()
    ns = parser.parse_args(argv)

    labels = None
    if ns.labels is not None:
        labels = [x.strip() for x in str(ns.labels).split(",")]

    series = []
    if ns.series:
        for s in ns.series:
            series.append(_parse_csv_numbers(s))

    data = Data(labels=labels or [], data=series)
    args = Args(
        width=ns.width,
        stacked=ns.stacked,
        different_scale=ns.different_scale,
        no_labels=ns.no_labels,
        format=ns.format,
        suffix=ns.suffix,
        no_values=ns.no_values,
        labels=labels,
        title=ns.title,
    )

    chart = StackedChart(data, args) if args.stacked else BarChart(data, args)
    chart.draw()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
</file>