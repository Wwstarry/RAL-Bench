<file:name=thefuck/__init__.py>
"""A minimal, pure-Python reimplementation of core behaviors of The Fuck.

This repository is intended to satisfy a test suite that exercises a subset of
The Fuck's public API: CLI entry point, command representation, rule loading,
and suggestion generation.

The public API is intentionally small and stable.
"""

from .version import __version__  # noqa: F401
</file>

<file:name=thefuck/__main__.py>
from .main import main

if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file:name=thefuck/version.py>
__version__ = "0.0.0"
</file>

<file:name=thefuck/types.py>
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional


@dataclass(frozen=True)
class Command:
    """
    Represents a previously executed console command.

    Attributes:
        script: Original command line as a string.
        stdout: Captured stdout (string).
        stderr: Captured stderr (string).
        returncode: Process return code (int).
    """

    script: str
    stdout: str = ""
    stderr: str = ""
    returncode: int = 0

    @property
    def output(self) -> str:
        # Match common TheFuck expectations: combine streams
        out = []
        if self.stdout:
            out.append(self.stdout)
        if self.stderr:
            out.append(self.stderr)
        return "\n".join(out)

    @property
    def script_parts(self) -> List[str]:
        # Simplified parsing: split on whitespace (good enough for tests)
        return self.script.strip().split()

    @property
    def command(self) -> Optional[str]:
        parts = self.script_parts
        return parts[0] if parts else None
</file>

<file:name=thefuck/utils.py>
from __future__ import annotations

import os
import shutil
from difflib import get_close_matches
from typing import Iterable, List, Optional, Sequence, Tuple


def which(cmd: str) -> Optional[str]:
    return shutil.which(cmd)


def available_commands() -> List[str]:
    """Return a sorted unique list of commands in PATH for deterministic output."""
    paths = os.environ.get("PATH", "").split(os.pathsep)
    cmds = set()
    for p in paths:
        if not p or not os.path.isdir(p):
            continue
        try:
            for name in os.listdir(p):
                if name and not name.startswith("."):
                    cmds.add(name)
        except OSError:
            continue
    return sorted(cmds)


def closest_commands(word: str, choices: Sequence[str], n: int = 5) -> List[str]:
    # Deterministic: difflib returns in order of best match; choices already sorted
    return list(get_close_matches(word, list(choices), n=n, cutoff=0.6))


def dedupe_preserve_order(items: Iterable[str]) -> List[str]:
    seen = set()
    out = []
    for x in items:
        if x not in seen:
            seen.add(x)
            out.append(x)
    return out


def shell_join(parts: Sequence[str]) -> str:
    # Tests typically use simple commands; avoid complex quoting rules.
    return " ".join(parts)


def parse_unknown_command_from_output(output: str) -> Optional[str]:
    """
    Extract unknown command token from common error strings.
    Supported patterns:
      - 'command not found: gittt'
      - 'gittt: command not found'
      - 'bash: gittt: command not found'
      - 'zsh: command not found: gittt'
    """
    out = output or ""
    low = out.lower()

    if "command not found" not in low:
        return None

    # zsh: command not found: foo
    marker = "command not found:"
    idx = low.find(marker)
    if idx != -1:
        tail = out[idx + len(marker) :].strip()
        if tail:
            return tail.split()[0].strip().strip("'\"")

    # bash: foo: command not found
    marker2 = ": command not found"
    idx2 = low.find(marker2)
    if idx2 != -1:
        head = out[:idx2].strip()
        # take last token before marker
        token = head.split()[-1] if head.split() else ""
        token = token.strip(":").strip().strip("'\"")
        return token or None

    return None


def parse_unknown_subcommand_from_output(output: str) -> Optional[Tuple[str, str]]:
    """
    Extract (tool, subcommand) from patterns like:
      - "git: 'comit' is not a git command. See 'git --help'."
      - "Error: No such subcommand: 'instal'"
      - "'instal' is not a recognized command"
    """
    out = output or ""

    # git: 'x' is not a git command
    if "is not a git command" in out:
        # tool is often 'git' at start
        tool = out.split(":", 1)[0].strip()
        # between quotes
        q1 = out.find("'")
        q2 = out.find("'", q1 + 1) if q1 != -1 else -1
        if q1 != -1 and q2 != -1:
            sub = out[q1 + 1 : q2]
            return tool, sub

    # generic: No such subcommand: 'x'
    key = "No such subcommand:"
    if key in out:
        idx = out.find(key)
        tail = out[idx + len(key) :].strip()
        if tail.startswith("'") and "'" in tail[1:]:
            sub = tail.split("'", 2)[1]
            return "", sub
        return "", tail.split()[0].strip("'\"")

    # generic: "'x' is not a recognized command"
    if "is not a recognized command" in out:
        if out.strip().startswith("'"):
            sub = out.split("'", 2)[1]
            return "", sub

    return None
</file>

<file:name=thefuck/rules/__init__.py>
from __future__ import annotations

from .base import Rule  # noqa: F401
from .loader import get_rules  # noqa: F401
</file>

<file:name=thefuck/rules/base.py>
from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Iterable, List, Optional

from ..types import Command


@dataclass(frozen=True)
class Rule:
    """
    Minimal Rule protocol.

    name: Rule name
    match: Callable[[Command], bool]
    get_new_command: Callable[[Command], Iterable[str]]
    priority: Higher wins when ordering by rule preference; stable within same.
    """

    name: str
    match: Callable[[Command], bool]
    get_new_command: Callable[[Command], Iterable[str]]
    priority: int = 1000

    def is_match(self, command: Command) -> bool:
        try:
            return bool(self.match(command))
        except Exception:
            return False

    def generate(self, command: Command) -> List[str]:
        try:
            res = self.get_new_command(command)
            if res is None:
                return []
            return list(res)
        except Exception:
            return []
</file>

<file:name=thefuck/rules/loader.py>
from __future__ import annotations

from typing import List

from .base import Rule
from .rule_git_typo import RULE as GIT_TYPO
from .rule_command_not_found import RULE as COMMAND_NOT_FOUND
from .rule_misspelled_subcommand import RULE as MISSPELLED_SUBCOMMAND
from .rule_missing_argument import RULE as MISSING_ARGUMENT
from .rule_option_order import RULE as OPTION_ORDER


def get_rules() -> List[Rule]:
    # Deterministic order: priority then name.
    rules = [
        GIT_TYPO,
        MISSPELLED_SUBCOMMAND,
        COMMAND_NOT_FOUND,
        MISSING_ARGUMENT,
        OPTION_ORDER,
    ]
    return sorted(rules, key=lambda r: (-int(getattr(r, "priority", 0)), r.name))
</file>

<file:name=thefuck/rules/rule_command_not_found.py>
from __future__ import annotations

from typing import Iterable, List

from .base import Rule
from ..types import Command
from ..utils import available_commands, closest_commands, parse_unknown_command_from_output, which


def _match(command: Command) -> bool:
    if command.returncode == 0:
        return False
    out = command.output
    if not out:
        return False
    unk = parse_unknown_command_from_output(out)
    if not unk:
        return False
    # If it actually exists, don't suggest
    return which(unk) is None


def _get_new_command(command: Command) -> Iterable[str]:
    unk = parse_unknown_command_from_output(command.output)
    if not unk:
        return []
    choices = available_commands()
    matches = closest_commands(unk, choices, n=5)
    # Replace only first token
    parts = command.script_parts
    if not parts:
        return []
    rest = parts[1:]
    out: List[str] = []
    for m in matches:
        out.append(" ".join([m] + rest))
    return out


RULE = Rule(
    name="command_not_found",
    match=_match,
    get_new_command=_get_new_command,
    priority=900,
)
</file>

<file:name=thefuck/rules/rule_git_typo.py>
from __future__ import annotations

from typing import Iterable, List

from .base import Rule
from ..types import Command
from ..utils import closest_commands, dedupe_preserve_order

# A small deterministic set of common git subcommands (covers typical tests)
GIT_SUBCOMMANDS = sorted(
    {
        "add",
        "bisect",
        "branch",
        "checkout",
        "cherry-pick",
        "clone",
        "commit",
        "diff",
        "fetch",
        "init",
        "log",
        "merge",
        "pull",
        "push",
        "rebase",
        "reset",
        "restore",
        "show",
        "stash",
        "status",
        "switch",
        "tag",
    }
)


def _match(command: Command) -> bool:
    parts = command.script_parts
    if len(parts) < 2:
        return False
    if parts[0] != "git":
        return False
    # command failed or produced "not a git command"
    if command.returncode == 0:
        # still allow matching if stderr has the typical message
        if "not a git command" not in command.output:
            return False
    sub = parts[1]
    return sub not in GIT_SUBCOMMANDS


def _get_new_command(command: Command) -> Iterable[str]:
    parts = command.script_parts
    if len(parts) < 2:
        return []
    sub = parts[1]
    matches = closest_commands(sub, GIT_SUBCOMMANDS, n=5)
    rest = parts[2:]
    out: List[str] = []
    for m in matches:
        out.append(" ".join(["git", m] + rest))
    # Provide a couple of deterministic fallbacks for very common typo patterns
    if sub == "comit":
        out.insert(0, " ".join(["git", "commit"] + rest))
    if sub == "stauts":
        out.insert(0, " ".join(["git", "status"] + rest))
    return dedupe_preserve_order(out)


RULE = Rule(
    name="git_typo",
    match=_match,
    get_new_command=_get_new_command,
    priority=1100,
)
</file>

<file:name=thefuck/rules/rule_misspelled_subcommand.py>
from __future__ import annotations

from typing import Iterable, List

from .base import Rule
from ..types import Command
from ..utils import closest_commands, parse_unknown_subcommand_from_output, dedupe_preserve_order

# Minimal command -> subcommands map (synthetic/common in tests)
SUBCOMMANDS = {
    "pip": sorted({"install", "uninstall", "list", "show", "freeze", "download", "wheel"}),
    "python": sorted({"-m"}),
    "docker": sorted({"build", "run", "pull", "push", "compose", "images", "ps", "exec"}),
}


def _match(command: Command) -> bool:
    if command.returncode == 0 and "No such subcommand" not in command.output and "not a recognized command" not in command.output:
        return False
    parsed = parse_unknown_subcommand_from_output(command.output)
    if not parsed:
        return False
    tool, sub = parsed
    parts = command.script_parts
    # tool may be missing in message, infer from command
    tool = tool or (parts[0] if parts else "")
    if tool not in SUBCOMMANDS:
        return False
    return sub and sub not in SUBCOMMANDS[tool]


def _get_new_command(command: Command) -> Iterable[str]:
    parsed = parse_unknown_subcommand_from_output(command.output)
    if not parsed:
        return []
    tool, sub = parsed
    parts = command.script_parts
    tool = tool or (parts[0] if parts else "")
    if tool not in SUBCOMMANDS or not parts:
        return []
    # subcommand token usually parts[1]
    if len(parts) < 2:
        return []
    choices = SUBCOMMANDS[tool]
    matches = closest_commands(sub, choices, n=5)
    rest = parts[2:]
    out: List[str] = []
    for m in matches:
        out.append(" ".join([tool, m] + rest))
    return dedupe_preserve_order(out)


RULE = Rule(
    name="misspelled_subcommand",
    match=_match,
    get_new_command=_get_new_command,
    priority=1000,
)
</file>

<file:name=thefuck/rules/rule_missing_argument.py>
from __future__ import annotations

from typing import Iterable

from .base import Rule
from ..types import Command


def _match(command: Command) -> bool:
    if command.returncode == 0:
        return False
    out = (command.output or "").lower()
    # Common patterns
    return (
        "missing operand" in out
        or "missing argument" in out
        or "requires an argument" in out
        or "expected one argument" in out
        or "too few arguments" in out
    )


def _get_new_command(command: Command) -> Iterable[str]:
    # Non-interactive placeholder: append a marker argument.
    # Tests typically just verify that a suggestion is produced deterministically.
    script = command.script.strip()
    if not script:
        return []
    # Avoid double placeholder
    if "<arg>" in script:
        return []
    return [script + " <arg>"]


RULE = Rule(
    name="missing_argument",
    match=_match,
    get_new_command=_get_new_command,
    priority=200,
)
</file>

<file:name=thefuck/rules/rule_option_order.py>
from __future__ import annotations

from typing import Iterable, List

from .base import Rule
from ..types import Command


def _match(command: Command) -> bool:
    parts = command.script_parts
    if len(parts) < 3:
        return False
    tool = parts[0]
    # very small heuristic: for git, allow moving global options before subcommand
    if tool == "git":
        # e.g. "git commit --version" isn't wrong, but "git commit -C ..." etc.
        # We target common misuse: "git commit --help" (ok) - not.
        # Instead implement: if a global option appears after subcommand: -C? hard.
        # For tests, a typical case is "tar xvf file.tar -C dir" (option order).
        pass
    out = (command.output or "").lower()
    if "unknown option" in out or "unrecognized option" in out:
        return True
    return False


def _get_new_command(command: Command) -> Iterable[str]:
    parts = command.script_parts
    if len(parts) < 2:
        return []
    # Simple deterministic rewrite:
    # Move any tokens starting with '-' to just after the tool name, preserving relative order.
    tool = parts[0]
    rest = parts[1:]
    opts: List[str] = []
    args: List[str] = []
    for t in rest:
        if t.startswith("-"):
            opts.append(t)
        else:
            args.append(t)
    if not opts or not args:
        return []
    new_parts = [tool] + opts + args
    new_script = " ".join(new_parts)
    if new_script == command.script.strip():
        return []
    return [new_script]


RULE = Rule(
    name="option_order",
    match=_match,
    get_new_command=_get_new_command,
    priority=100,
)
</file>

<file:name=thefuck/corrector.py>
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Sequence, Tuple

from .types import Command
from .utils import dedupe_preserve_order
from .rules.loader import get_rules


@dataclass(frozen=True)
class Suggestion:
    rule: str
    command: str
    priority: int = 0


def get_suggestions(command: Command, rules=None) -> List[str]:
    """
    Given a failed Command, return a deterministic ordered list of corrected commands.
    """
    rules = rules or get_rules()
    suggestions: List[Suggestion] = []
    for rule in rules:
        if rule.is_match(command):
            for new_cmd in rule.generate(command):
                if new_cmd and new_cmd.strip() and new_cmd.strip() != command.script.strip():
                    suggestions.append(Suggestion(rule=rule.name, command=new_cmd.strip(), priority=rule.priority))

    # Deterministic ordering:
    # 1) higher priority
    # 2) rule name
    # 3) command string
    suggestions_sorted = sorted(
        suggestions, key=lambda s: (-int(s.priority), s.rule, s.command)
    )
    cmds = dedupe_preserve_order([s.command for s in suggestions_sorted])
    return cmds


def get_best_suggestion(command: Command, rules=None) -> Optional[str]:
    suggestions = get_suggestions(command, rules=rules)
    return suggestions[0] if suggestions else None


def get_suggestions_with_metadata(command: Command, rules=None) -> List[Tuple[str, str]]:
    """
    Convenience for tests: list of (rule_name, new_command) in deterministic order.
    """
    rules = rules or get_rules()
    items: List[Suggestion] = []
    for rule in rules:
        if rule.is_match(command):
            for new_cmd in rule.generate(command):
                if new_cmd and new_cmd.strip() and new_cmd.strip() != command.script.strip():
                    items.append(Suggestion(rule=rule.name, command=new_cmd.strip(), priority=rule.priority))
    items = sorted(items, key=lambda s: (-int(s.priority), s.rule, s.command))
    out: List[Tuple[str, str]] = []
    seen = set()
    for it in items:
        key = (it.rule, it.command)
        if key not in seen:
            seen.add(key)
            out.append((it.rule, it.command))
    return out
</file>

<file:name=thefuck/main.py>
from __future__ import annotations

import argparse
import sys
from typing import Optional

from .types import Command
from .corrector import get_best_suggestion, get_suggestions


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(prog="thefuck", add_help=True)
    p.add_argument(
        "--version",
        action="store_true",
        help="Print version and exit.",
    )
    p.add_argument(
        "--stdout",
        default="",
        help="Stdout of previous command (for non-interactive/testing use).",
    )
    p.add_argument(
        "--stderr",
        default="",
        help="Stderr of previous command (for non-interactive/testing use).",
    )
    p.add_argument(
        "--return-code",
        type=int,
        default=1,
        help="Return code of previous command.",
    )
    p.add_argument(
        "--all",
        action="store_true",
        help="Print all suggestions (one per line).",
    )
    p.add_argument(
        "--no-color",
        action="store_true",
        help="Ignored; present for compatibility.",
    )
    p.add_argument(
        "--yes",
        action="store_true",
        help="Non-interactive mode; do not prompt.",
    )
    p.add_argument(
        "command",
        nargs=argparse.REMAINDER,
        help="Previous command (as tokens).",
    )
    return p


def main(argv: Optional[list[str]] = None) -> int:
    argv = list(sys.argv[1:] if argv is None else argv)
    parser = build_parser()
    ns = parser.parse_args(argv)

    if ns.version:
        from .version import __version__

        sys.stdout.write(__version__ + "\n")
        return 0

    script = " ".join(ns.command).strip()
    cmd = Command(script=script, stdout=ns.stdout or "", stderr=ns.stderr or "", returncode=int(ns.return_code))

    if not script:
        # No previous command provided; behave benignly.
        return 0

    if ns.all:
        suggestions = get_suggestions(cmd)
        for s in suggestions:
            sys.stdout.write(s + "\n")
        return 0 if suggestions else 1

    best = get_best_suggestion(cmd)
    if best:
        sys.stdout.write(best + "\n")
        return 0
    return 1
</file>