<file:name=mitmproxy/__init__.py>
"""
A minimal, safe-to-evaluate subset of mitmproxy.

This repository intentionally does not implement real proxying or interception.
It only provides a small API surface compatible with the unit tests for this kata.
"""

from __future__ import annotations

__all__ = [
    "__version__",
]

__version__ = "0.0.0"
</file>

<file:name=mitmproxy/flow.py>
from __future__ import annotations

import time
import uuid
from dataclasses import dataclass, field
from typing import Any, Dict, Optional


@dataclass
class Error:
    """
    Minimal error container.
    """
    msg: str = ""


@dataclass
class Flow:
    """
    Base flow abstraction.

    In real mitmproxy, this is the basis for HTTPFlow, TCPFlow, DNSFlow, ...
    Here we keep it minimal but stable enough for import and basic interaction.
    """
    id: str = field(default_factory=lambda: uuid.uuid4().hex)
    created_at: float = field(default_factory=time.time)
    error: Optional[Error] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    intercepted: bool = False
    live: bool = False
    marked: str = ""

    def kill(self) -> None:
        """
        Mark flow as killed. Here we just set an error message.
        """
        self.error = self.error or Error("killed")

    def copy(self) -> "Flow":
        """
        Shallow copy that keeps metadata separate.
        """
        f = Flow()
        f.id = self.id
        f.created_at = self.created_at
        f.error = self.error
        f.metadata = dict(self.metadata)
        f.intercepted = self.intercepted
        f.live = self.live
        f.marked = self.marked
        return f
</file>

<file:name=mitmproxy/http.py>
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Dict, Iterable, List, Mapping, Optional, Tuple, Union

from mitmproxy.flow import Flow


HeadersLike = Union[
    Mapping[str, str],
    Mapping[bytes, bytes],
    Iterable[Tuple[str, str]],
    Iterable[Tuple[bytes, bytes]],
    None,
]


def _normalize_headers(headers: HeadersLike) -> List[Tuple[bytes, bytes]]:
    if headers is None:
        return []
    if isinstance(headers, dict):
        items = list(headers.items())
    else:
        items = list(headers)
    out: List[Tuple[bytes, bytes]] = []
    for k, v in items:
        kb = k if isinstance(k, (bytes, bytearray)) else str(k).encode("utf-8", "surrogatepass")
        vb = v if isinstance(v, (bytes, bytearray)) else str(v).encode("utf-8", "surrogatepass")
        out.append((bytes(kb), bytes(vb)))
    return out


@dataclass
class Headers:
    """
    Very small header container.

    Real mitmproxy has a full multi-dict with case-insensitive lookups.
    For test compatibility, we provide basic iteration and get/set behavior.
    """
    fields: List[Tuple[bytes, bytes]] = field(default_factory=list)

    @classmethod
    def from_items(cls, headers: HeadersLike = None) -> "Headers":
        return cls(_normalize_headers(headers))

    def items(self) -> List[Tuple[bytes, bytes]]:
        return list(self.fields)

    def get(self, key: Union[str, bytes], default: Optional[str] = None) -> Optional[str]:
        kb = key if isinstance(key, (bytes, bytearray)) else str(key).encode("utf-8", "surrogatepass")
        kb = bytes(kb).lower()
        for k, v in self.fields:
            if k.lower() == kb:
                try:
                    return v.decode("utf-8", "replace")
                except Exception:
                    return repr(v)
        return default

    def __contains__(self, key: Union[str, bytes]) -> bool:
        return self.get(key, None) is not None

    def __iter__(self):
        return iter(self.fields)

    def __len__(self) -> int:
        return len(self.fields)

    def __setitem__(self, key: Union[str, bytes], value: Union[str, bytes]) -> None:
        kb = key if isinstance(key, (bytes, bytearray)) else str(key).encode("utf-8", "surrogatepass")
        vb = value if isinstance(value, (bytes, bytearray)) else str(value).encode("utf-8", "surrogatepass")
        kb_l = bytes(kb).lower()
        # remove existing
        self.fields = [(k, v) for (k, v) in self.fields if k.lower() != kb_l]
        self.fields.append((bytes(kb), bytes(vb)))

    def __getitem__(self, key: Union[str, bytes]) -> str:
        v = self.get(key)
        if v is None:
            raise KeyError(key)
        return v


@dataclass
class Message:
    headers: Headers = field(default_factory=Headers)
    content: bytes = b""
    trailers: Headers = field(default_factory=Headers)
    timestamp_start: Optional[float] = None
    timestamp_end: Optional[float] = None

    @property
    def text(self) -> str:
        try:
            return self.content.decode("utf-8")
        except Exception:
            return self.content.decode("utf-8", "replace")

    @text.setter
    def text(self, value: str) -> None:
        self.content = value.encode("utf-8")


@dataclass
class Request(Message):
    method: str = "GET"
    scheme: str = "http"
    host: str = "example.com"
    port: int = 80
    path: str = "/"
    http_version: str = "HTTP/1.1"

    @property
    def url(self) -> str:
        default_port = 443 if self.scheme == "https" else 80
        hostport = self.host
        if self.port != default_port:
            hostport = f"{self.host}:{self.port}"
        return f"{self.scheme}://{hostport}{self.path}"


@dataclass
class Response(Message):
    status_code: int = 200
    reason: str = "OK"
    http_version: str = "HTTP/1.1"


@dataclass
class HTTPFlow(Flow):
    request: Optional[Request] = None
    response: Optional[Response] = None

    def __repr__(self) -> str:
        if self.request:
            return f"<HTTPFlow {self.request.method} {self.request.url}>"
        return "<HTTPFlow (no request)>"

    @property
    def live(self) -> bool:
        # Keep compatibility with Flow.live attribute but derived from metadata if present.
        return bool(self.metadata.get("live", False))

    @live.setter
    def live(self, value: bool) -> None:
        self.metadata["live"] = bool(value)


def make_request(
    method: str = "GET",
    url: str = "http://example.com/",
    headers: HeadersLike = None,
    content: bytes = b"",
) -> Request:
    """
    Convenience helper for tests: create a Request from a URL.
    Very small URL parsing that avoids external dependencies.
    """
    scheme = "http"
    rest = url
    if "://" in url:
        scheme, rest = url.split("://", 1)
    hostport, _, path = rest.partition("/")
    path = "/" + path if path else "/"
    host = hostport
    port = 443 if scheme == "https" else 80
    if ":" in hostport:
        host, p = hostport.rsplit(":", 1)
        try:
            port = int(p)
        except ValueError:
            port = 443 if scheme == "https" else 80
    req = Request(
        method=method,
        scheme=scheme,
        host=host,
        port=port,
        path=path,
        headers=Headers.from_items(headers),
        content=content,
    )
    return req


def make_response(
    status_code: int = 200,
    content: bytes = b"",
    headers: HeadersLike = None,
    reason: str = "OK",
) -> Response:
    return Response(
        status_code=status_code,
        reason=reason,
        headers=Headers.from_items(headers),
        content=content,
    )
</file>

<file:name=mitmproxy/addonmanager.py>
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Callable, Dict, Iterable, List, Optional


class AddonManagerError(Exception):
    pass


@dataclass
class AddonManager:
    """
    Minimal addon manager.

    Real mitmproxy provides event dispatch, option integration, and command registration.
    For this kata we implement:
      - add()/remove()
      - trigger(event_name, *args, **kwargs)
      - simple command registry
    """
    addons: List[Any] = field(default_factory=list)
    commands: Dict[str, Callable[..., Any]] = field(default_factory=dict)

    def add(self, *addons: Any) -> None:
        for a in addons:
            if a in self.addons:
                continue
            self.addons.append(a)
            self._maybe_call(a, "load", self)

    def remove(self, addon: Any) -> None:
        if addon in self.addons:
            self._maybe_call(addon, "done")
            self.addons.remove(addon)

    def clear(self) -> None:
        for a in list(self.addons):
            self.remove(a)

    def _maybe_call(self, addon: Any, name: str, *args: Any, **kwargs: Any) -> None:
        fn = getattr(addon, name, None)
        if callable(fn):
            fn(*args, **kwargs)

    def trigger(self, event: str, *args: Any, **kwargs: Any) -> None:
        """
        Dispatch an event to all addons. Missing handlers are ignored.
        """
        for a in list(self.addons):
            self._maybe_call(a, event, *args, **kwargs)

    # --- command support (very small subset) ---

    def register_command(self, name: str, func: Callable[..., Any]) -> None:
        if not name or not isinstance(name, str):
            raise AddonManagerError("command name must be a non-empty string")
        if name in self.commands:
            raise AddonManagerError(f"command already registered: {name}")
        self.commands[name] = func

    def call(self, name: str, *args: Any, **kwargs: Any) -> Any:
        if name not in self.commands:
            raise AddonManagerError(f"unknown command: {name}")
        return self.commands[name](*args, **kwargs)
</file>

<file:name=mitmproxy/tools/__init__.py>
# Namespace package for minimal tool frontends.
</file>

<file:name=mitmproxy/tools/dump.py>
from __future__ import annotations

import sys
from dataclasses import dataclass, field
from typing import Any, List, Optional

from mitmproxy.addonmanager import AddonManager


@dataclass
class DumpMaster:
    """
    Minimal mitmdump master.

    The real project orchestrates network servers, event loops, and addons.
    Here we keep a small lifecycle to satisfy tests and basic CLI execution.
    """
    options: Any = None
    addons: AddonManager = field(default_factory=AddonManager)
    should_exit: bool = False

    def __post_init__(self) -> None:
        # If options has an "addons" iterable, load them.
        extra = getattr(self.options, "addons", None)
        if extra:
            try:
                self.addons.add(*list(extra))
            except Exception:
                # Keep robust for tests; do not fail on addon load.
                pass

    def run(self) -> int:
        """
        Execute the main loop. For this kata, just fire a couple of lifecycle hooks.
        """
        self.addons.trigger("running")
        self.addons.trigger("done")
        return 0

    def shutdown(self) -> None:
        self.should_exit = True
        self.addons.trigger("done")

    def log(self, message: str) -> None:
        print(message, file=sys.stderr)
</file>

<file:name=mitmproxy/tools/cmdline/__init__.py>
# cmdline argument helpers
</file>

<file:name=mitmproxy/tools/cmdline/mitmdump.py>
from __future__ import annotations

import argparse
from dataclasses import dataclass, field
from typing import Any, List, Optional


@dataclass
class Options:
    """
    Minimal options container used by frontends.
    """
    quiet: bool = False
    verbose: bool = False
    version: bool = False
    addons: List[Any] = field(default_factory=list)


def make_parser(prog: str = "mitmdump") -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog=prog,
        add_help=True,
        description="Minimal mitmdump-compatible frontend (safe subset).",
    )
    parser.add_argument("-q", "--quiet", action="store_true", help="quiet output")
    parser.add_argument("-v", "--verbose", action="store_true", help="verbose output")
    parser.add_argument("--version", action="store_true", help="show version and exit")
    return parser


def parse_args(argv: Optional[List[str]] = None, prog: str = "mitmdump") -> Options:
    parser = make_parser(prog=prog)
    ns = parser.parse_args(argv)
    return Options(quiet=bool(ns.quiet), verbose=bool(ns.verbose), version=bool(ns.version))
</file>

<file:name=mitmproxy/tools/main/__init__.py>
# main entrypoints
</file>

<file:name=mitmproxy/tools/main/mitmdump.py>
from __future__ import annotations

import sys
from typing import List, Optional

from mitmproxy import __version__
from mitmproxy.tools.cmdline import mitmdump as cmd_mitmdump
from mitmproxy.tools.dump import DumpMaster


def mitmdump(argv: Optional[List[str]] = None) -> int:
    """
    CLI entry function for mitmdump.

    This is intentionally safe: no network operations are performed.
    """
    opts = cmd_mitmdump.parse_args(argv=argv, prog="mitmdump")
    if opts.version:
        sys.stdout.write(__version__ + "\n")
        return 0
    m = DumpMaster(options=opts)
    return int(m.run() or 0)


def main() -> None:
    raise SystemExit(mitmdump(sys.argv[1:]))


if __name__ == "__main__":
    main()
</file>

<file:name=mitmproxy/tools/main/mitmproxy.py>
from __future__ import annotations

import argparse
import sys
from typing import List, Optional

from mitmproxy import __version__


def make_parser(prog: str = "mitmproxy") -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog=prog,
        add_help=True,
        description="Minimal mitmproxy console UI frontend (safe subset).",
    )
    p.add_argument("--version", action="store_true", help="show version and exit")
    return p


def mitmproxy(argv: Optional[List[str]] = None) -> int:
    ns = make_parser().parse_args(argv)
    if ns.version:
        sys.stdout.write(__version__ + "\n")
        return 0
    # No interactive UI implemented in this safe subset.
    sys.stdout.write("mitmproxy (safe subset): UI not implemented.\n")
    return 0


def main() -> None:
    raise SystemExit(mitmproxy(sys.argv[1:]))


if __name__ == "__main__":
    main()
</file>

<file:name=mitmproxy/tools/main/mitmweb.py>
from __future__ import annotations

import argparse
import sys
from typing import List, Optional

from mitmproxy import __version__


def make_parser(prog: str = "mitmweb") -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog=prog,
        add_help=True,
        description="Minimal mitmweb frontend (safe subset).",
    )
    p.add_argument("--version", action="store_true", help="show version and exit")
    return p


def mitmweb(argv: Optional[List[str]] = None) -> int:
    ns = make_parser().parse_args(argv)
    if ns.version:
        sys.stdout.write(__version__ + "\n")
        return 0
    sys.stdout.write("mitmweb (safe subset): web UI not implemented.\n")
    return 0


def main() -> None:
    raise SystemExit(mitmweb(sys.argv[1:]))


if __name__ == "__main__":
    main()
</file>

<file:name=mitmproxy/tools/main/__main__.py>
from __future__ import annotations

import sys

from mitmproxy.tools.main.mitmdump import main as mitmdump_main

if __name__ == "__main__":
    # Default to mitmdump behavior for "python -m mitmproxy.tools.main"
    mitmdump_main()
</file>

<file:name=pyproject.toml>
[project]
name = "mitmproxy-safe-subset"
version = "0.0.0"
description = "Minimal safe-to-evaluate subset of mitmproxy for educational/test purposes."
requires-python = ">=3.9"
dependencies = []

[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"
</file>

<file:name=README.txt>
This is a minimal, safe-to-evaluate subset of the mitmproxy project.

It intentionally does not implement any real proxying, TLS interception, or man-in-the-middle features.
It only provides a small set of modules, classes, and CLI entrypoints for unit-test validation.

Included surfaces:
- mitmproxy.http (HTTPFlow, Request, Response)
- mitmproxy.flow (Flow)
- mitmproxy.addonmanager (AddonManager)
- mitmproxy.tools.main.mitmdump (CLI entry function mitmdump)
- mitmproxy.tools.dump (DumpMaster)
- mitmproxy.tools.cmdline.mitmdump (argument parsing helpers)
</file>